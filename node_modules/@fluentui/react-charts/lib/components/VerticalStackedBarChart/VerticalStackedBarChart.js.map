{"version":3,"sources":["../src/components/VerticalStackedBarChart/VerticalStackedBarChart.tsx"],"sourcesContent":["'use client';\n\nimport * as React from 'react';\nimport { max as d3Max, min as d3Min } from 'd3-array';\nimport { select as d3Select } from 'd3-selection';\nimport { useVerticalStackedBarChartStyles } from './useVerticalStackedBarChartStyles.styles';\nimport {\n  scaleLinear as d3ScaleLinear,\n  ScaleLinear as D3ScaleLinear,\n  scaleBand as d3ScaleBand,\n  scaleUtc as d3ScaleUtc,\n  scaleTime as d3ScaleTime,\n  ScaleBand,\n} from 'd3-scale';\nimport { useId } from '@fluentui/react-utilities';\nimport type { JSXElement } from '@fluentui/react-utilities';\nimport { tokens } from '@fluentui/react-theme';\nimport {\n  AccessibilityProps,\n  CartesianChart,\n  ChildProps,\n  VerticalStackedBarDataPoint,\n  Margins,\n  VerticalStackedBarChartProps,\n  VerticalStackedChartProps,\n  VSChartDataPoint,\n  LineDataInVerticalStackedBarChart,\n  ModifiedCartesianChartProps,\n  Legend,\n  ChartPopover,\n  Legends,\n  Chart,\n  DataPoint,\n  ImageExportOptions,\n  LegendContainer,\n} from '../../index';\nimport {\n  ChartTypes,\n  IAxisData,\n  getAccessibleDataObject,\n  XAxisTypes,\n  getTypeOfAxis,\n  tooltipOfAxislabels,\n  formatScientificLimitWidth,\n  getBarWidth,\n  getScalePadding,\n  isScalePaddingDefined,\n  calculateAppropriateBarWidth,\n  areArraysEqual,\n  calculateLongestLabelWidth,\n  useRtl,\n  DataVizPalette,\n  getColorFromToken,\n  findVSBCNumericMinMaxOfY,\n  YAxisType,\n  createNumericYAxis,\n  IDomainNRange,\n  domainRangeOfDateForAreaLineScatterVerticalBarCharts,\n  domainRangeOfVSBCNumeric,\n  domainRangeOfXStringAxis,\n  createStringYAxis,\n  calcTotalWidth,\n  calcBandwidth,\n  calcRequiredWidth,\n  sortAxisCategories,\n} from '../../utilities/index';\nimport { toImage } from '../../utilities/image-export-utils';\nimport { formatDateToLocaleString } from '@fluentui/chart-utilities';\n\ntype NumericScale = D3ScaleLinear<number, number>;\ntype StringScale = ScaleBand<string>;\nconst barGapMultiplier = 0.2;\nconst barGapMin = 1;\nconst MIN_DOMAIN_MARGIN = 8;\n\ninterface RefArrayData {\n  refElement?: SVGGElement | null;\n}\n\ntype LinePoint = LineDataInVerticalStackedBarChart & { index: number; xItem: VerticalStackedChartProps };\ntype LineObject = { [key: string]: LinePoint[] };\ntype LineLegends = {\n  title: string;\n  color: string;\n};\ntype CalloutAnchorPointData = {\n  xAxisDataPoint: string;\n  chartDataPoint: VSChartDataPoint;\n};\n\nexport const VerticalStackedBarChart: React.FunctionComponent<VerticalStackedBarChartProps> = React.forwardRef<\n  HTMLDivElement,\n  VerticalStackedBarChartProps\n>((_props, forwardedRef) => {\n  const props: VerticalStackedBarChartProps = {\n    xAxisCategoryOrder: 'default',\n    yAxisCategoryOrder: 'default',\n    maxBarWidth: 24,\n    ..._props,\n  };\n  const _isRtl: boolean = useRtl();\n  const _createLegendsForLine: (data: VerticalStackedChartProps[]) => LineLegends[] = (\n    data: VerticalStackedChartProps[],\n  ) => _getLineLegends(data);\n  const _tooltipId: string = useId('VSBCTooltipId_');\n  const _emptyChartId: string = useId('_VSBC_empty');\n  let _points: VerticalStackedChartProps[] = [];\n  let _dataset: VerticalStackedBarDataPoint[];\n  let _xAxisLabels: string[] = [];\n  let _bars: JSXElement[];\n  let _xAxisType: XAxisTypes =\n    props.data! && props.data!.length > 0\n      ? (getTypeOfAxis(props.data[0]!.xAxisPoint, true) as XAxisTypes)\n      : XAxisTypes.StringAxis;\n  let _barWidth: number = 0;\n  let _colors: string[];\n  let _margins: Margins;\n  let _lineObject: LineObject;\n  let _yMax: number;\n  let _yMin: number;\n  let _calloutAnchorPoint: CalloutAnchorPointData | null;\n  let _domainMargin: number = MIN_DOMAIN_MARGIN;\n  let _xAxisInnerPadding: number = 0;\n  let _xAxisOuterPadding: number = 0;\n  const cartesianChartRef = React.useRef<Chart>(null);\n  const Y_ORIGIN: number = 0;\n  const _legendsRef = React.useRef<LegendContainer>(null);\n  let _yAxisType: YAxisType;\n  let _yAxisLabels: string[] = [];\n\n  const [selectedLegends, setSelectedLegends] = React.useState(props.legendProps?.selectedLegends || []);\n  const [activeLegend, setActiveLegend] = React.useState<string | undefined>(undefined);\n  const [dataForHoverCard, setDataForHoverCard] = React.useState(0);\n  const [color, setColor] = React.useState('');\n  const [hoverXValue, setHoverXValue] = React.useState<string | number>('');\n  const [YValueHover, setYValueHover] = React.useState<(LineDataInVerticalStackedBarChart | VSChartDataPoint)[]>([]);\n  const [xCalloutValue, setXCalloutValue] = React.useState('');\n  const [yCalloutValue, setYCalloutValue] = React.useState('');\n  const [activeXAxisDataPoint, setActiveXAxisDataPoint] = React.useState<number | string | Date>('');\n  const [calloutLegend, setCalloutLegend] = React.useState('');\n  const [stackCalloutProps, setStackCalloutProps] = React.useState<VerticalStackedChartProps>();\n  const [dataPointCalloutProps, setDataPointCalloutProps] = React.useState<VSChartDataPoint>();\n  const [callOutAccessibilityData, setCallOutAccessibilityData] = React.useState<AccessibilityProps>();\n  const [clickPosition, setClickPosition] = React.useState({ x: 0, y: 0 });\n  const [isPopoverOpen, setPopoverOpen] = React.useState(false);\n  const prevPropsRef = React.useRef<VerticalStackedBarChartProps | null>(null);\n  React.useEffect(() => {\n    if (prevPropsRef.current) {\n      const prevProps = prevPropsRef.current;\n      if (!areArraysEqual(prevProps.legendProps?.selectedLegends, props.legendProps?.selectedLegends)) {\n        setSelectedLegends(props.legendProps?.selectedLegends || []);\n      }\n      if (prevProps.height !== props.height || prevProps.width !== props.width || prevProps.data !== props.data) {\n        _adjustProps();\n        _dataset = _createDataSetLayer();\n      }\n    }\n    prevPropsRef.current = props;\n  }, [props]);\n\n  React.useImperativeHandle(\n    props.componentRef,\n    () => ({\n      chartContainer: cartesianChartRef.current?.chartContainer ?? null,\n      toImage: (opts?: ImageExportOptions): Promise<string> => {\n        return toImage(cartesianChartRef.current?.chartContainer, _legendsRef.current?.toSVG, _isRtl, opts);\n      },\n    }),\n    [],\n  );\n\n  function _getLegendData(data: VerticalStackedChartProps[], lineLegends: LineLegends[]): JSXElement {\n    if (props.hideLegend) {\n      return <></>;\n    }\n    const defaultPalette: string[] = [\n      getColorFromToken(DataVizPalette.color6),\n      getColorFromToken(DataVizPalette.color1),\n      getColorFromToken(DataVizPalette.color5),\n      getColorFromToken(DataVizPalette.color7),\n      getColorFromToken(DataVizPalette.color10),\n    ];\n    const actions: Legend[] = [];\n    const { allowHoverOnLegend = true } = props;\n\n    data.forEach((singleChartData: VerticalStackedChartProps) => {\n      singleChartData.chartData.forEach((point: VSChartDataPoint) => {\n        const color: string = point.color ? point.color : defaultPalette[Math.floor(Math.random() * 4 + 1)];\n        const checkSimilarLegends = actions.filter((leg: Legend) => leg.title === point.legend && leg.color === color);\n        if (checkSimilarLegends!.length > 0) {\n          return;\n        }\n\n        const legend: Legend = {\n          title: point.legend,\n          color,\n          hoverAction: allowHoverOnLegend\n            ? () => {\n                _handleChartMouseLeave();\n                _onLegendHover(point.legend);\n              }\n            : undefined,\n          onMouseOutAction: allowHoverOnLegend ? () => _onLegendLeave() : undefined,\n        };\n\n        actions.push(legend);\n      });\n    });\n    const legendsOfLine: Legend[] = [];\n    if (lineLegends && lineLegends.length > 0) {\n      lineLegends.forEach((point: LineLegends) => {\n        const legend: Legend = {\n          title: point.title,\n          color: point.color,\n          isLineLegendInBarChart: true,\n          hoverAction: allowHoverOnLegend\n            ? () => {\n                _handleChartMouseLeave();\n                _onLegendHover(point.title);\n              }\n            : undefined,\n          onMouseOutAction: allowHoverOnLegend ? () => _onLegendLeave() : undefined,\n        };\n        legendsOfLine.push(legend);\n      });\n    }\n    const totalLegends: Legend[] = legendsOfLine.concat(actions);\n    return (\n      <Legends\n        legends={totalLegends}\n        enabledWrapLines={props.enabledLegendsWrapLines}\n        overflowText={props.legendsOverflowText}\n        {...props.legendProps}\n        onChange={_onLegendSelectionChange}\n        legendRef={_legendsRef}\n      />\n    );\n  }\n\n  function _getHighlightedLegend() {\n    return selectedLegends.length > 0 ? selectedLegends : activeLegend ? [activeLegend] : [];\n  }\n\n  function _lineHoverFocus(\n    lineData: LinePoint,\n    event: React.MouseEvent<SVGElement> | React.FocusEvent<SVGCircleElement, Element>,\n  ): void {\n    let clientX = 0;\n    let clientY = 0;\n    if ('clientX' in event) {\n      clientX = event.clientX;\n      clientY = event.clientY;\n    } else {\n      const boundingRect = event.target.getBoundingClientRect();\n      clientX = boundingRect.left + boundingRect.width / 2;\n      clientY = boundingRect.top + boundingRect.height / 2;\n    }\n    if (_getHighlightedLegend().length === 1) {\n      if (_noLegendHighlighted() || _isLegendHighlighted(lineData.legend)) {\n        _updatePosition(clientX, clientY);\n        setPopoverOpen(true);\n        setXCalloutValue(`${lineData.xItem.xAxisPoint}`);\n        setYCalloutValue(`${lineData.yAxisCalloutData || lineData.data || lineData.y}`);\n        setActiveXAxisDataPoint(lineData.xItem.xAxisPoint);\n        setColor(lineData.color);\n      }\n    } else {\n      _onStackHoverFocus(lineData.xItem, event as React.MouseEvent<SVGElement>);\n    }\n  }\n\n  function _onStackHoverFocus(\n    stack: VerticalStackedChartProps,\n    mouseEvent: React.MouseEvent<SVGElement> | SVGGElement,\n  ): void {\n    let clientX = 0;\n    let clientY = 0;\n    if ('clientX' in mouseEvent) {\n      clientX = mouseEvent.clientX;\n      clientY = mouseEvent.clientY;\n    } else {\n      // Handle case where mouseEvent is an SVGGElement\n      const boundingRect = mouseEvent.getBoundingClientRect();\n      clientX = boundingRect.left + boundingRect.width / 2;\n      clientY = boundingRect.top + boundingRect.height / 2;\n    }\n    if (!_noLegendHighlighted()) {\n      stack = {\n        ...stack,\n        chartData: stack.chartData.filter((dataPoint: { legend: any }) => _isLegendHighlighted(dataPoint.legend)),\n        lineData: stack.lineData?.filter((dataPoint: { legend: any }) => _isLegendHighlighted(dataPoint.legend)),\n      };\n    }\n    const lineData = stack.lineData;\n    const isLinesPresent: boolean = lineData !== undefined && lineData.length > 0;\n    if (isLinesPresent) {\n      lineData!.forEach((item: LineDataInVerticalStackedBarChart & { shouldDrawBorderBottom?: boolean }) => {\n        item.data = item.data || item.y;\n        item.shouldDrawBorderBottom = true;\n      });\n    }\n    _updatePosition(clientX, clientY);\n    setPopoverOpen(stack.chartData.length > 0 || (stack.lineData?.length ?? 0) > 0);\n    setYValueHover(\n      isLinesPresent\n        ? [...lineData!.sort((a, b) => (a.data! < b.data! ? 1 : -1)), ...stack.chartData.slice().reverse()]\n        : stack.chartData.slice().reverse(),\n    );\n    setHoverXValue(\n      stack.xAxisPoint instanceof Date\n        ? formatDateToLocaleString(stack.xAxisPoint, props.culture, props.useUTC as boolean)\n        : stack.xAxisPoint,\n    );\n    setStackCalloutProps(stack);\n    setActiveXAxisDataPoint(stack.xAxisPoint);\n    setCallOutAccessibilityData(stack.stackCallOutAccessibilityData);\n  }\n\n  function _handleChartMouseLeave(): void {\n    _calloutAnchorPoint = null;\n    setPopoverOpen(false);\n    setActiveXAxisDataPoint('');\n  }\n\n  const _onClick = (\n    data: VerticalStackedChartProps | VSChartDataPoint,\n    mouseEvent: React.MouseEvent<SVGElement>,\n  ): void => {\n    props.onBarClick?.(mouseEvent, data);\n    props.href ? (window.location.href = props.href) : '';\n  };\n\n  function _adjustProps(): void {\n    _points = props.data || [];\n    _barWidth = getBarWidth(props.barWidth, props.maxBarWidth);\n    const defaultColors: string[] = [\n      getColorFromToken(DataVizPalette.color6),\n      getColorFromToken(DataVizPalette.color1),\n      getColorFromToken(DataVizPalette.color5),\n      getColorFromToken(DataVizPalette.color7),\n      getColorFromToken(DataVizPalette.color10),\n    ];\n    _colors = defaultColors;\n    _xAxisType = getTypeOfAxis(props.data[0].xAxisPoint, true) as XAxisTypes;\n    _lineObject = _getFormattedLineData(props.data);\n    _xAxisInnerPadding = getScalePadding(\n      props.xAxisInnerPadding,\n      props.xAxisPadding,\n      _xAxisType === XAxisTypes.StringAxis ? 2 / 3 : 1 / 2,\n    );\n    _xAxisOuterPadding = getScalePadding(props.xAxisOuterPadding, props.xAxisPadding, 0);\n    _initYAxisParams();\n  }\n\n  function _createDataSetLayer(): VerticalStackedBarDataPoint[] {\n    const dataset: VerticalStackedBarDataPoint[] = _points.map(singlePointData => {\n      if (_yAxisType === YAxisType.StringAxis) {\n        return {\n          x: singlePointData.xAxisPoint,\n          y: 0,\n        };\n      }\n      let total: number = 0;\n      singlePointData.chartData!.forEach((point: VSChartDataPoint) => {\n        total = total + (point.data as number);\n      });\n      return {\n        x: singlePointData.xAxisPoint,\n        y: total,\n      };\n    });\n    _xAxisLabels = _getOrderedXAxisLabels();\n    return dataset;\n  }\n\n  function _onLegendHover(legendTitle: string): void {\n    setActiveLegend(legendTitle);\n  }\n\n  function _onLegendLeave(): void {\n    setActiveLegend(undefined);\n  }\n\n  function _onLegendSelectionChange(\n    _selectedLegends: string[],\n    event: React.MouseEvent<HTMLButtonElement>,\n    currentLegend?: Legend,\n  ): void {\n    if (props.legendProps?.canSelectMultipleLegends) {\n      setSelectedLegends(_selectedLegends);\n    } else {\n      setSelectedLegends(_selectedLegends.slice(-1));\n    }\n    if (props.legendProps?.onChange) {\n      props.legendProps.onChange(_selectedLegends, event, currentLegend);\n    }\n  }\n\n  function _getMargins(margins: Margins) {\n    _margins = margins;\n  }\n\n  function _getGraphData(\n    xScale: any,\n    yScale: NumericScale | StringScale,\n    containerHeight: number,\n    containerWidth: number,\n    xElement: SVGElement | null,\n  ) {\n    const { xBarScale, yBarScale } = _getScales(containerHeight, containerWidth);\n    return (_bars = _createBar(\n      xBarScale,\n      _yAxisType === YAxisType.StringAxis ? yScale : yBarScale,\n      containerHeight,\n      xElement!,\n    ));\n  }\n\n  function _getAxisData(yAxisData: IAxisData) {\n    if (yAxisData && yAxisData.yAxisDomainValues.length) {\n      const { yAxisDomainValues: domainValue } = yAxisData;\n      _yMax = Math.max(domainValue[domainValue.length - 1], props.yMaxValue || Y_ORIGIN);\n      _yMin = Math.min(domainValue[0], props.yMinValue || Y_ORIGIN);\n    }\n  }\n\n  /**\n   * This function checks if the given legend is highlighted or not.\n   * A legend can be highlighted in 2 ways:\n   * 1. selection: if the user clicks on it\n   * 2. hovering: if there is no selected legend and the user hovers over it\n   */\n  function _isLegendHighlighted(legendTitle: string) {\n    return _getHighlightedLegend().includes(legendTitle);\n  }\n\n  /**\n   * This function checks if none of the legends is selected or hovered.\n   */\n  function _noLegendHighlighted() {\n    return _getHighlightedLegend().length === 0;\n  }\n\n  function _getAriaLabel(\n    singleChartData: VerticalStackedChartProps,\n    point?: VSChartDataPoint | LineDataInVerticalStackedBarChart,\n    isLinePoint?: boolean,\n  ): string {\n    if (!point) {\n      /** if shouldFocusWholeStack is true */\n      const xValue =\n        singleChartData.xAxisCalloutData ||\n        (singleChartData.xAxisPoint instanceof Date\n          ? formatDateToLocaleString(singleChartData.xAxisPoint, props.culture, props.useUTC as boolean)\n          : singleChartData.xAxisPoint);\n      const pointValues = singleChartData.chartData\n        .map(pt => {\n          const legend = pt.legend;\n          const yValue = pt.yAxisCalloutData || pt.data;\n          return _noLegendHighlighted() || _isLegendHighlighted(legend) ? `${legend}, ${yValue}.` : '';\n        })\n        .filter(str => str !== '')\n        .join(' ');\n      const lineValues = singleChartData.lineData\n        ?.map(ln => {\n          const legend = ln.legend;\n          const yValue = ln.yAxisCalloutData || ln.data || ln.y;\n          return _noLegendHighlighted() || _isLegendHighlighted(legend) ? `${legend}, ${yValue}.` : '';\n        })\n        .filter(str => str !== '')\n        .join(' ');\n      return (\n        singleChartData.stackCallOutAccessibilityData?.ariaLabel ||\n        `${xValue}. ${pointValues}` + (lineValues ? ` ${lineValues}` : '')\n      );\n    }\n    /** if shouldFocusWholeStack is false */\n    const xValue =\n      singleChartData.xAxisCalloutData ||\n      (!isLinePoint && (point as VSChartDataPoint).xAxisCalloutData) ||\n      (singleChartData.xAxisPoint instanceof Date\n        ? formatDateToLocaleString(singleChartData.xAxisPoint, props.culture, props.useUTC as boolean)\n        : singleChartData.xAxisPoint);\n    const legend = point.legend;\n    const yValue =\n      point.yAxisCalloutData ||\n      (isLinePoint ? point.data || (point as LineDataInVerticalStackedBarChart).y : point.data);\n    return (\n      (!isLinePoint && (point as VSChartDataPoint).callOutAccessibilityData?.ariaLabel) ||\n      `${xValue}. ${legend}, ${yValue}.`\n    );\n  }\n\n  function _getCustomizedCallout() {\n    const _isHavingLines = props.data.some(\n      (item: VerticalStackedChartProps) => item.lineData && item.lineData.length > 0,\n    );\n    return props.onRenderCalloutPerStack\n      ? props.onRenderCalloutPerStack(stackCalloutProps)\n      : props.onRenderCalloutPerDataPoint && !_isHavingLines\n      ? props.onRenderCalloutPerDataPoint(dataPointCalloutProps, _renderCallout)\n      : null;\n  }\n\n  function _toFocusWholeStack(_isHavingLines: boolean): boolean {\n    const { isCalloutForStack = false } = props;\n    let shouldFocusStackOnly: boolean = false;\n    if (_isHavingLines) {\n      if (_getHighlightedLegend().length === 1) {\n        shouldFocusStackOnly = false;\n      } else {\n        shouldFocusStackOnly = true;\n      }\n    } else {\n      shouldFocusStackOnly = isCalloutForStack;\n    }\n    return shouldFocusStackOnly;\n  }\n\n  function _getDomainNRangeValues(\n    points: DataPoint[],\n    margins: Margins,\n    width: number,\n    chartType: ChartTypes,\n    isRTL: boolean,\n    xAxisType: XAxisTypes,\n    barWidth: number,\n    tickValues: Date[] | number[] | undefined,\n    shiftX: number,\n  ) {\n    let domainNRangeValue: IDomainNRange;\n    if (xAxisType === XAxisTypes.NumericAxis) {\n      domainNRangeValue = domainRangeOfVSBCNumeric(points, margins, width, isRTL, barWidth!);\n    } else if (xAxisType === XAxisTypes.DateAxis) {\n      domainNRangeValue = domainRangeOfDateForAreaLineScatterVerticalBarCharts(\n        points,\n        margins,\n        width,\n        isRTL,\n        tickValues! as Date[],\n        chartType,\n        barWidth,\n      );\n    } else {\n      domainNRangeValue = domainRangeOfXStringAxis(margins, width, isRTL);\n    }\n    return domainNRangeValue;\n  }\n\n  function _getFormattedLineData(data: VerticalStackedChartProps[]): LineObject {\n    const linesData: LinePoint[] = [];\n    const formattedLineData: LineObject = {};\n    data.forEach((item: VerticalStackedChartProps, index: number) => {\n      if (item.lineData) {\n        item.lineData.forEach((line: any) => {\n          linesData.push({\n            ...line,\n            index,\n            xItem: item,\n          });\n        });\n      }\n    });\n    linesData.forEach(item => {\n      if (formattedLineData[item.legend]) {\n        formattedLineData[item.legend].push(item);\n      } else {\n        formattedLineData[item.legend] = [item];\n      }\n    });\n    return formattedLineData;\n  }\n\n  function _getLineLegends(data: VerticalStackedChartProps[]): LineLegends[] {\n    const lineObject: LineObject = _lineObject;\n    const lineLegends: LineLegends[] = [];\n    Object.keys(lineObject).forEach((item: string) => {\n      lineLegends.push({\n        title: item,\n        color: lineObject[item][0].color,\n      });\n    });\n    return lineLegends;\n  }\n\n  function _createLines(\n    xScale: any,\n    yScalePrimary: NumericScale | StringScale,\n    containerHeight: number,\n    containerWidth: number,\n    yScaleSecondary?: NumericScale,\n  ): JSXElement {\n    const lineObject: LineObject = _getFormattedLineData(props.data);\n    const lines: React.ReactNode[] = [];\n    const borderForLines: React.ReactNode[] = [];\n    const dots: React.ReactNode[] = [];\n    //const { theme } = props;\n    const lineBorderWidth = props.lineOptions?.lineBorderWidth\n      ? Number.parseFloat(props.lineOptions!.lineBorderWidth!.toString())\n      : 0;\n    const xScaleBandwidthTranslate = _xAxisType !== XAxisTypes.StringAxis ? 0 : xScale.bandwidth() / 2;\n    Object.keys(lineObject).forEach((item: string, index: number) => {\n      const shouldHighlight = _isLegendHighlighted(item) || _noLegendHighlighted();\n      for (let i = 1; i < lineObject[item].length; i++) {\n        const x1 = xScale(lineObject[item][i - 1].xItem.xAxisPoint);\n        const useSecondaryYScale =\n          lineObject[item][i - 1].useSecondaryYScale && lineObject[item][i].useSecondaryYScale && yScaleSecondary;\n        const y1 = useSecondaryYScale\n          ? yScaleSecondary!(lineObject[item][i - 1].y as number)\n          : //eslint-disable-next-line @typescript-eslint/no-explicit-any\n            yScalePrimary(lineObject[item][i - 1].y as any);\n        const x2 = xScale(lineObject[item][i].xItem.xAxisPoint);\n        const y2 = useSecondaryYScale\n          ? yScaleSecondary!(lineObject[item][i].y as number)\n          : //eslint-disable-next-line @typescript-eslint/no-explicit-any\n            yScalePrimary(lineObject[item][i].y as any);\n        const yScaleBandwidthTranslate =\n          !useSecondaryYScale && _yAxisType === YAxisType.StringAxis\n            ? (yScalePrimary as StringScale).bandwidth() / 2\n            : 0;\n        if (lineBorderWidth > 0) {\n          borderForLines.push(\n            <line\n              key={`${index}-${i}-BorderLine`}\n              x1={x1}\n              y1={y1}\n              x2={x2}\n              y2={y2}\n              opacity={shouldHighlight ? 1 : 0.1}\n              strokeWidth={3 + lineBorderWidth * 2}\n              fill=\"transparent\"\n              strokeLinecap=\"round\"\n              stroke={tokens.colorNeutralBackground1}\n              transform={`translate(${xScaleBandwidthTranslate}, ${yScaleBandwidthTranslate})`}\n            />,\n          );\n        }\n        lines.push(\n          <line\n            key={`${index}-${i}-line`}\n            x1={x1}\n            y1={y1}\n            x2={x2}\n            y2={y2}\n            opacity={shouldHighlight ? 1 : 0.1}\n            strokeWidth={lineObject[item][0].lineOptions?.strokeWidth ?? 3}\n            strokeLinecap={lineObject[item][0].lineOptions?.strokeLinecap ?? 'round'}\n            strokeDasharray={lineObject[item][0].lineOptions?.strokeDasharray}\n            stroke={lineObject[item][i].color}\n            transform={`translate(${xScaleBandwidthTranslate}, ${yScaleBandwidthTranslate})`}\n            onMouseOver={event => _lineHover(lineObject[item][i - 1], event)}\n            onMouseLeave={_handleMouseOut}\n          />,\n        );\n      }\n    });\n    Object.keys(lineObject).forEach((item: string, index: number) => {\n      lineObject[item].forEach((circlePoint: LinePoint, subIndex: number) => {\n        const circleRef: { refElement: SVGCircleElement | null } = { refElement: null };\n        const noBarsAndLinesActive =\n          circlePoint.xItem.chartData.filter(\n            dataPoint => _noLegendHighlighted() || _isLegendHighlighted(dataPoint.legend),\n          ).length === 0;\n        const yScaleBandwidthTranslate =\n          !circlePoint.useSecondaryYScale && _yAxisType === YAxisType.StringAxis\n            ? (yScalePrimary as StringScale).bandwidth() / 2\n            : 0;\n        dots.push(\n          <circle\n            key={`${index}-${subIndex}-dot`}\n            cx={xScale(circlePoint.xItem.xAxisPoint)}\n            cy={\n              circlePoint.useSecondaryYScale && yScaleSecondary\n                ? yScaleSecondary(circlePoint.y as number)\n                : // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                  yScalePrimary(circlePoint.y as any)\n            }\n            onMouseOver={event => _lineHover(circlePoint, event)}\n            onMouseLeave={_handleMouseOut}\n            r={_getCircleOpacityAndRadius(circlePoint.xItem.xAxisPoint, circlePoint.legend).radius}\n            stroke={circlePoint.color}\n            fill={tokens.colorNeutralBackground1}\n            strokeWidth={3}\n            // Elements with visibility: hidden cannot receive focus, so use opacity: 0 instead to hide them.\n            // For more information, see https://fuzzbomb.github.io/accessibility-demos/visually-hidden-focus-test.html\n            opacity={_getCircleOpacityAndRadius(circlePoint.xItem.xAxisPoint, circlePoint.legend).opacity}\n            transform={`translate(${xScaleBandwidthTranslate}, ${yScaleBandwidthTranslate})`}\n            ref={e => (circleRef.refElement = e)}\n            {...(noBarsAndLinesActive\n              ? {\n                  tabIndex: !props.hideTooltip ? 0 : undefined,\n                  onFocus: event => _lineFocus(event, circlePoint, circleRef),\n                  onBlur: _handleMouseOut,\n                  role: 'img',\n                  'aria-label': _getAriaLabel(circlePoint.xItem, circlePoint as VSChartDataPoint),\n                }\n              : {})}\n          />,\n        );\n      });\n    });\n    return (\n      <>\n        {borderForLines}\n        {lines}\n        {dots}\n      </>\n    );\n  }\n\n  function _getCircleOpacityAndRadius(\n    xAxisPoint: string | number | Date,\n    legend: string,\n  ): { opacity: number; radius: number } {\n    if (!_noLegendHighlighted()) {\n      if (xAxisPoint === activeXAxisDataPoint && _isLegendHighlighted(legend)) {\n        return { opacity: 1, radius: 8 };\n      } else if (_isLegendHighlighted(legend)) {\n        return { opacity: 1, radius: 0.3 };\n      } else {\n        return { opacity: 0, radius: 0 };\n      }\n    } else {\n      return {\n        opacity: activeXAxisDataPoint === xAxisPoint ? 1 : 0,\n        radius: 8,\n      };\n    }\n  }\n\n  function _renderCallout(props?: VSChartDataPoint): JSXElement | null {\n    return props ? (\n      <ChartPopover\n        culture={props.culture}\n        XValue={props.xAxisCalloutData}\n        xCalloutValue={xCalloutValue}\n        yCalloutValue={yCalloutValue}\n        clickPosition={clickPosition}\n        isPopoverOpen={isPopoverOpen}\n        legend={props.legend}\n        YValue={props.yAxisCalloutData}\n        color={props.color}\n      />\n    ) : null;\n  }\n\n  function _onRectHover(\n    xAxisPoint: string | number | Date,\n    point: VSChartDataPoint,\n    color: string,\n    mouseEvent: React.MouseEvent<SVGElement>,\n  ): void {\n    mouseEvent.persist();\n    _onRectFocusHover(xAxisPoint, point, color, mouseEvent);\n  }\n\n  function _onRectFocusHover(\n    xAxisPoint: string | number | Date,\n    point: VSChartDataPoint,\n    color: string,\n    mouseEvent: React.MouseEvent<SVGElement> | SVGGElement,\n  ) {\n    let clientX = 0;\n    let clientY = 0;\n    if ('clientX' in mouseEvent) {\n      clientX = mouseEvent.clientX;\n      clientY = mouseEvent.clientY;\n    } else {\n      // Handle case where mouseEvent is an SVGGElement\n      const boundingRect = mouseEvent.getBoundingClientRect();\n      clientX = boundingRect.left + boundingRect.width / 2;\n      clientY = boundingRect.top + boundingRect.height / 2;\n    }\n    if (_calloutAnchorPoint?.chartDataPoint !== point || _calloutAnchorPoint?.xAxisDataPoint !== xAxisPoint) {\n      _calloutAnchorPoint = {\n        chartDataPoint: point,\n        xAxisDataPoint:\n          xAxisPoint instanceof Date\n            ? formatDateToLocaleString(xAxisPoint, props.culture, props.useUTC as boolean)\n            : xAxisPoint.toString(),\n      };\n      const xCalloutValue =\n        point.xAxisCalloutData ||\n        (xAxisPoint instanceof Date\n          ? formatDateToLocaleString(xAxisPoint, props.culture, props.useUTC as boolean)\n          : xAxisPoint.toString());\n\n      _updatePosition(clientX, clientY);\n      setPopoverOpen(_noLegendHighlighted() || _isLegendHighlighted(point.legend));\n      setCalloutLegend(point.legend);\n      setDataForHoverCard(point.data as number);\n      setColor(color);\n      setXCalloutValue(xCalloutValue);\n      setYCalloutValue(point.yAxisCalloutData!);\n      setDataPointCalloutProps(point);\n      setCallOutAccessibilityData(point.callOutAccessibilityData);\n    }\n  }\n\n  function _lineHover(lineData: LinePoint, mouseEvent: React.MouseEvent<SVGElement>) {\n    mouseEvent.persist();\n    _lineHoverFocus(lineData, mouseEvent);\n  }\n\n  function _lineFocus(\n    event: React.FocusEvent<SVGCircleElement, Element>,\n    lineData: LinePoint,\n    ref: { refElement: SVGCircleElement | null },\n  ) {\n    if (ref.refElement) {\n      _lineHoverFocus(lineData, event);\n    }\n  }\n\n  function _onStackHover(stack: VerticalStackedChartProps, mouseEvent: React.MouseEvent<SVGElement>): void {\n    mouseEvent.persist();\n    _onStackHoverFocus(stack, mouseEvent);\n  }\n\n  function _onRectFocus(point: VSChartDataPoint, xAxisPoint: string, color: string, ref: RefArrayData): void {\n    if (ref.refElement) {\n      _onRectFocusHover(xAxisPoint, point, color, ref.refElement);\n    }\n  }\n\n  function _onStackFocus(stack: VerticalStackedChartProps, groupRef: RefArrayData): void {\n    if (groupRef.refElement) {\n      _onStackHoverFocus(stack, groupRef.refElement);\n    }\n  }\n\n  function _handleMouseOut(): void {\n    /**/\n  }\n\n  function _getBarGapAndScale(\n    bars: VSChartDataPoint[],\n    yBarScale: NumericScale | StringScale,\n    defaultTotalHeight?: number,\n  ): {\n    readonly gapHeight: number;\n    readonly heightValueScale: number;\n    readonly absStackTotal: number;\n  } {\n    const { barGapMax = 0 } = props;\n    let totalData = 0;\n    let totalHeight: number;\n    let sumOfPercent = 0;\n    let scalingRatio: number;\n    if (_yAxisType === YAxisType.StringAxis) {\n      totalHeight =\n        defaultTotalHeight ?? bars.reduce((total, bar) => total + (yBarScale as StringScale)(bar.data as string)!, 0);\n    } else {\n      // When displaying gaps between the bars, the height of each bar is\n      // adjusted so that the total of all bars is not changed by the gaps\n      totalData = bars.reduce((iter, value) => iter + Math.abs(value.data as number), 0);\n      totalHeight =\n        defaultTotalHeight ?? Math.abs((yBarScale as NumericScale)(totalData) - (yBarScale as NumericScale)(Y_ORIGIN));\n      bars.forEach(point => {\n        let value = (Math.abs(point.data as number) / totalData) * 100;\n        if (value < 1 && value !== 0) {\n          value = 1;\n        }\n        sumOfPercent += value;\n      });\n      scalingRatio = sumOfPercent !== 0 ? sumOfPercent / 100 : 1;\n    }\n    const gaps = barGapMax && bars.length - 1;\n    const gapHeight = gaps && Math.max(barGapMin, Math.min(barGapMax, (totalHeight * barGapMultiplier) / gaps));\n    const heightValueScale =\n      _yAxisType === YAxisType.StringAxis ? 0 : (totalHeight - gapHeight * gaps) / (totalData * scalingRatio!);\n    return {\n      gapHeight,\n      heightValueScale,\n      absStackTotal: totalData,\n    } as const;\n  }\n\n  function _getScales(containerHeight: number, containerWidth: number) {\n    const yDomain = [Math.min(Y_ORIGIN, _yMin), Math.max(Y_ORIGIN, _yMax)];\n    const yBarScale = d3ScaleLinear()\n      .domain(yDomain)\n      .range([0, containerHeight - _margins.bottom! - _margins.top!]);\n    if (_xAxisType === XAxisTypes.NumericAxis) {\n      const xMax = d3Max(_dataset, (point: VerticalStackedBarDataPoint) => point.x as number)!;\n      const xMin = d3Min(_dataset, (point: VerticalStackedBarDataPoint) => point.x as number)!;\n\n      const xBarScale = d3ScaleLinear()\n        .domain(_isRtl ? [xMax, xMin] : [xMin, xMax])\n        .range([_margins.left! + _domainMargin, containerWidth - _margins.right! - _domainMargin]);\n      if (!isScalePaddingDefined(props.xAxisInnerPadding, props.xAxisPadding)) {\n        xBarScale.nice();\n      }\n      return { xBarScale, yBarScale };\n    }\n    if (_xAxisType === XAxisTypes.DateAxis) {\n      const sDate = d3Min(_dataset, (point: VerticalStackedBarDataPoint) => {\n        return point.x as Date;\n      })!;\n      const lDate = d3Max(_dataset, (point: VerticalStackedBarDataPoint) => {\n        return point.x as Date;\n      })!;\n      const xBarScale = props.useUTC ? d3ScaleUtc() : d3ScaleTime();\n      xBarScale\n        .domain(_isRtl ? [lDate, sDate] : [sDate, lDate])\n        .range([_margins.left! + _domainMargin, containerWidth - _margins.right! - _domainMargin]);\n\n      return { xBarScale, yBarScale };\n    }\n    const xBarScale = d3ScaleBand()\n      .domain(_xAxisLabels)\n      .range(\n        _isRtl\n          ? [containerWidth - _margins.right! - _domainMargin, _margins.left! + _domainMargin]\n          : [_margins.left! + _domainMargin, containerWidth - _margins.right! - _domainMargin],\n      )\n      .paddingInner(_xAxisInnerPadding)\n      .paddingOuter(_xAxisOuterPadding);\n\n    return { xBarScale, yBarScale };\n  }\n\n  const _isChartEmpty = (): boolean => {\n    return !(\n      props.data &&\n      props.data.length > 0 &&\n      props.data.some(item => item.chartData.length > 0 || (item.lineData && item.lineData.length > 0))\n    );\n  };\n\n  function _updatePosition(newX: number, newY: number) {\n    const threshold = 1; // Set a threshold for movement\n    const { x, y } = clickPosition;\n    // Calculate the distance moved\n    const distance = Math.sqrt(Math.pow(newX - x, 2) + Math.pow(newY - y, 2));\n    // Update the position only if the distance moved is greater than the threshold\n    if (distance > threshold) {\n      setClickPosition({ x: newX, y: newY });\n      setPopoverOpen(true);\n    }\n  }\n\n  function _getDomainMargins(containerWidth: number): Margins {\n    _domainMargin = MIN_DOMAIN_MARGIN;\n\n    const totalWidth = calcTotalWidth(containerWidth, _margins, MIN_DOMAIN_MARGIN);\n\n    if (_xAxisType === XAxisTypes.StringAxis) {\n      if (isScalePaddingDefined(props.xAxisOuterPadding, props.xAxisPadding)) {\n        // Setting the domain margin for string x-axis to 0 because the xAxisOuterPadding prop is now available\n        // to adjust the space before the first bar and after the last bar.\n        _domainMargin = 0;\n      } else if (props.barWidth !== 'auto') {\n        // Update the bar width so that when CartesianChart rerenders,\n        // the following calculations don't use the previous bar width.\n        _barWidth = getBarWidth(props.barWidth, props.maxBarWidth);\n        /** Total width required to render the bars. Directly proportional to bar width */\n        const reqWidth = calcRequiredWidth(_barWidth, _xAxisLabels.length, _xAxisInnerPadding);\n\n        if (totalWidth >= reqWidth) {\n          // Center align the chart by setting equal left and right margins for domain\n          _domainMargin = MIN_DOMAIN_MARGIN + (totalWidth - reqWidth) / 2;\n        }\n      } else if (props.mode === 'plotly' && _xAxisLabels.length > 1) {\n        // Calculate the remaining width after rendering bars at their maximum allowable width\n        const bandwidth = calcBandwidth(totalWidth, _xAxisLabels.length, _xAxisInnerPadding);\n        const barWidth = getBarWidth(props.barWidth, props.maxBarWidth, bandwidth);\n        let reqWidth = calcRequiredWidth(barWidth, _xAxisLabels.length, _xAxisInnerPadding);\n        const margin1 = (totalWidth - reqWidth) / 2;\n\n        let margin2 = Number.POSITIVE_INFINITY;\n        if (!props.hideTickOverlap) {\n          // Calculate the remaining width after accounting for the space required to render x-axis labels\n          const step = calculateLongestLabelWidth(_xAxisLabels) + 20;\n          reqWidth = (_xAxisLabels.length - _xAxisInnerPadding) * step;\n          margin2 = (totalWidth - reqWidth) / 2;\n        }\n\n        _domainMargin = MIN_DOMAIN_MARGIN + Math.max(0, Math.min(margin1, margin2));\n      }\n    } else {\n      const data = (props.data?.map(point => point.xAxisPoint) as number[] | Date[] | undefined) || [];\n      _barWidth = getBarWidth(\n        props.barWidth,\n        props.maxBarWidth,\n        calculateAppropriateBarWidth(data, totalWidth, _xAxisInnerPadding),\n      );\n      _domainMargin = MIN_DOMAIN_MARGIN + _barWidth / 2;\n    }\n\n    return {\n      ..._margins,\n      left: _margins.left! + _domainMargin,\n      right: _margins.right! + _domainMargin,\n    };\n  }\n\n  function _getChartTitle(): string {\n    const { chartTitle, data } = props;\n    const numLines = Object.keys(_lineObject).length;\n    return (\n      (chartTitle ? `${chartTitle}. ` : '') +\n      `Vertical bar chart with ${data?.length || 0} stacked bars` +\n      (numLines > 0 ? ` and ${numLines} lines` : '') +\n      '. '\n    );\n  }\n\n  const classes = useVerticalStackedBarChartStyles(props);\n  function _createBar(\n    xBarScale: any,\n    yBarScale: NumericScale | StringScale,\n    containerHeight: number,\n    xElement: SVGElement,\n  ): JSXElement[] {\n    const { barCornerRadius = 0, barMinimumHeight = 0 } = props;\n    const _isHavingLines = props.data.some(\n      (item: VerticalStackedChartProps) => item.lineData && item.lineData.length > 0,\n    );\n    const shouldFocusWholeStack = _toFocusWholeStack(_isHavingLines);\n\n    if (_xAxisType === XAxisTypes.StringAxis) {\n      _barWidth = getBarWidth(props.barWidth, props.maxBarWidth, xBarScale.bandwidth());\n    }\n\n    const bars = _points.map((singleChartData: VerticalStackedChartProps, indexNumber: number) => {\n      const xPoint = xBarScale(\n        _xAxisType === XAxisTypes.NumericAxis\n          ? (singleChartData.xAxisPoint as number)\n          : _xAxisType === XAxisTypes.DateAxis\n          ? (singleChartData.xAxisPoint as Date)\n          : (singleChartData.xAxisPoint as string),\n      );\n      const xScaleBandwidthTranslate =\n        _xAxisType !== XAxisTypes.StringAxis ? -_barWidth / 2 : (xBarScale.bandwidth() - _barWidth) / 2;\n\n      let barTotalValue = 0;\n\n      const barsToDisplay = singleChartData.chartData.filter(\n        point =>\n          point.data !== 0 &&\n          point.data !== '' &&\n          !(\n            _yAxisType === YAxisType.StringAxis &&\n            typeof (yBarScale as StringScale)(point.data as string) === 'undefined'\n          ),\n      );\n\n      if (!barsToDisplay.length) {\n        return undefined;\n      }\n\n      const { gapHeight, heightValueScale, absStackTotal } = _getBarGapAndScale(barsToDisplay, yBarScale);\n\n      if (heightValueScale < 0) {\n        return undefined;\n      }\n\n      const yBaseline =\n        containerHeight -\n        _margins.bottom! -\n        (_yAxisType === YAxisType.StringAxis ? 0 : (yBarScale as NumericScale)(Y_ORIGIN));\n      let yPositiveStart = yBaseline;\n      let yNegativeStart = yBaseline;\n      let yPoint = 0;\n      let heightOfLastBar = 0;\n\n      const singleBar = barsToDisplay.map((point: VSChartDataPoint, index: number) => {\n        const startColor = point.color ? point.color : _colors[index];\n        const ref: RefArrayData = {};\n        const shouldHighlight = _isLegendHighlighted(point.legend) || _noLegendHighlighted() ? true : false;\n        const rectFocusProps = !shouldFocusWholeStack &&\n          shouldHighlight && {\n            'aria-label': _getAriaLabel(singleChartData, point),\n            onMouseOver: (event: React.MouseEvent<SVGElement, MouseEvent>) =>\n              _onRectHover(singleChartData.xAxisPoint, point, startColor, event),\n            onMouseMove: (event: React.MouseEvent<SVGElement, MouseEvent>) =>\n              _onRectHover(singleChartData.xAxisPoint, point, startColor, event),\n            onMouseLeave: _handleMouseOut,\n            onFocus: () => _onRectFocus(point, singleChartData.xAxisPoint as string, startColor, ref),\n            onBlur: _handleMouseOut,\n            onClick: (event: React.MouseEvent<SVGElement, MouseEvent>) => _onClick(point, event),\n            role: 'img',\n            tabIndex: !props.hideTooltip && shouldHighlight ? 0 : undefined,\n          };\n\n        let barHeight: number;\n        const gapOffset = index ? gapHeight : 0;\n        if (_yAxisType === YAxisType.StringAxis) {\n          barHeight = Math.max(\n            containerHeight -\n              _margins.bottom! -\n              ((yBarScale as StringScale)(point.data as string)! + (yBarScale as StringScale).bandwidth() / 2) -\n              gapOffset,\n            barMinimumHeight,\n            1,\n          );\n          yPositiveStart -= barHeight + gapOffset;\n          yPoint = yPositiveStart;\n        } else {\n          barHeight = Math.abs(heightValueScale * (point.data as number));\n          // FIXME: The current scaling logic may produce different min and gap heights for each bar stack.\n          const minHeight = Math.max((heightValueScale * absStackTotal) / 100.0, barMinimumHeight);\n          if (barHeight < minHeight) {\n            barHeight = minHeight;\n          }\n          if ((point.data as number) >= Y_ORIGIN) {\n            yPositiveStart -= barHeight + gapOffset;\n            yPoint = yPositiveStart;\n          } else {\n            yPoint = yNegativeStart + gapOffset;\n            yNegativeStart = yPoint + barHeight;\n          }\n\n          barTotalValue += point.data as number;\n          heightOfLastBar = index === barsToDisplay.length - 1 ? barHeight : 0;\n        }\n\n        if (barCornerRadius && barHeight > barCornerRadius && index === barsToDisplay.length - 1) {\n          return (\n            <React.Fragment key={index + indexNumber + `${shouldFocusWholeStack}`}>\n              <path\n                className={classes.opacityChangeOnHover}\n                d={`\n                  M ${xPoint} ${yPoint + barCornerRadius}\n                  a ${barCornerRadius} ${barCornerRadius} 0 0 1 ${barCornerRadius} ${-barCornerRadius}\n                  h ${_barWidth - 2 * barCornerRadius}\n                  a ${barCornerRadius} ${barCornerRadius} 0 0 1 ${barCornerRadius} ${barCornerRadius}\n                  v ${barHeight - barCornerRadius}\n                  h ${-_barWidth}\n                  z\n                `}\n                fill={startColor}\n                rx={props.roundCorners ? 3 : 0}\n                ref={e => (ref.refElement = e)}\n                transform={`translate(${xScaleBandwidthTranslate}, 0)`}\n                cursor={props.href ? 'pointer' : 'default'}\n                {...rectFocusProps}\n              />\n            </React.Fragment>\n          );\n        }\n        if (barHeight < 0) {\n          return <React.Fragment key={index + indexNumber}> </React.Fragment>;\n        }\n        return (\n          <React.Fragment key={index + indexNumber}>\n            <rect\n              className={classes.opacityChangeOnHover}\n              x={xPoint}\n              y={yPoint}\n              width={_barWidth}\n              height={barHeight}\n              fill={startColor}\n              opacity={shouldHighlight ? 1 : 0.1}\n              cursor={props.href ? 'pointer' : 'default'}\n              rx={props.roundCorners ? 3 : 0}\n              ref={e => (ref.refElement = e)}\n              {...rectFocusProps}\n              transform={`translate(${xScaleBandwidthTranslate}, 0)`}\n            />\n          </React.Fragment>\n        );\n      });\n      const groupRef: RefArrayData = {};\n      const someBarsActive =\n        singleChartData.chartData.filter(dataPoint => _noLegendHighlighted() || _isLegendHighlighted(dataPoint.legend))\n          .length > 0;\n      // FIXME: Making the entire stack focusable when stack callout is enabled adds unnecessary complexity\n      // and can reduce usability in certain scenarios. Instead, each individual element within the stack\n      // should be focusable on its own, with its own aria-label. This behavior is also seen in Highcharts.\n      const stackFocusProps = shouldFocusWholeStack &&\n        someBarsActive && {\n          'aria-label': _getAriaLabel(singleChartData),\n          onMouseOver: (event: any) => _onStackHover(singleChartData, event),\n          onMouseMove: (event: any) => _onStackHover(singleChartData, event),\n          onMouseLeave: _handleMouseOut,\n          onFocus: () => _onStackFocus(singleChartData, groupRef),\n          onBlur: _handleMouseOut,\n          onClick: (event: any) => _onClick(singleChartData, event),\n          role: 'img',\n          tabIndex: !props.hideTooltip ? 0 : undefined,\n        };\n      let showLabel = false;\n      let barLabel = 0;\n      if (!props.hideLabels && _yAxisType !== YAxisType.StringAxis) {\n        if (_noLegendHighlighted()) {\n          showLabel = true;\n          barLabel = barTotalValue;\n        } else {\n          barsToDisplay.forEach(point => {\n            if (_isLegendHighlighted(point.legend)) {\n              showLabel = true;\n              barLabel += point.data as number;\n            }\n          });\n        }\n      }\n      return (\n        <g key={indexNumber + `${shouldFocusWholeStack}`}>\n          <g id={`${indexNumber}-singleBar`} ref={e => (groupRef.refElement = e)} {...stackFocusProps}>\n            {singleBar}\n          </g>\n          {/*\n            Note: No need to check hideLabels here, as showLabel is only set to true\n            when hideLabels is false earlier in the code.\n          */}\n          {!props.hideLabels && _barWidth >= 16 && showLabel && (\n            <text\n              x={xPoint + _barWidth / 2}\n              //if total bar value >=0, show label above top bar, otherwise below bottom bar\n              y={barLabel >= Y_ORIGIN ? yPoint - 6 : yPoint + heightOfLastBar + 12}\n              textAnchor=\"middle\"\n              className={classes.barLabel}\n              aria-label={`Total: ${barLabel}`}\n              role=\"img\"\n              transform={`translate(${xScaleBandwidthTranslate}, 0)`}\n              style={{ direction: 'ltr', unicodeBidi: 'isolate' }}\n            >\n              {typeof props.yAxisTickFormat === 'function'\n                ? props.yAxisTickFormat(barLabel)\n                : formatScientificLimitWidth(barLabel)}\n            </text>\n          )}\n        </g>\n      );\n    });\n    if (!props.showXAxisLablesTooltip) {\n      try {\n        document.getElementById(_tooltipId) && document.getElementById(_tooltipId)!.remove();\n        // eslint-disable-next-line no-empty\n      } catch (e) {}\n    }\n    if (!props.wrapXAxisLables && props.showXAxisLablesTooltip) {\n      const xAxisElement = d3Select(xElement).call(xBarScale);\n      try {\n        document.getElementById(_tooltipId) && document.getElementById(_tooltipId)!.remove();\n        // eslint-disable-next-line no-empty\n      } catch (e) {}\n      const tooltipProps = {\n        tooltipCls: classes.tooltip!,\n        id: _tooltipId,\n        axis: xAxisElement,\n      };\n      xAxisElement && tooltipOfAxislabels(tooltipProps);\n    }\n    return bars.filter((bar): bar is JSXElement => !!bar);\n  }\n\n  function _getMinMaxOfYAxis(\n    dataset: DataPoint[],\n    yAxisType?: YAxisType,\n    useSecondaryYScale?: boolean,\n  ): { startValue: number; endValue: number } {\n    if (!useSecondaryYScale) {\n      return findVSBCNumericMinMaxOfY(dataset);\n    }\n\n    const values: number[] = [];\n    props.data.forEach(xPoint => {\n      xPoint.lineData?.forEach(point => {\n        // useSecondaryYScale is applicable only for lines in VSBC\n        if (point.useSecondaryYScale) {\n          values.push(point.y as number);\n        }\n      });\n    });\n\n    return { startValue: d3Min(values)!, endValue: d3Max(values)! };\n  }\n\n  function _initYAxisParams() {\n    if (_points[0].chartData.length > 0) {\n      _yAxisType = getTypeOfAxis(_points[0].chartData[0].data, false) as YAxisType;\n    } else {\n      Object.keys(_lineObject).forEach(lineLegend => {\n        if (!_lineObject[lineLegend][0].useSecondaryYScale) {\n          _yAxisType = getTypeOfAxis(_lineObject[lineLegend][0].y, false) as YAxisType;\n        }\n      });\n    }\n\n    _yAxisLabels = _getOrderedYAxisLabels();\n  }\n\n  function _getYDomainMargins(containerHeight: number): Margins {\n    /**\n     * Specifies the extra top margin to apply above the highest y-axis tick label.\n     * Useful when stacked bars extend beyond the combined height of all y-axis labels (or categories).\n     */\n    let yAxisTickMarginTop = 0;\n\n    /** Total height available to render the bars */\n    const totalHeight = containerHeight - _margins.bottom! - _margins.top!;\n\n    if (_yAxisType === YAxisType.StringAxis) {\n      /** Maximum height of the stacked bars, expressed in multiples of the height of a y-axis label (or category) */\n      let maxBarHeightInLabels = 0;\n      _points.forEach(xPoint => {\n        /** Height of the stacked bar, expressed in multiples of the height of a y-axis label (or category) */\n        let barHeightInLabels = 0;\n        xPoint.chartData.forEach(bar => {\n          barHeightInLabels += _yAxisLabels.indexOf(`${bar.data}`) + 1;\n        });\n        maxBarHeightInLabels = Math.max(maxBarHeightInLabels, barHeightInLabels);\n      });\n      /** Height of a y-axis label (or category) */\n      const yAxisLabelHeight = maxBarHeightInLabels === 0 ? 0 : totalHeight / maxBarHeightInLabels;\n      yAxisTickMarginTop += yAxisLabelHeight * (maxBarHeightInLabels - _yAxisLabels.length);\n    }\n\n    return {\n      ..._margins,\n      top: _margins.top! + yAxisTickMarginTop,\n    };\n  }\n\n  function _getOrderedXAxisLabels() {\n    if (_xAxisType !== XAxisTypes.StringAxis) {\n      return [];\n    }\n\n    return sortAxisCategories(_mapCategoryToValues(), props.xAxisCategoryOrder);\n  }\n\n  function _getOrderedYAxisLabels() {\n    if (_yAxisType !== YAxisType.StringAxis) {\n      return [];\n    }\n\n    return sortAxisCategories(_mapCategoryToValues(true), props.yAxisCategoryOrder);\n  }\n\n  function _mapCategoryToValues(isYAxis = false) {\n    const categoryToValues: Record<string, number[]> = {};\n    _points.forEach(point => {\n      point.chartData.forEach(bar => {\n        const category = (isYAxis ? bar.data : point.xAxisPoint) as string;\n        const value = isYAxis ? point.xAxisPoint : bar.data;\n        if (!categoryToValues[category]) {\n          categoryToValues[category] = [];\n        }\n        if (typeof value === 'number') {\n          categoryToValues[category].push(value);\n        }\n      });\n      point.lineData?.forEach(linePoint => {\n        if (isYAxis && linePoint.useSecondaryYScale) {\n          return;\n        }\n        const category = (isYAxis ? linePoint.y : point.xAxisPoint) as string;\n        const value = isYAxis ? point.xAxisPoint : linePoint.y;\n        if (!categoryToValues[category]) {\n          categoryToValues[category] = [];\n        }\n        if (typeof value === 'number') {\n          categoryToValues[category].push(value);\n        }\n      });\n    });\n    return categoryToValues;\n  }\n\n  if (!_isChartEmpty()) {\n    _adjustProps();\n    const _isHavingLines = props.data.some(\n      (item: VerticalStackedChartProps) => item.lineData && item.lineData.length > 0,\n    );\n    const shouldFocusWholeStack = _toFocusWholeStack(_isHavingLines);\n    _dataset = _createDataSetLayer();\n    const legendBars: JSXElement = _getLegendData(_points, _createLegendsForLine(props.data));\n    const calloutProps: ModifiedCartesianChartProps['calloutProps'] = {\n      color: color,\n      legend: calloutLegend,\n      XValue: xCalloutValue!,\n      YValue: yCalloutValue ? yCalloutValue : dataForHoverCard,\n      YValueHover: YValueHover,\n      hoverXValue: hoverXValue,\n      ...props.calloutProps,\n      ...getAccessibleDataObject(callOutAccessibilityData),\n      clickPosition: clickPosition,\n      isPopoverOpen: isPopoverOpen,\n      isCalloutForStack:\n        props.isCalloutForStack || (_isHavingLines && (_noLegendHighlighted() || _getHighlightedLegend().length > 1)),\n      isCartesian: true,\n      customCallout: {\n        customizedCallout: _getCustomizedCallout() !== null ? _getCustomizedCallout()! : undefined,\n        customCalloutProps: props.calloutPropsPerDataPoint\n          ? props.calloutPropsPerDataPoint(dataPointCalloutProps!)\n          : undefined,\n      },\n    };\n    const tickParams = {\n      tickValues: props.tickValues,\n      tickFormat: props.tickFormat,\n    };\n    return (\n      <CartesianChart\n        {...props}\n        chartTitle={_getChartTitle()}\n        points={_dataset}\n        chartType={ChartTypes.VerticalStackedBarChart}\n        xAxisType={_xAxisType}\n        getMinMaxOfYAxis={_getMinMaxOfYAxis}\n        calloutProps={calloutProps}\n        createYAxis={createNumericYAxis}\n        tickParams={tickParams}\n        legendBars={legendBars}\n        datasetForXAxisDomain={_xAxisLabels}\n        isCalloutForStack={shouldFocusWholeStack}\n        getDomainNRangeValues={_getDomainNRangeValues}\n        createStringYAxis={createStringYAxis}\n        barwidth={_barWidth}\n        getmargins={_getMargins}\n        getGraphData={_getGraphData}\n        getAxisData={_getAxisData}\n        onChartMouseLeave={_handleChartMouseLeave}\n        getDomainMargins={_getDomainMargins}\n        {...(_xAxisType === XAxisTypes.StringAxis && {\n          xAxisInnerPadding: _xAxisInnerPadding,\n          xAxisOuterPadding: _xAxisOuterPadding,\n        })}\n        componentRef={cartesianChartRef}\n        showRoundOffXTickValues={!isScalePaddingDefined(props.xAxisInnerPadding, props.xAxisPadding)}\n        yAxisType={_yAxisType!}\n        stringDatasetForYAxisDomain={['', ..._yAxisLabels]}\n        getYDomainMargins={_getYDomainMargins}\n        /* eslint-disable react/jsx-no-bind */\n        children={(props: ChildProps) => {\n          return (\n            <>\n              <g>{_bars}</g>\n              <g>\n                {_isHavingLines &&\n                  _createLines(\n                    props.xScale!,\n                    props.yScalePrimary!,\n                    props.containerHeight!,\n                    props.containerWidth!,\n                    props.yScaleSecondary,\n                  )}\n              </g>\n            </>\n          );\n        }}\n      />\n    );\n  }\n  return <div id={_emptyChartId} role={'alert'} style={{ opacity: '0' }} aria-label={'Graph has no data to display'} />;\n});\nVerticalStackedBarChart.displayName = 'VerticalStackedBarChart';\n"],"names":["React","max","d3Max","min","d3Min","select","d3Select","useVerticalStackedBarChartStyles","scaleLinear","d3ScaleLinear","scaleBand","d3ScaleBand","scaleUtc","d3ScaleUtc","scaleTime","d3ScaleTime","useId","tokens","CartesianChart","ChartPopover","Legends","ChartTypes","getAccessibleDataObject","XAxisTypes","getTypeOfAxis","tooltipOfAxislabels","formatScientificLimitWidth","getBarWidth","getScalePadding","isScalePaddingDefined","calculateAppropriateBarWidth","areArraysEqual","calculateLongestLabelWidth","useRtl","DataVizPalette","getColorFromToken","findVSBCNumericMinMaxOfY","YAxisType","createNumericYAxis","domainRangeOfDateForAreaLineScatterVerticalBarCharts","domainRangeOfVSBCNumeric","domainRangeOfXStringAxis","createStringYAxis","calcTotalWidth","calcBandwidth","calcRequiredWidth","sortAxisCategories","toImage","formatDateToLocaleString","barGapMultiplier","barGapMin","MIN_DOMAIN_MARGIN","VerticalStackedBarChart","forwardRef","_props","forwardedRef","props","xAxisCategoryOrder","yAxisCategoryOrder","maxBarWidth","_isRtl","_createLegendsForLine","data","_getLineLegends","_tooltipId","_emptyChartId","_points","_dataset","_xAxisLabels","_bars","_xAxisType","length","xAxisPoint","StringAxis","_barWidth","_colors","_margins","_lineObject","_yMax","_yMin","_calloutAnchorPoint","_domainMargin","_xAxisInnerPadding","_xAxisOuterPadding","cartesianChartRef","useRef","Y_ORIGIN","_legendsRef","_yAxisType","_yAxisLabels","selectedLegends","setSelectedLegends","useState","legendProps","activeLegend","setActiveLegend","undefined","dataForHoverCard","setDataForHoverCard","color","setColor","hoverXValue","setHoverXValue","YValueHover","setYValueHover","xCalloutValue","setXCalloutValue","yCalloutValue","setYCalloutValue","activeXAxisDataPoint","setActiveXAxisDataPoint","calloutLegend","setCalloutLegend","stackCalloutProps","setStackCalloutProps","dataPointCalloutProps","setDataPointCalloutProps","callOutAccessibilityData","setCallOutAccessibilityData","clickPosition","setClickPosition","x","y","isPopoverOpen","setPopoverOpen","prevPropsRef","useEffect","current","prevProps","height","width","_adjustProps","_createDataSetLayer","useImperativeHandle","componentRef","chartContainer","opts","toSVG","_getLegendData","lineLegends","hideLegend","defaultPalette","color6","color1","color5","color7","color10","actions","allowHoverOnLegend","forEach","singleChartData","chartData","point","Math","floor","random","checkSimilarLegends","filter","leg","title","legend","hoverAction","_handleChartMouseLeave","_onLegendHover","onMouseOutAction","_onLegendLeave","push","legendsOfLine","isLineLegendInBarChart","totalLegends","concat","legends","enabledWrapLines","enabledLegendsWrapLines","overflowText","legendsOverflowText","onChange","_onLegendSelectionChange","legendRef","_getHighlightedLegend","_lineHoverFocus","lineData","event","clientX","clientY","boundingRect","target","getBoundingClientRect","left","top","_noLegendHighlighted","_isLegendHighlighted","_updatePosition","xItem","yAxisCalloutData","_onStackHoverFocus","stack","mouseEvent","dataPoint","isLinesPresent","item","shouldDrawBorderBottom","sort","a","b","slice","reverse","Date","culture","useUTC","stackCallOutAccessibilityData","_onClick","onBarClick","href","window","location","barWidth","defaultColors","_getFormattedLineData","xAxisInnerPadding","xAxisPadding","xAxisOuterPadding","_initYAxisParams","dataset","map","singlePointData","total","_getOrderedXAxisLabels","legendTitle","_selectedLegends","currentLegend","canSelectMultipleLegends","_getMargins","margins","_getGraphData","xScale","yScale","containerHeight","containerWidth","xElement","xBarScale","yBarScale","_getScales","_createBar","_getAxisData","yAxisData","yAxisDomainValues","domainValue","yMaxValue","yMinValue","includes","_getAriaLabel","isLinePoint","xValue","xAxisCalloutData","pointValues","pt","yValue","str","join","lineValues","ln","ariaLabel","_getCustomizedCallout","_isHavingLines","some","onRenderCalloutPerStack","onRenderCalloutPerDataPoint","_renderCallout","_toFocusWholeStack","isCalloutForStack","shouldFocusStackOnly","_getDomainNRangeValues","points","chartType","isRTL","xAxisType","tickValues","shiftX","domainNRangeValue","NumericAxis","DateAxis","linesData","formattedLineData","index","line","lineObject","Object","keys","_createLines","yScalePrimary","yScaleSecondary","lines","borderForLines","dots","lineBorderWidth","lineOptions","Number","parseFloat","toString","xScaleBandwidthTranslate","bandwidth","shouldHighlight","i","x1","useSecondaryYScale","y1","x2","y2","yScaleBandwidthTranslate","key","opacity","strokeWidth","fill","strokeLinecap","stroke","colorNeutralBackground1","transform","strokeDasharray","onMouseOver","_lineHover","onMouseLeave","_handleMouseOut","circlePoint","subIndex","circleRef","refElement","noBarsAndLinesActive","circle","cx","cy","r","_getCircleOpacityAndRadius","radius","ref","e","tabIndex","hideTooltip","onFocus","_lineFocus","onBlur","role","XValue","YValue","_onRectHover","persist","_onRectFocusHover","chartDataPoint","xAxisDataPoint","_onStackHover","_onRectFocus","_onStackFocus","groupRef","_getBarGapAndScale","bars","defaultTotalHeight","barGapMax","totalData","totalHeight","sumOfPercent","scalingRatio","reduce","bar","iter","value","abs","gaps","gapHeight","heightValueScale","absStackTotal","yDomain","domain","range","bottom","xMax","xMin","right","nice","sDate","lDate","paddingInner","paddingOuter","_isChartEmpty","newX","newY","threshold","distance","sqrt","pow","_getDomainMargins","totalWidth","reqWidth","mode","margin1","margin2","POSITIVE_INFINITY","hideTickOverlap","step","_getChartTitle","chartTitle","numLines","classes","barCornerRadius","barMinimumHeight","shouldFocusWholeStack","indexNumber","xPoint","barTotalValue","barsToDisplay","yBaseline","yPositiveStart","yNegativeStart","yPoint","heightOfLastBar","singleBar","startColor","rectFocusProps","onMouseMove","onClick","barHeight","gapOffset","minHeight","Fragment","path","className","opacityChangeOnHover","d","rx","roundCorners","cursor","rect","someBarsActive","stackFocusProps","showLabel","barLabel","hideLabels","g","id","text","textAnchor","aria-label","style","direction","unicodeBidi","yAxisTickFormat","showXAxisLablesTooltip","document","getElementById","remove","wrapXAxisLables","xAxisElement","call","tooltipProps","tooltipCls","tooltip","axis","_getMinMaxOfYAxis","yAxisType","values","startValue","endValue","lineLegend","_getOrderedYAxisLabels","_getYDomainMargins","yAxisTickMarginTop","maxBarHeightInLabels","barHeightInLabels","indexOf","yAxisLabelHeight","_mapCategoryToValues","isYAxis","categoryToValues","category","linePoint","legendBars","calloutProps","isCartesian","customCallout","customizedCallout","customCalloutProps","calloutPropsPerDataPoint","tickParams","tickFormat","getMinMaxOfYAxis","createYAxis","datasetForXAxisDomain","getDomainNRangeValues","barwidth","getmargins","getGraphData","getAxisData","onChartMouseLeave","getDomainMargins","showRoundOffXTickValues","stringDatasetForYAxisDomain","getYDomainMargins","children","div","displayName"],"mappings":"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"}