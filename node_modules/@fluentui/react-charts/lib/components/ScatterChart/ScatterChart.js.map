{"version":3,"sources":["../src/components/ScatterChart/ScatterChart.tsx"],"sourcesContent":["'use client';\n\nimport * as React from 'react';\nimport { ScatterChartProps } from './ScatterChart.types';\nimport { useScatterChartStyles } from './useScatterChartStyles.styles';\nimport { Axis as D3Axis } from 'd3-axis';\nimport { select as d3Select } from 'd3-selection';\nimport { Legend, Legends } from '../Legends/index';\nimport { max as d3Max } from 'd3-array';\nimport { useId } from '@fluentui/react-utilities';\nimport type { JSXElement } from '@fluentui/react-utilities';\nimport {\n  areArraysEqual,\n  createNumericYAxis,\n  createStringYAxis,\n  getDomainPaddingForMarkers,\n  domainRangeOfXStringAxis,\n  findNumericMinMaxOfY,\n  IDomainNRange,\n  YAxisType,\n  useRtl,\n  isTextMode,\n  isScatterPolarSeries,\n  isPlottable,\n  getRangeForScatterMarkerSize,\n  domainRangeOfDateForAreaLineScatterVerticalBarCharts,\n  domainRangeOfNumericForAreaLineScatterCharts,\n  sortAxisCategories,\n  findCalloutPoints,\n} from '../../utilities/index';\nimport {\n  AccessibilityProps,\n  CartesianChart,\n  ChildProps,\n  CustomizedCalloutData,\n  Margins,\n  RefArrayData,\n  ScatterChartDataPoint,\n  Chart,\n  ImageExportOptions,\n  LegendContainer,\n  ScatterChartPoints,\n  YValueHover,\n} from '../../index';\nimport { tokens } from '@fluentui/react-theme';\nimport {\n  calloutData,\n  ChartTypes,\n  XAxisTypes,\n  tooltipOfAxislabels,\n  getTypeOfAxis,\n  getNextColor,\n  getColorFromToken,\n} from '../../utilities/index';\nimport { LineChartPoints } from '../../types/DataPoint';\nimport { toImage } from '../../utilities/image-export-utils';\nimport { renderScatterPolarCategoryLabels } from '../../utilities/scatterpolar-utils';\nimport { formatDateToLocaleString } from '@fluentui/chart-utilities';\n\ntype NumericAxis = D3Axis<number | { valueOf(): number }>;\n\ntype ScatterChartDataWithIndex = ScatterChartPoints & { index: number };\n\n// Create a ScatterChart variant which uses these default styles and this styled subcomponent.\n/**\n * ScatterChart component\n * {@docCategory ScatterChart}\n */\nexport const ScatterChart: React.FunctionComponent<ScatterChartProps> = React.forwardRef<\n  HTMLDivElement,\n  ScatterChartProps\n>((props, forwardedRef) => {\n  const _circleId: string = useId('circle');\n  const _seriesId: string = useId('seriesID');\n  const _verticalLine: string = useId('verticalLine');\n  const _tooltipId: string = useId('ScatterChartTooltipId_');\n  const _firstRenderOptimization = true;\n  const _emptyChartId: string = useId('_ScatterChart_empty');\n  let _points: ScatterChartDataWithIndex[] = _injectIndexPropertyInScatterChartData(props.data.scatterChartData);\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  let _xAxisScale: any = '';\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  let _yAxisScale: any = '';\n  let _uniqueCallOutID: string | null = '';\n  let _refArray: RefArrayData[] = [];\n  let margins: Margins;\n  let renderSeries: JSXElement[];\n  let _xAxisLabels: string[] = [];\n  let xAxisCalloutAccessibilityData: AccessibilityProps = {};\n  let _xBandwidth = 0;\n  const cartesianChartRef = React.useRef<Chart>(null);\n  const classes = useScatterChartStyles(props);\n  const _legendsRef = React.useRef<LegendContainer>(null);\n  const _isRTL: boolean = useRtl();\n\n  const [hoverXValue, setHoverXValue] = React.useState<string | number>('');\n  const [activeLegend, setActiveLegend] = React.useState<string>('');\n  const [yValueHover, setYValueHover] = React.useState<YValueHover[]>([]);\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const [selectedLegendPoints, setSelectedLegendPoints] = React.useState<any[]>([]);\n  const [isSelectedLegend, setIsSelectedLegend] = React.useState<boolean>(false);\n  const [activePoint, setActivePoint] = React.useState<string>('');\n  const [stackCalloutProps, setStackCalloutProps] = React.useState<CustomizedCalloutData>();\n  const [clickPosition, setClickPosition] = React.useState({ x: 0, y: 0 });\n  const [isPopoverOpen, setPopoverOpen] = React.useState(false);\n  const [selectedLegends, setSelectedLegends] = React.useState<string[]>(props.legendProps?.selectedLegends || []);\n  const prevSelectedLegendsRef = React.useRef<string[] | undefined>(undefined);\n  const _isTextMode = React.useRef(false);\n  const _isScatterPolarRef = React.useRef(false);\n\n  React.useEffect(() => {\n    if (\n      prevSelectedLegendsRef.current &&\n      !areArraysEqual(prevSelectedLegendsRef.current, props.legendProps?.selectedLegends)\n    ) {\n      setSelectedLegends(props.legendProps?.selectedLegends || []);\n    }\n    prevSelectedLegendsRef.current = props.legendProps?.selectedLegends;\n  }, [props.legendProps?.selectedLegends]);\n\n  React.useImperativeHandle(\n    props.componentRef,\n    () => ({\n      chartContainer: cartesianChartRef.current?.chartContainer ?? null,\n      toImage: (opts?: ImageExportOptions): Promise<string> => {\n        return toImage(cartesianChartRef.current?.chartContainer, _legendsRef.current?.toSVG, _isRTL, opts);\n      },\n    }),\n    [],\n  );\n\n  const _xAxisType: XAxisTypes =\n    props.data.scatterChartData! &&\n    props.data.scatterChartData!.length > 0 &&\n    props.data.scatterChartData![0].data &&\n    props.data.scatterChartData![0].data.length > 0\n      ? (getTypeOfAxis(props.data.scatterChartData![0].data[0].x, true) as XAxisTypes)\n      : XAxisTypes.StringAxis;\n\n  // Detect y axis type (numeric or string)\n  const _yAxisType: YAxisType =\n    props.data.scatterChartData &&\n    props.data.scatterChartData.length > 0 &&\n    props.data.scatterChartData[0].data &&\n    props.data.scatterChartData[0].data.length > 0\n      ? typeof props.data.scatterChartData[0].data[0].y === 'string'\n        ? YAxisType.StringAxis\n        : YAxisType.NumericAxis\n      : YAxisType.NumericAxis;\n\n  const pointsRef = React.useRef<ScatterChartDataWithIndex[] | []>([]);\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const calloutPointsRef = React.useRef<Record<string, YValueHover[]>>({});\n  React.useEffect(() => {\n    /** note that height and width are not used to resize or set as dimesions of the chart,\n     * fitParentContainer is responisble for setting the height and width or resizing of the svg/chart\n     */\n\n    if (_points !== _injectIndexPropertyInScatterChartData(props.data.scatterChartData) || props.data !== _points) {\n      pointsRef.current = _injectIndexPropertyInScatterChartData(props.data.scatterChartData);\n      calloutPointsRef.current = calloutData(pointsRef.current);\n    }\n  }, [props.height, props.width, props.data, _points]);\n\n  function _injectIndexPropertyInScatterChartData(\n    scatterChartData?: ScatterChartPoints[],\n  ): ScatterChartDataWithIndex[] | [] {\n    return scatterChartData\n      ? scatterChartData.map((item: ScatterChartPoints, index: number) => {\n          let color: string;\n          if (typeof item.color === 'undefined') {\n            color = getNextColor(index, 0);\n          } else {\n            color = getColorFromToken(item.color);\n          }\n          return {\n            ...item,\n            index: -1,\n            color,\n          };\n        })\n      : [];\n  }\n\n  function updatePosition(newX: number, newY: number) {\n    const threshold = 1; // Set a threshold for movement\n    const { x, y } = clickPosition;\n    // Calculate the distance moved\n    const distance = Math.sqrt(Math.pow(newX - x, 2) + Math.pow(newY - y, 2));\n    // Update the position only if the distance moved is greater than the threshold\n    if (distance > threshold) {\n      setClickPosition({ x: newX, y: newY });\n      setPopoverOpen(true);\n    }\n  }\n\n  function _getNumericMinMaxOfY(\n    points: ScatterChartPoints[],\n    yAxisType?: YAxisType,\n  ): { startValue: number; endValue: number } {\n    // eslint-disable-next-line @typescript-eslint/no-shadow\n    const { startValue, endValue } = findNumericMinMaxOfY(points, yAxisType);\n    const yPadding = getDomainPaddingForMarkers(startValue, endValue, props.yScaleType);\n\n    return {\n      startValue: startValue - yPadding.start,\n      endValue: endValue + yPadding.end,\n    };\n  }\n\n  function _getDomainNRangeValues(\n    points: any,\n    margins: Margins,\n    width: number,\n    chartType: ChartTypes,\n    isRTL: boolean,\n    xAxisType: XAxisTypes,\n    barWidth: number,\n    tickValues: Date[] | number[] | undefined,\n    shiftX: number,\n  ) {\n    let domainNRangeValue: IDomainNRange;\n    if (xAxisType === XAxisTypes.NumericAxis) {\n      domainNRangeValue = domainRangeOfNumericForAreaLineScatterCharts(\n        points,\n        margins,\n        width,\n        isRTL,\n        props.xScaleType,\n        true,\n      );\n    } else if (xAxisType === XAxisTypes.DateAxis) {\n      domainNRangeValue = domainRangeOfDateForAreaLineScatterVerticalBarCharts(\n        points,\n        margins,\n        width,\n        isRTL,\n        tickValues! as Date[],\n        chartType,\n      );\n    } else {\n      domainNRangeValue = domainRangeOfXStringAxis(margins, width, isRTL);\n    }\n    return domainNRangeValue;\n  }\n\n  function _getMargins(_margins: Margins) {\n    margins = _margins;\n  }\n\n  function _initializeScatterChartData(\n    xScale: NumericAxis,\n    yScale: NumericAxis,\n    containerHeight: number,\n    containerWidth: number,\n    xElement: SVGElement | null,\n  ) {\n    _xAxisScale = xScale;\n    _yAxisScale = yScale;\n    _isTextMode.current = isTextMode(_points);\n    _isScatterPolarRef.current = isScatterPolarSeries(_points);\n    renderSeries = _createPlot(xElement!, containerHeight!);\n  }\n\n  function _onHoverCardHide() {\n    setSelectedLegendPoints([]);\n    setIsSelectedLegend(false);\n  }\n\n  function _createLegends(data: ScatterChartDataWithIndex[]): JSXElement {\n    const { legendProps } = props;\n    const isLegendMultiSelectEnabled = !!(legendProps && !!legendProps.canSelectMultipleLegends);\n    const mapLegendToPoints: Record<string, ScatterChartDataWithIndex[]> = {};\n    data.forEach((point: ScatterChartDataWithIndex) => {\n      if (point.legend) {\n        if (!mapLegendToPoints[point.legend]) {\n          mapLegendToPoints[point.legend] = [];\n        }\n        mapLegendToPoints[point.legend].push(point);\n      }\n    });\n    const legendDataItems: Legend[] = Object.entries(mapLegendToPoints).map(([legendTitle, points]) => {\n      const representativePoint = points[0];\n      // mapping data to the format Legends component needs\n      const legend: Legend = {\n        title: legendTitle,\n        color: representativePoint.color!,\n        onMouseOutAction: () => {\n          setActiveLegend('');\n        },\n        hoverAction: () => {\n          _handleChartMouseLeave();\n          setActiveLegend(legendTitle);\n        },\n        ...(representativePoint.legendShape && {\n          shape: representativePoint.legendShape,\n        }),\n      };\n      return legend;\n    });\n\n    return (\n      <Legends\n        legends={[...legendDataItems]}\n        enabledWrapLines={props.enabledLegendsWrapLines}\n        overflowText={props.legendsOverflowText}\n        {...(isLegendMultiSelectEnabled && { onLegendHoverCardLeave: _onHoverCardHide })}\n        {...props.legendProps}\n        selectedLegends={selectedLegends}\n        onChange={_onLegendSelectionChange}\n        legendRef={_legendsRef}\n      />\n    );\n  }\n\n  function _getOrderedYAxisLabels() {\n    const shouldOrderYAxisLabelsByCategoryOrder =\n      _yAxisType === YAxisType.StringAxis && props.yAxisCategoryOrder !== 'default';\n    if (!shouldOrderYAxisLabelsByCategoryOrder) {\n      // Collect all unique string y values from all data points in all series, in reverse order\n      const yLabelsSet = new Set<string>();\n      for (let i = _points.length - 1; i >= 0; i--) {\n        const point = _points[i];\n        if (point.data && Array.isArray(point.data)) {\n          for (const d of point.data) {\n            if (typeof d.y === 'string') {\n              yLabelsSet.add(d.y);\n            }\n          }\n        }\n      }\n      return Array.from(yLabelsSet);\n    }\n\n    return sortAxisCategories(_mapCategoryToValues(), props.yAxisCategoryOrder);\n  }\n\n  function _mapCategoryToValues() {\n    const categoryToValues: Record<string, number[]> = {};\n    _points.forEach(point => {\n      if (point.data && Array.isArray(point.data)) {\n        point.data.forEach(d => {\n          if (typeof d.y === 'string') {\n            if (!categoryToValues[d.y]) {\n              categoryToValues[d.y] = [];\n            }\n            if (typeof d.x === 'number') {\n              categoryToValues[d.y].push(d.x);\n            }\n          }\n        });\n      }\n    });\n    return categoryToValues;\n  }\n\n  function _onLegendSelectionChange(\n    legendsSelected: string[],\n    event: React.MouseEvent<HTMLButtonElement>,\n    currentLegend?: Legend,\n  ): void {\n    if (props.legendProps?.canSelectMultipleLegends) {\n      setSelectedLegends(legendsSelected);\n    } else {\n      setSelectedLegends(legendsSelected.slice(-1));\n    }\n\n    if (props.legendProps?.onChange) {\n      props.legendProps.onChange(legendsSelected, event, currentLegend);\n    }\n  }\n\n  function _getPointFill(seriesColor: string, pointId: string, pointIndex: number, isLastPoint: boolean) {\n    if (activePoint === pointId) {\n      return tokens.colorNeutralBackground1;\n    } else {\n      return seriesColor;\n    }\n  }\n\n  function _createPlot(xElement: SVGElement, containerHeight: number): JSXElement[] {\n    const series: JSXElement[] = [];\n    if (isSelectedLegend) {\n      _points = selectedLegendPoints;\n    } else {\n      _points = _injectIndexPropertyInScatterChartData(props.data.scatterChartData);\n    }\n\n    if (_xAxisType === XAxisTypes.StringAxis) {\n      _xBandwidth = _xAxisScale.bandwidth() / 2;\n    }\n\n    const maxMarkerSize = d3Max(_points, (point: ScatterChartPoints) => {\n      return d3Max(point.data as ScatterChartDataPoint[], (item: ScatterChartDataPoint) => {\n        return item.markerSize as number;\n      });\n    })!;\n\n    const extraMaxPixels =\n      _xAxisType !== XAxisTypes.StringAxis && _yAxisType !== YAxisType.StringAxis\n        ? getRangeForScatterMarkerSize({\n            data: _points,\n            xScale: _xAxisScale,\n            yScalePrimary: _yAxisScale,\n            xScaleType: props.xScaleType,\n            yScaleType: props.yScaleType,\n          })\n        : 0;\n\n    for (let i = _points.length - 1; i >= 0; i--) {\n      const pointsForSeries: JSXElement[] = [];\n\n      const legendVal: string = _points[i].legend;\n      const seriesColor: string = _points[i].color!;\n      const verticaLineHeight = containerHeight - margins.bottom! + 6;\n\n      for (let j = 0; j < _points[i].data.length; j++) {\n        const { x, y, xAxisCalloutData, xAxisCalloutAccessibilityData } = _points?.[i]?.data[j];\n        const xPoint = _xAxisScale?.(x);\n        // Use string y axis scale if needed\n        const yPoint =\n          _yAxisType === YAxisType.StringAxis\n            ? _yAxisScale?.(y) + (_yAxisScale?.bandwidth ? _yAxisScale.bandwidth() / 2 : 0)\n            : _yAxisScale?.(y);\n        if (!isPlottable(xPoint, yPoint)) {\n          continue;\n        }\n        const seriesId = `${_seriesId}_${i}_${j}`;\n        const circleId = `${_circleId}_${i}_${j}`;\n        const pointMarkerSize = (_points[i].data[j] as ScatterChartDataPoint).markerSize;\n        const minPixel = 4;\n        const maxPixel = 16;\n        const circleRadius =\n          pointMarkerSize && maxMarkerSize !== 0\n            ? _xAxisType !== XAxisTypes.StringAxis\n              ? (pointMarkerSize * extraMaxPixels) / maxMarkerSize\n              : minPixel + ((pointMarkerSize - minPixel) / (maxMarkerSize - minPixel)) * (maxPixel - minPixel)\n            : activePoint === circleId\n            ? 6\n            : 4;\n\n        const isLegendSelected: boolean = _legendHighlighted(legendVal) || _noLegendHighlighted() || isSelectedLegend;\n\n        const currentPointHidden = _points[i].hideNonActiveDots && activePoint !== circleId;\n        const text = _points?.[i].data[j]?.text;\n        if (!_isTextMode.current) {\n          pointsForSeries.push(\n            <>\n              <circle\n                id={circleId}\n                key={circleId}\n                r={Math.max(circleRadius, 4)}\n                cx={xPoint + _xBandwidth}\n                cy={yPoint}\n                data-is-focusable={isLegendSelected}\n                onMouseOver={(event: React.MouseEvent<SVGElement>) =>\n                  _handleHover(\n                    x,\n                    y,\n                    verticaLineHeight,\n                    xAxisCalloutData,\n                    circleId,\n                    xAxisCalloutAccessibilityData,\n                    event,\n                  )\n                }\n                onMouseMove={(event: React.MouseEvent<SVGElement>) =>\n                  _handleHover(\n                    x,\n                    y,\n                    verticaLineHeight,\n                    xAxisCalloutData,\n                    circleId,\n                    xAxisCalloutAccessibilityData,\n                    event,\n                  )\n                }\n                onMouseOut={_handleMouseOut}\n                onFocus={event =>\n                  _handleFocus(event, seriesId, x, xAxisCalloutData, circleId, xAxisCalloutAccessibilityData)\n                }\n                onBlur={_handleMouseOut}\n                {..._getClickHandler(_points[i].data[j].onDataPointClick)}\n                opacity={isLegendSelected && !currentPointHidden ? 1 : 0.1}\n                fill={_getPointFill(seriesColor, circleId, j, false)}\n                stroke={seriesColor}\n                role=\"img\"\n                aria-label={_getAriaLabel(i, j)}\n                tabIndex={isLegendSelected ? 0 : undefined}\n              />\n              ,\n              {text && (\n                <text\n                  key={`${circleId}-label`}\n                  x={xPoint + _xBandwidth}\n                  y={yPoint + Math.max(circleRadius + 12, 16)}\n                  className={classes.markerLabel}\n                >\n                  {text}\n                </text>\n              )}\n            </>,\n          );\n        }\n      }\n\n      if (_isScatterPolarRef.current) {\n        pointsForSeries.push(\n          ...renderScatterPolarCategoryLabels({\n            xAxisScale: _xAxisScale,\n            yAxisScale: _yAxisScale,\n            className: classes.markerLabel || '',\n            lineOptions: (_points?.[i] as Partial<LineChartPoints>)?.lineOptions,\n          }),\n        );\n      }\n\n      series.push(\n        <g\n          key={`series_${i}`}\n          role=\"region\"\n          aria-label={`${legendVal}, series ${i + 1} of ${_points.length} with ${_points[i].data.length} data points.`}\n        >\n          {pointsForSeries}\n        </g>,\n      );\n    }\n    // Removing un wanted tooltip div from DOM, when prop not provided.\n    if (!props.showXAxisLablesTooltip) {\n      try {\n        document.getElementById(_tooltipId) && document.getElementById(_tooltipId)!.remove();\n        // eslint-disable-next-line no-empty\n      } catch (e) {}\n    }\n    // Used to display tooltip at x axis labels.\n    if (!props.wrapXAxisLables && props.showXAxisLablesTooltip) {\n      const xAxisElement = d3Select(xElement).call(_xAxisScale);\n      try {\n        document.getElementById(_tooltipId) && document.getElementById(_tooltipId)!.remove();\n        // eslint-disable-next-line no-empty\n      } catch (e) {}\n      const tooltipProps = {\n        tooltipCls: classes.tooltip!,\n        id: _tooltipId,\n        axis: xAxisElement,\n      };\n      xAxisElement && tooltipOfAxislabels(tooltipProps);\n    }\n    return series;\n  }\n\n  function _handleFocus(\n    event: React.FocusEvent<SVGCircleElement, Element>,\n    seriesId: string,\n    x: number | Date | string,\n    xAxisCalloutData: string | undefined,\n    circleId: string,\n    xAxisCalloutAccessibilityData?: AccessibilityProps,\n  ) {\n    let cx = 0;\n    let cy = 0;\n\n    const targetRect = (event.target as SVGCircleElement).getBoundingClientRect();\n    cx = targetRect.left + targetRect.width / 2;\n    cy = targetRect.top + targetRect.height / 2;\n    updatePosition(cx, cy);\n    _uniqueCallOutID = circleId;\n    const formattedData = x instanceof Date ? formatDateToLocaleString(x, props.culture, props.useUTC as boolean) : x;\n    const found = findCalloutPoints(calloutPointsRef.current, x) as CustomizedCalloutData | undefined;\n    // if no points need to be called out then don't show vertical line and callout card\n\n    if (found) {\n      d3Select(`#${_verticalLine}`)\n        .attr('transform', () => `translate(${_xAxisScale(x) + _xBandwidth}, 0)`)\n        .attr('visibility', 'visibility');\n      _refArray.forEach((obj: RefArrayData) => {\n        if (obj.index === seriesId) {\n          setPopoverOpen(true);\n          xAxisCalloutData ? setHoverXValue(xAxisCalloutData) : setHoverXValue('' + formattedData);\n          setYValueHover(found.values);\n          setStackCalloutProps(found!);\n          setActivePoint(circleId);\n        }\n      });\n    } else {\n      setActivePoint(circleId);\n    }\n  }\n\n  function _handleHover(\n    x: number | Date | string,\n    y: number,\n    lineHeight: number,\n    xAxisCalloutData: string | undefined,\n    circleId: string,\n    xAxisCalloutAccessibilityData: AccessibilityProps | undefined,\n    mouseEvent: React.MouseEvent<SVGElement>,\n  ) {\n    mouseEvent?.persist();\n    const formattedData = x instanceof Date ? formatDateToLocaleString(x, props.culture, props.useUTC as boolean) : x;\n    const found = findCalloutPoints(calloutPointsRef.current, x) as CustomizedCalloutData | undefined;\n    // if no points need to be called out then don't show vertical line and callout card\n\n    if (found) {\n      d3Select(`#${_verticalLine}`)\n        .attr('transform', () => `translate(${_xAxisScale(x) + _xBandwidth}, ${_yAxisScale(y)})`)\n        .attr('visibility', 'visibility')\n        .attr('y2', `${lineHeight - _yAxisScale(y)}`);\n\n      if (_uniqueCallOutID !== circleId) {\n        _uniqueCallOutID = circleId;\n        updatePosition(mouseEvent.clientX, mouseEvent.clientY);\n        xAxisCalloutData ? setHoverXValue(xAxisCalloutData) : setHoverXValue('' + formattedData);\n        setYValueHover(found.values);\n        setStackCalloutProps(found!);\n        setActivePoint(circleId);\n      }\n    } else {\n      setActivePoint(circleId);\n    }\n  }\n\n  /**\n   * Screen readers announce an element as clickable if the onClick attribute is set.\n   * This function sets the attribute only when a click event handler is provided.*/\n\n  function _getClickHandler(func?: () => void): { onClick?: () => void } {\n    if (func) {\n      return {\n        onClick: func,\n      };\n    }\n\n    return {};\n  }\n\n  function _handleMouseOut() {\n    d3Select(`#${_verticalLine}`).attr('visibility', 'hidden');\n  }\n\n  function _handleChartMouseLeave() {\n    _uniqueCallOutID = null;\n    setActivePoint('');\n    if (isPopoverOpen) {\n      setPopoverOpen(false);\n    }\n  }\n\n  /**\n   * This function checks if the given legend is highlighted or not.\n   * A legend can be highlighted in 2 ways:\n   * 1. selection: if the user clicks on it\n   * 2. hovering: if there is no selected legend and the user hovers over it*/\n\n  function _legendHighlighted(legend: string): boolean {\n    return _getHighlightedLegend().includes(legend);\n  }\n\n  /**\n   * This function checks if none of the legends is selected or hovered.*/\n\n  function _noLegendHighlighted(): boolean {\n    return _getHighlightedLegend().length === 0;\n  }\n\n  function _getHighlightedLegend(): string[] {\n    return selectedLegends.length > 0 ? selectedLegends : activeLegend ? [activeLegend] : [];\n  }\n\n  function _getAriaLabel(seriesIndex: number, pointIndex: number): string {\n    const series = _points[seriesIndex];\n    const point = series.data[pointIndex];\n    const formattedDate =\n      point.x instanceof Date ? formatDateToLocaleString(point.x, props.culture, props.useUTC as boolean) : point.x;\n    const xValue = point.xAxisCalloutData || formattedDate;\n    const legend = series.legend;\n    const yValue = point.yAxisCalloutData || point.y;\n    return point.callOutAccessibilityData?.ariaLabel || `${xValue}. ${legend}, ${yValue}.`;\n  }\n\n  function _isChartEmpty(): boolean {\n    return !(\n      props.data &&\n      props.data.scatterChartData &&\n      props.data.scatterChartData.length > 0 &&\n      props.data.scatterChartData.filter((item: ScatterChartPoints) => item.data.length).length > 0\n    );\n  }\n\n  const { legendProps, tickValues, tickFormat } = props;\n  _points = _injectIndexPropertyInScatterChartData(props.data.scatterChartData);\n\n  let points = _points as ScatterChartPoints[];\n  if (legendProps && !!legendProps.canSelectMultipleLegends) {\n    points = selectedLegendPoints.length >= 1 ? selectedLegendPoints : _points;\n    calloutPointsRef.current = calloutData(points);\n  }\n\n  let legendBars = null;\n  // reduce computation cost by only creating legendBars\n  // if when hideLegend is false.\n  // NOTE: they are rendered only when hideLegend is false in CartesianChart.\n  if (!props.hideLegend && !_isTextMode.current) {\n    legendBars = _createLegends(_points!); // ToDo: Memoize legends to improve performance.\n  }\n  const calloutProps = {\n    YValueHover: yValueHover,\n    hoverXValue,\n    descriptionMessage:\n      props.getCalloutDescriptionMessage && stackCalloutProps\n        ? props.getCalloutDescriptionMessage(stackCalloutProps)\n        : undefined,\n    'data-is-focusable': true,\n    xAxisCalloutAccessibilityData,\n    ...props.calloutProps,\n    clickPosition,\n    isPopoverOpen,\n    isCalloutForStack: true,\n    culture: props.culture,\n    isCartesian: true,\n  };\n  const tickParams = {\n    tickValues,\n    tickFormat,\n  };\n\n  const xAxisLabels: string[] = _points\n    .map((point: ScatterChartDataWithIndex) => point.data.map((dp: ScatterChartDataPoint) => dp.x as string))\n    .flat();\n\n  _xAxisLabels = [...new Set(xAxisLabels)];\n\n  // Compute unique y axis labels for string y axis\n  const _yAxisLabels: string[] = _getOrderedYAxisLabels();\n\n  return !_isChartEmpty() ? (\n    <CartesianChart\n      {...props}\n      chartTitle={props.data.chartTitle}\n      points={points}\n      chartType={ChartTypes.ScatterChart}\n      calloutProps={calloutProps}\n      tickParams={tickParams}\n      legendBars={legendBars}\n      getmargins={_getMargins}\n      getGraphData={_initializeScatterChartData}\n      xAxisType={_xAxisType}\n      yAxisType={_yAxisType}\n      // Pass stringDatasetForYAxisDomain only if y axis is string\n      {...(_yAxisType === YAxisType.StringAxis ? { stringDatasetForYAxisDomain: _yAxisLabels } : {})}\n      getMinMaxOfYAxis={_getNumericMinMaxOfY}\n      getDomainNRangeValues={_getDomainNRangeValues}\n      createYAxis={createNumericYAxis}\n      createStringYAxis={createStringYAxis}\n      onChartMouseLeave={_handleChartMouseLeave}\n      enableFirstRenderOptimization={_firstRenderOptimization}\n      datasetForXAxisDomain={_xAxisLabels}\n      componentRef={cartesianChartRef}\n      {...(_isScatterPolarRef.current ? { yMaxValue: 1, yMinValue: -1 } : {})}\n      /* eslint-disable react/jsx-no-bind */\n      // eslint-disable-next-line react/no-children-prop\n      children={(props: ChildProps) => {\n        _xAxisScale = props.xScale!;\n        _yAxisScale = props.yScalePrimary!;\n        return (\n          <>\n            <g>\n              <line\n                x1={0}\n                y1={0}\n                x2={0}\n                y2={props.containerHeight}\n                stroke={'#323130'}\n                id={_verticalLine}\n                visibility={'hidden'}\n                strokeDasharray={'5,5'}\n              />\n              <g>{renderSeries}</g>\n            </g>\n          </>\n        );\n      }}\n    />\n  ) : (\n    <div id={_emptyChartId} role={'alert'} style={{ opacity: '0' }} aria-label={'Graph has no data to display'} />\n  );\n});\nScatterChart.displayName = 'ScatterChart';\n"],"names":["React","useScatterChartStyles","select","d3Select","Legends","max","d3Max","useId","areArraysEqual","createNumericYAxis","createStringYAxis","getDomainPaddingForMarkers","domainRangeOfXStringAxis","findNumericMinMaxOfY","YAxisType","useRtl","isTextMode","isScatterPolarSeries","isPlottable","getRangeForScatterMarkerSize","domainRangeOfDateForAreaLineScatterVerticalBarCharts","domainRangeOfNumericForAreaLineScatterCharts","sortAxisCategories","findCalloutPoints","CartesianChart","tokens","calloutData","ChartTypes","XAxisTypes","tooltipOfAxislabels","getTypeOfAxis","getNextColor","getColorFromToken","toImage","renderScatterPolarCategoryLabels","formatDateToLocaleString","ScatterChart","forwardRef","props","forwardedRef","_circleId","_seriesId","_verticalLine","_tooltipId","_firstRenderOptimization","_emptyChartId","_points","_injectIndexPropertyInScatterChartData","data","scatterChartData","_xAxisScale","_yAxisScale","_uniqueCallOutID","_refArray","margins","renderSeries","_xAxisLabels","xAxisCalloutAccessibilityData","_xBandwidth","cartesianChartRef","useRef","classes","_legendsRef","_isRTL","hoverXValue","setHoverXValue","useState","activeLegend","setActiveLegend","yValueHover","setYValueHover","selectedLegendPoints","setSelectedLegendPoints","isSelectedLegend","setIsSelectedLegend","activePoint","setActivePoint","stackCalloutProps","setStackCalloutProps","clickPosition","setClickPosition","x","y","isPopoverOpen","setPopoverOpen","selectedLegends","setSelectedLegends","legendProps","prevSelectedLegendsRef","undefined","_isTextMode","_isScatterPolarRef","useEffect","current","useImperativeHandle","componentRef","chartContainer","opts","toSVG","_xAxisType","length","StringAxis","_yAxisType","NumericAxis","pointsRef","calloutPointsRef","height","width","map","item","index","color","updatePosition","newX","newY","threshold","distance","Math","sqrt","pow","_getNumericMinMaxOfY","points","yAxisType","startValue","endValue","yPadding","yScaleType","start","end","_getDomainNRangeValues","chartType","isRTL","xAxisType","barWidth","tickValues","shiftX","domainNRangeValue","xScaleType","DateAxis","_getMargins","_margins","_initializeScatterChartData","xScale","yScale","containerHeight","containerWidth","xElement","_createPlot","_onHoverCardHide","_createLegends","isLegendMultiSelectEnabled","canSelectMultipleLegends","mapLegendToPoints","forEach","point","legend","push","legendDataItems","Object","entries","legendTitle","representativePoint","title","onMouseOutAction","hoverAction","_handleChartMouseLeave","legendShape","shape","legends","enabledWrapLines","enabledLegendsWrapLines","overflowText","legendsOverflowText","onLegendHoverCardLeave","onChange","_onLegendSelectionChange","legendRef","_getOrderedYAxisLabels","shouldOrderYAxisLabelsByCategoryOrder","yAxisCategoryOrder","yLabelsSet","Set","i","Array","isArray","d","add","from","_mapCategoryToValues","categoryToValues","legendsSelected","event","currentLegend","slice","_getPointFill","seriesColor","pointId","pointIndex","isLastPoint","colorNeutralBackground1","series","bandwidth","maxMarkerSize","markerSize","extraMaxPixels","yScalePrimary","pointsForSeries","legendVal","verticaLineHeight","bottom","j","xAxisCalloutData","xPoint","yPoint","seriesId","circleId","pointMarkerSize","minPixel","maxPixel","circleRadius","isLegendSelected","_legendHighlighted","_noLegendHighlighted","currentPointHidden","hideNonActiveDots","text","circle","id","key","r","cx","cy","data-is-focusable","onMouseOver","_handleHover","onMouseMove","onMouseOut","_handleMouseOut","onFocus","_handleFocus","onBlur","_getClickHandler","onDataPointClick","opacity","fill","stroke","role","aria-label","_getAriaLabel","tabIndex","className","markerLabel","xAxisScale","yAxisScale","lineOptions","g","showXAxisLablesTooltip","document","getElementById","remove","e","wrapXAxisLables","xAxisElement","call","tooltipProps","tooltipCls","tooltip","axis","targetRect","target","getBoundingClientRect","left","top","formattedData","Date","culture","useUTC","found","attr","obj","values","lineHeight","mouseEvent","persist","clientX","clientY","func","onClick","_getHighlightedLegend","includes","seriesIndex","formattedDate","xValue","yValue","yAxisCalloutData","callOutAccessibilityData","ariaLabel","_isChartEmpty","filter","tickFormat","legendBars","hideLegend","calloutProps","YValueHover","descriptionMessage","getCalloutDescriptionMessage","isCalloutForStack","isCartesian","tickParams","xAxisLabels","dp","flat","_yAxisLabels","chartTitle","getmargins","getGraphData","stringDatasetForYAxisDomain","getMinMaxOfYAxis","getDomainNRangeValues","createYAxis","onChartMouseLeave","enableFirstRenderOptimization","datasetForXAxisDomain","yMaxValue","yMinValue","children","line","x1","y1","x2","y2","visibility","strokeDasharray","div","style","displayName"],"mappings":"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"}