{"version":3,"sources":["../src/components/HeatMapChart/HeatMapChart.tsx"],"sourcesContent":["'use client';\n\nimport * as React from 'react';\nimport { HeatMapChartProps } from './HeatMapChart.types';\nimport {\n  AccessibilityProps,\n  Chart,\n  HeatMapChartData,\n  HeatMapChartDataPoint,\n  Margins,\n  ImageExportOptions,\n} from '../../types/index';\nimport {\n  ChartTypes,\n  getAccessibleDataObject,\n  getColorContrast,\n  getTypeOfAxis,\n  resolveCSSVariables,\n  XAxisTypes,\n  YAxisType,\n  createNumericYAxis,\n  IMargins,\n  IDomainNRange,\n  domainRangeOfXStringAxis,\n  createStringYAxis,\n  useRtl,\n  sortAxisCategories,\n} from '../../utilities/index';\nimport { formatToLocaleString } from '@fluentui/chart-utilities';\nimport { CartesianChart, ChartPopoverProps, ChildProps } from '../CommonComponents/index';\nimport { useId } from '@fluentui/react-utilities';\nimport type { JSXElement } from '@fluentui/react-utilities';\nimport { tokens } from '@fluentui/react-theme';\nimport { useHeatMapChartStyles } from './useHeatMapChartStyles.styles';\nimport { Legend, Legends, LegendContainer } from '../Legends/index';\nimport { scaleLinear as d3ScaleLinear } from 'd3-scale';\nimport { format as d3Format } from 'd3-format';\nimport { timeFormat as d3TimeFormat } from 'd3-time-format';\nimport { toImage } from '../../utilities/image-export-utils';\n\ntype DataSet = {\n  dataSet: RectanglesGraphData;\n  yAxisPoints: string[];\n  xAxisPoints: string[];\n};\ntype FlattenData = HeatMapChartDataPoint & {\n  legend: string;\n};\ntype RectanglesGraphData = { [key: string]: FlattenData[] };\n\nexport const HeatMapChart: React.FunctionComponent<HeatMapChartProps> = React.forwardRef<\n  HTMLDivElement,\n  HeatMapChartProps\n>(\n  (\n    props = {\n      xAxisCategoryOrder: 'default',\n      yAxisCategoryOrder: 'default',\n      data: [],\n      domainValuesForColorScale: [],\n      rangeValuesForColorScale: [],\n    },\n    forwardedRef,\n  ) => {\n    const classes = useHeatMapChartStyles(props);\n    const _stringXAxisDataPoints = React.useRef<string[]>([]);\n    const _stringYAxisDataPoints = React.useRef<string[]>([]);\n    const _dataSet = React.useRef<RectanglesGraphData>({});\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const _colorScale = React.useRef<any>();\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const _xAxisScale = React.useRef<any>();\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const _yAxisScale = React.useRef<any>();\n    const _xAxisType = React.useRef<XAxisTypes>();\n    const _yAxisType = React.useRef<YAxisType>();\n    const _calloutAnchorPoint = React.useRef<FlattenData | null>(null);\n    const _emptyChartId = useId('_HeatMap_empty');\n    const _margins = React.useRef<Margins>({});\n    const cartesianChartRef = React.useRef<Chart>(null);\n    const _legendsRef = React.useRef<LegendContainer>(null);\n    const _isRtl = useRtl();\n\n    const [selectedLegend, setSelectedLegend] = React.useState<string>('');\n    const [activeLegend, setActiveLegend] = React.useState<string>('');\n    const [isPopoverOpen, setPopoverOpen] = React.useState<boolean>(false);\n    const [calloutLegend, setCalloutLegend] = React.useState<string>('');\n    const [calloutTextColor, setCalloutTextColor] = React.useState<string>('');\n    const [calloutYValue, setCalloutYValue] = React.useState<string>('');\n    const [ratio, setRatio] = React.useState<[number, number]>();\n    const [descriptionMessage, setDescriptionMessage] = React.useState<string>('');\n    const [callOutAccessibilityData, setCallOutAccessibilityData] = React.useState<AccessibilityProps>();\n    const [clickPosition, setClickPosition] = React.useState({ x: 0, y: 0 });\n\n    React.useImperativeHandle(\n      props.componentRef,\n      () => ({\n        chartContainer: cartesianChartRef.current?.chartContainer ?? null,\n        toImage: (opts?: ImageExportOptions): Promise<string> => {\n          return toImage(cartesianChartRef.current?.chartContainer, _legendsRef.current?.toSVG, _isRtl, opts);\n        },\n      }),\n      [],\n    );\n\n    function _getMinMaxOfYAxis() {\n      return { startValue: 0, endValue: 0 };\n    }\n\n    function _getDomainNRangeValues(\n      points: HeatMapChartDataPoint[],\n      margins: IMargins,\n      width: number,\n      chartType: ChartTypes,\n      isRTL: boolean,\n      xAxisType: XAxisTypes,\n      barWidth: number,\n      tickValues: Date[] | number[] | undefined,\n      shiftX: number,\n    ) {\n      let domainNRangeValue: IDomainNRange;\n      if (xAxisType === XAxisTypes.NumericAxis || xAxisType === XAxisTypes.DateAxis) {\n        domainNRangeValue = { dStartValue: 0, dEndValue: 0, rStartValue: 0, rEndValue: 0 };\n      } else {\n        domainNRangeValue = domainRangeOfXStringAxis(_margins.current, width, isRTL);\n      }\n      return domainNRangeValue;\n    }\n\n    const _getXandY = (): { x: string | Date | number; y: string | Date | number } => {\n      let x: string | Date | number = '';\n      let y: string | Date | number = '';\n      props.data.forEach((item: HeatMapChartData) => {\n        if (item.data && item.data.length > 0) {\n          x = item.data[0].x;\n          y = item.data[0].y;\n          return { x, y };\n        }\n      });\n      return { x, y };\n    };\n\n    const _getMargins = (margins: Margins) => {\n      _margins.current = margins;\n    };\n\n    const _getOpacity = (legendTitle: string): string => {\n      const opacity = _legendHighlighted(legendTitle) || _noLegendHighlighted() ? '1' : '0.1';\n      return opacity;\n    };\n\n    const _onRectFocus = (id: string, data: FlattenData, focusEvent: React.FocusEvent<SVGGElement>): void => {\n      const boundingRect = focusEvent.currentTarget.getBoundingClientRect();\n      const clientX = boundingRect.left + boundingRect.width / 2;\n      const clientY = boundingRect.top + boundingRect.height / 2;\n      updatePosition(clientX, clientY);\n      /** Show the callout if highlighted rectangle is focused and Hide it if unhighlighted rectangle is focused */\n      setPopoverOpen(selectedLegend === '' || selectedLegend === data.legend);\n      setCalloutYValue(`${data.rectText}`);\n      setCalloutTextColor(Number.isNaN(data.value) ? tokens.colorNeutralForeground1 : _colorScale.current(data.value));\n      setCalloutLegend(data.legend);\n      setRatio(data.ratio);\n      setDescriptionMessage(data.descriptionMessage || '');\n      setCallOutAccessibilityData(data.callOutAccessibilityData);\n    };\n\n    const _onRectMouseOver = (id: string, data: FlattenData, mouseEvent: React.MouseEvent<SVGGElement>): void => {\n      mouseEvent.persist();\n      if (_calloutAnchorPoint.current !== data) {\n        _calloutAnchorPoint.current = data;\n        updatePosition(mouseEvent.clientX, mouseEvent.clientY);\n        /** Show the callout if highlighted rectangle is hovered and Hide it if unhighlighted rectangle is hovered */\n        setPopoverOpen(selectedLegend === '' || selectedLegend === data.legend);\n        setCalloutYValue(`${data.rectText}`);\n        setCalloutTextColor(\n          Number.isNaN(data.value) ? tokens.colorNeutralForeground1 : _colorScale.current(data.value),\n        );\n        setCalloutLegend(data.legend);\n        setRatio(data.ratio);\n        setDescriptionMessage(data.descriptionMessage || '');\n        setCallOutAccessibilityData(data.callOutAccessibilityData);\n      }\n    };\n\n    const _onRectBlurOrMouseOut = (): void => {\n      /**/\n    };\n\n    const _handleChartMouseLeave = (): void => {\n      _calloutAnchorPoint.current = null;\n      setPopoverOpen(false);\n    };\n\n    const _getInvertedTextColor = (color: string): string => {\n      return color === tokens.colorNeutralForeground1 ? tokens.colorNeutralBackground1 : tokens.colorNeutralForeground1;\n    };\n\n    /**\n     * This is the function which is responsible for\n     * drawing the rectangle in the graph and also\n     * attaching dom events to that rectangles\n     */\n    const _createRectangles = (): React.ReactNode => {\n      const rectangles: JSXElement[] = [];\n      const yAxisDataPoints = _stringYAxisDataPoints.current.slice().reverse();\n      /**\n       * yAxisDataPoint is noting but the DataPoint\n       * which will be rendered on the y-axis\n       */\n      yAxisDataPoints.forEach((yAxisDataPoint: string) => {\n        let index = 0;\n        _stringXAxisDataPoints.current.forEach((xAxisDataPoint: string) => {\n          let rectElement: JSXElement;\n          const id = `x${xAxisDataPoint}y${yAxisDataPoint}`;\n          if (\n            _dataSet.current[yAxisDataPoint][index]?.x === xAxisDataPoint &&\n            typeof _dataSet.current[yAxisDataPoint][index]?.value === 'number'\n          ) {\n            /**\n             * dataPointObject is an object where it contains information on single\n             * data point such as x, y , value, rectText property of the rectangle\n             */\n            const dataPointObject = _dataSet.current[yAxisDataPoint][index];\n            let styleRules = '';\n            let foregroundColor = tokens.colorNeutralForeground1;\n            if (cartesianChartRef.current?.chartContainer) {\n              styleRules = resolveCSSVariables(cartesianChartRef.current.chartContainer, foregroundColor);\n            }\n            const contrastRatio = getColorContrast(styleRules, _colorScale.current(dataPointObject.value));\n            if (contrastRatio < 3) {\n              foregroundColor = _getInvertedTextColor(foregroundColor);\n            }\n            rectElement = (\n              <g\n                key={id}\n                role=\"img\"\n                aria-label={_getAriaLabel(dataPointObject)}\n                tabIndex={_legendHighlighted(dataPointObject.legend) || _noLegendHighlighted() ? 0 : -1}\n                fillOpacity={_getOpacity(dataPointObject.legend)}\n                transform={`translate(${_xAxisScale.current(dataPointObject.x)}, ${_yAxisScale.current(\n                  dataPointObject.y,\n                )})`}\n                onFocus={e => _onRectFocus(id, dataPointObject, e)}\n                onBlur={_onRectBlurOrMouseOut}\n                onMouseOver={e => _onRectMouseOver(id, dataPointObject, e)}\n                onMouseOut={_onRectBlurOrMouseOut}\n              >\n                <rect\n                  fill={_colorScale.current(dataPointObject.value)}\n                  width={_xAxisScale.current.bandwidth()}\n                  height={_yAxisScale.current.bandwidth()}\n                  onClick={dataPointObject.onClick}\n                />\n                <text\n                  dominantBaseline={'middle'}\n                  textAnchor={'middle'}\n                  className={classes.text}\n                  transform={`translate(${_xAxisScale.current.bandwidth() / 2}, ${\n                    _yAxisScale.current.bandwidth() / 2\n                  })`}\n                  fill={foregroundColor}\n                >\n                  {formatToLocaleString(dataPointObject.rectText, props.culture, props.useUTC) as React.ReactNode}\n                </text>\n              </g>\n            );\n            index++;\n          } else {\n            const dataPointObject: FlattenData = {\n              x: xAxisDataPoint,\n              y: yAxisDataPoint,\n              value: NaN,\n              rectText: 'No data available',\n              legend: '',\n            };\n            rectElement = (\n              <g\n                key={id}\n                role=\"img\"\n                aria-label={_getAriaLabel(dataPointObject)}\n                tabIndex={_noLegendHighlighted() ? 0 : -1}\n                transform={`translate(${_xAxisScale.current(dataPointObject.x)}, ${_yAxisScale.current(\n                  dataPointObject.y,\n                )})`}\n                onFocus={e => _onRectFocus(id, dataPointObject, e)}\n                onBlur={_onRectBlurOrMouseOut}\n                onMouseOver={e => _onRectMouseOver(id, dataPointObject, e)}\n                onMouseOut={_onRectBlurOrMouseOut}\n              >\n                <rect\n                  fill=\"transparent\"\n                  width={_xAxisScale.current.bandwidth()}\n                  height={_yAxisScale.current.bandwidth()}\n                />\n              </g>\n            );\n          }\n          rectangles.push(rectElement);\n        });\n      });\n      return rectangles;\n    };\n    /**\n     * when the legend is hovered we need to highlight\n     * all the rectangles which fall under that category\n     * and un-highlight the rest of them\n     * @param legendTitle\n     */\n    const _onLegendHover = (legendTitle: string): void => {\n      setActiveLegend(legendTitle);\n    };\n\n    /**\n     * when the mouse is out from the legend , we need\n     * to show the graph in initial mode.\n     */\n    const _onLegendLeave = (): void => {\n      setActiveLegend('');\n    };\n    /**\n     * @param legendTitle\n     * when the legend is clicked we need to highlight\n     * all the rectangles which fall under that category\n     * and un highlight the rest of them\n     */\n    const _onLegendClick = (legendTitle: string): void => {\n      /**\n       * check if the legend is already selceted,\n       * if yes, un-select the legend, else\n       * set the selected legend state to legendTitle\n       */\n      if (selectedLegend === legendTitle) {\n        setSelectedLegend('');\n      } else {\n        setSelectedLegend(legendTitle);\n      }\n    };\n    const _createLegendBars = (): JSXElement => {\n      const { data, legendProps } = props;\n      const legends: Legend[] = [];\n      data.forEach((item: HeatMapChartData) => {\n        const legend: Legend = {\n          title: item.legend,\n          color: _colorScale.current(item.value),\n          action: () => {\n            _onLegendClick(item.legend);\n          },\n          hoverAction: () => {\n            _handleChartMouseLeave();\n            _onLegendHover(item.legend);\n          },\n          onMouseOutAction: () => {\n            _onLegendLeave();\n          },\n        };\n        legends.push(legend);\n      });\n      return <Legends {...legendProps} legends={legends} legendRef={_legendsRef} />;\n    };\n\n    const _getColorScale = () => {\n      const { domainValuesForColorScale, rangeValuesForColorScale } = props;\n      return d3ScaleLinear()\n        .domain(domainValuesForColorScale)\n        .range(rangeValuesForColorScale as unknown as number[]);\n    };\n\n    const _getXIndex = (value: string | Date | number): string => {\n      if (_xAxisType.current === XAxisTypes.DateAxis) {\n        return `${(value as Date).getTime()}`;\n      } else if (_xAxisType.current === XAxisTypes.StringAxis) {\n        return value as string;\n      } else if (_xAxisType.current === XAxisTypes.NumericAxis) {\n        return `${value}`;\n      } else {\n        return '';\n      }\n    };\n    const _getYIndex = (value: string | Date | number): string => {\n      if (_yAxisType.current === YAxisType.DateAxis) {\n        return `${(value as Date).getTime()}`;\n      } else if (_yAxisType.current === YAxisType.StringAxis) {\n        return value as string;\n      } else if (_yAxisType.current === YAxisType.NumericAxis) {\n        return `${value}`;\n      } else {\n        return '';\n      }\n    };\n\n    const { xAxisStringFormatter } = props;\n    const _getFormattedLabelForXAxisDataPoint = React.useCallback(\n      (point: string): string => {\n        return xAxisStringFormatter ? xAxisStringFormatter(point) : point;\n      },\n      [xAxisStringFormatter],\n    );\n\n    const { yAxisStringFormatter } = props;\n    const _getFormattedLabelForYAxisDataPoint = React.useCallback(\n      (point: string): string => {\n        return yAxisStringFormatter ? yAxisStringFormatter(point) : point;\n      },\n      [yAxisStringFormatter],\n    );\n\n    /**\n     * This function will return the final sorted and formatted x-axis points\n     * which will be rendered on the x-axis\n     * @param points\n     * @returns x-axis points\n     */\n    const _getXAxisDataPoints = React.useCallback(\n      (points: { [key: string]: '1' }): string[] => {\n        let xAxisPoints: string[] = [];\n        const unFormattedXAxisDataPoints = _getOrderedXAxisLabels(points);\n        xAxisPoints = unFormattedXAxisDataPoints.map((xPoint: string) => {\n          if (_xAxisType.current === XAxisTypes.DateAxis) {\n            return _getStringFormattedDate(xPoint, props.xAxisDateFormatString);\n          } else if (_xAxisType.current === XAxisTypes.NumericAxis) {\n            return _getStringFormattedNumber(xPoint, props.xAxisNumberFormatString);\n          } else {\n            return _getFormattedLabelForXAxisDataPoint(xPoint);\n          }\n        });\n\n        return xAxisPoints;\n      },\n      [\n        _getFormattedLabelForXAxisDataPoint,\n        props.sortOrder,\n        props.xAxisDateFormatString,\n        props.xAxisNumberFormatString,\n      ],\n    );\n\n    /**\n     * This function will return the final sorted and formatted y-axis points\n     * which will be rendered on the y-axis\n     * @param points\n     * @returns yaxis points\n     */\n    const _getYAxisDataPoints = React.useCallback(\n      (points: { [key: string]: '1' }): string[] => {\n        let yAxisPoints: string[] = [];\n        const unFormattedYAxisDataPoints = _getOrderedYAxisLabels(points);\n        yAxisPoints = unFormattedYAxisDataPoints.map((yPoint: string) => {\n          if (_yAxisType.current === YAxisType.DateAxis) {\n            return _getStringFormattedDate(yPoint, props.yAxisDateFormatString);\n          } else if (_yAxisType.current === YAxisType.NumericAxis) {\n            return _getStringFormattedNumber(yPoint, props.yAxisNumberFormatString);\n          } else {\n            return _getFormattedLabelForYAxisDataPoint(yPoint);\n          }\n        });\n\n        return yAxisPoints;\n      },\n      [\n        _getFormattedLabelForYAxisDataPoint,\n        props.sortOrder,\n        props.yAxisDateFormatString,\n        props.yAxisNumberFormatString,\n      ],\n    );\n\n    /**\n     * This will create a new data set based on the prop\n     * @data\n     * We will be using This data set to contsruct our rectangles\n     * in the chart, we use this data set becuase, when we loop in this\n     * data and build the heat map, it will support accessibility as\n     * specified in the figma\n     */\n\n    const _createNewDataSet = React.useCallback(\n      (\n        data: HeatMapChartData[],\n        xAxisDateFormatString: string | undefined,\n        xAxisNumberFormatString: string | undefined,\n        yAxisDateFormatString: string | undefined,\n        yAxisNumberFormatString: string | undefined,\n      ): DataSet => {\n        /**\n         * please do not destructure any of the props here,\n         * instead send them as parameter to this functions so that\n         * this functions get called whenever the prop changes\n         */\n        const flattenData: FlattenData[] = [];\n        /**\n         * below for each loop will store all the datapoints in the one array.\n         * basically it will flatten the nestesd array (data prop) into single array\n         * of object. where each object contains x, y, rectText , value and legend propety of single\n         * data point.\n         */\n        data.forEach((item: HeatMapChartData) => {\n          item.data.forEach((point: HeatMapChartDataPoint) => {\n            flattenData.push({ ...point, legend: item.legend });\n          });\n        });\n        const yPoints: RectanglesGraphData = {};\n        const uniqueYPoints: { [key: string]: '1' } = {};\n        const uniqueXPoints: { [key: string]: '1' } = {};\n        flattenData.forEach((item: FlattenData) => {\n          const posX = _getXIndex(item.x);\n          const posY = _getYIndex(item.y);\n\n          uniqueXPoints[posX] = '1';\n          uniqueYPoints[posY] = '1';\n          /** we will check if the property(posY) is already there in object, if  Yes,\n           *  then we will append the item in the Array related to the pos, if not\n           *  then we will simply append the item in the new Array and\n           *  assign that array to the  property (posY) in the Object\n           *  and finally we will get the array of Objects associated to each\n           *  property (which is nothing but y data point) and object in the\n           *  array are noting but x data points associated to the property y\n           */\n          if (yPoints[posY]) {\n            yPoints[posY] = [...yPoints[posY], item];\n          } else {\n            yPoints[posY] = [item];\n          }\n        });\n        /**\n         * we will now sort(ascending) the array's of y data point based on the x value\n         * sorting is important to achive the accessibility order of the\n         * rectangles and then format the x and y datapoints respectively\n         */\n        Object.keys(yPoints).forEach((item: string) => {\n          yPoints[item] = _getOrderedXPoints(yPoints[item]);\n\n          yPoints[item].forEach((datapoint: HeatMapChartDataPoint) => {\n            if (_xAxisType.current === XAxisTypes.DateAxis) {\n              datapoint.x = _getStringFormattedDate(datapoint.x as string, xAxisDateFormatString);\n            }\n            if (_xAxisType.current === XAxisTypes.NumericAxis) {\n              datapoint.x = _getStringFormattedNumber(datapoint.x as string, xAxisNumberFormatString);\n            }\n            if (_xAxisType.current === XAxisTypes.StringAxis) {\n              datapoint.x = _getFormattedLabelForXAxisDataPoint(datapoint.x as string);\n            }\n            if (_yAxisType.current === YAxisType.DateAxis) {\n              datapoint.y = _getStringFormattedDate(datapoint.y as string, yAxisDateFormatString);\n            }\n            if (_yAxisType.current === YAxisType.NumericAxis) {\n              datapoint.y = _getStringFormattedNumber(datapoint.y as string, yAxisNumberFormatString);\n            }\n            if (_yAxisType.current === YAxisType.StringAxis) {\n              datapoint.y = _getFormattedLabelForYAxisDataPoint(datapoint.y as string);\n            }\n          });\n        });\n        /**\n         * if  y-axis data points are of type date or number or if we have string formatter,\n         * then we need to change data points  to their respective string\n         * format, becuase in the private variable _stringYAxisDatapoints, points will be stored in\n         * string format. and in here `yPoint` are not so we need to change, so that\n         * function `_createRectangles` should work perfetcly while looping, and  if we don't change\n         * then `_createRectangles` will fail while looping, causing the error\n         * Cannot read property 'forEach' of undefined\n         */\n\n        Object.keys(yPoints).forEach((yPoint: string) => {\n          if (_yAxisType.current === YAxisType.DateAxis) {\n            yPoints[_getStringFormattedDate(yPoint, yAxisDateFormatString)] = yPoints[yPoint];\n          } else if (_yAxisType.current === YAxisType.NumericAxis) {\n            yPoints[`${_getStringFormattedNumber(yPoint, yAxisNumberFormatString)}`] = yPoints[yPoint];\n          } else {\n            yPoints[_getFormattedLabelForYAxisDataPoint(yPoint)] = yPoints[yPoint];\n          }\n        });\n        /**\n         * assigning new data set\n         */\n        const dataSet = yPoints;\n        /**\n         * These are the Y axis data points which will get rendered in the\n         * Y axis in graph\n         */\n        const yAxisPoints = _getYAxisDataPoints(uniqueYPoints);\n        /**\n         * These are the x axis data points which will get rendered in the\n         * x axis in the graph\n         */\n\n        const xAxisPoints = _getXAxisDataPoints(uniqueXPoints);\n        return {\n          dataSet,\n          yAxisPoints,\n          xAxisPoints,\n        };\n      },\n      [\n        _getFormattedLabelForXAxisDataPoint,\n        _getFormattedLabelForYAxisDataPoint,\n        _getXAxisDataPoints,\n        _getYAxisDataPoints,\n        props.sortOrder,\n      ],\n    );\n\n    const _getStringFormattedDate = (point: string, formatString?: string): string => {\n      const date = new Date();\n      date.setTime(+point);\n      return d3TimeFormat(formatString || '%b/%d')(date);\n    };\n\n    const _getStringFormattedNumber = (point: string, formatString?: string): string => {\n      return d3Format(formatString || '.2~s')(+point);\n    };\n\n    /**\n     * This function checks if the given legend is highlighted or not.\n     * A legend can be highlighted in 2 ways:\n     * 1. selection: if the user clicks on it\n     * 2. hovering: if there is no selected legend and the user hovers over it\n     */\n    const _legendHighlighted = (legendTitle: string) => {\n      return selectedLegend === legendTitle || (selectedLegend === '' && activeLegend === legendTitle);\n    };\n\n    /**\n     * This function checks if none of the legends is selected or hovered.\n     */\n    const _noLegendHighlighted = () => {\n      return selectedLegend === '' && activeLegend === '';\n    };\n\n    const _getAriaLabel = (point: FlattenData): string => {\n      const xValue = point.x;\n      const yValue = point.y;\n      const legend = point.legend;\n      const zValue = point.ratio ? `${point.ratio[0]}/${point.ratio[1]}` : point.rectText || point.value;\n      const description = point.descriptionMessage;\n      return (\n        point.callOutAccessibilityData?.ariaLabel ||\n        `${xValue}, ${yValue}. ${legend}, ${zValue}.` + (description ? ` ${description}.` : '')\n      );\n    };\n\n    const _isChartEmpty = (): boolean => {\n      return !(props.data && props.data.length > 0);\n    };\n\n    const _getChartTitle = (): string => {\n      const { chartTitle } = props;\n      const numDataPoints = props.data.reduce((acc, curr) => acc + curr.data.length, 0);\n      return (chartTitle ? `${chartTitle}. ` : '') + `Heat map chart with ${numDataPoints} data points. `;\n    };\n\n    const _getOrderedXAxisLabels = (points: { [key: string]: '1' }) => {\n      if (!_shouldOrderXAxisLabelsByCategoryOrder()) {\n        // Keep the original ordering logic as the default behavior to ensure backward compatibility\n        return Object.keys(points).sort((a: string, b: string) => {\n          if (_xAxisType.current === XAxisTypes.DateAxis || _xAxisType.current === XAxisTypes.NumericAxis) {\n            return +a - +b;\n          } else {\n            return props.sortOrder === 'none' ? 0 : a.toLowerCase() > b.toLowerCase() ? 1 : -1;\n          }\n        });\n      }\n\n      return sortAxisCategories(_mapCategoryToValues(), props.xAxisCategoryOrder);\n    };\n\n    const _getOrderedYAxisLabels = (points: { [key: string]: '1' }) => {\n      if (!_shouldOrderYAxisLabelsByCategoryOrder()) {\n        // Keep the original ordering logic as the default behavior to ensure backward compatibility\n        return Object.keys(points).sort((a: string, b: string) => {\n          if (_yAxisType.current === YAxisType.DateAxis || _yAxisType.current === YAxisType.NumericAxis) {\n            return +a - +b;\n          } else {\n            return props.sortOrder === 'none' ? 0 : a.toLowerCase() > b.toLowerCase() ? 1 : -1;\n          }\n        });\n      }\n\n      return sortAxisCategories(_mapCategoryToValues(true), props.yAxisCategoryOrder);\n    };\n\n    const _getOrderedXPoints = (xPoints: FlattenData[]) => {\n      if (!_shouldOrderXAxisLabelsByCategoryOrder()) {\n        return xPoints.sort((a: HeatMapChartDataPoint, b: HeatMapChartDataPoint) => {\n          if (_xAxisType.current === XAxisTypes.StringAxis) {\n            return props.sortOrder === 'none'\n              ? 0\n              : (a.x as string).toLowerCase() > (b.x as string).toLowerCase()\n              ? 1\n              : -1;\n          } else if (_xAxisType.current === XAxisTypes.DateAxis) {\n            return (a.x as Date).getTime() - (b.x as Date).getTime();\n          } else if (_xAxisType.current === XAxisTypes.NumericAxis) {\n            return +(a.x as string) > +(b.x as string) ? 1 : -1;\n          } else {\n            return a.x > b.x ? 1 : -1;\n          }\n        });\n      }\n\n      const result: FlattenData[] = [];\n\n      const xValueToPoints: Record<string, FlattenData[]> = {};\n      xPoints.forEach(point => {\n        const xValue = point.x as string;\n        if (!xValueToPoints[xValue]) {\n          xValueToPoints[xValue] = [];\n        }\n        xValueToPoints[xValue].push(point);\n      });\n\n      const xAxisLabels = _getOrderedXAxisLabels({});\n      xAxisLabels.forEach(xValue => {\n        if (xValueToPoints[xValue]) {\n          result.push(...xValueToPoints[xValue]);\n        }\n      });\n\n      return result;\n    };\n\n    const _shouldOrderXAxisLabelsByCategoryOrder = () => {\n      return _xAxisType.current === XAxisTypes.StringAxis && props.xAxisCategoryOrder !== 'default';\n    };\n\n    const _shouldOrderYAxisLabelsByCategoryOrder = () => {\n      return _yAxisType.current === YAxisType.StringAxis && props.yAxisCategoryOrder !== 'default';\n    };\n\n    const _mapCategoryToValues = (isYAxis = false) => {\n      const categoryToValues: Record<string, number[]> = {};\n      props.data.forEach(item => {\n        item.data.forEach(point => {\n          const category = (isYAxis ? point.y : point.x) as string;\n          if (!categoryToValues[category]) {\n            categoryToValues[category] = [];\n          }\n          categoryToValues[category].push(point.value);\n        });\n      });\n      return categoryToValues;\n    };\n\n    const updatePosition = (newX: number, newY: number) => {\n      const threshold = 1; // Set a threshold for movement\n      const { x, y } = clickPosition;\n      // Calculate the distance moved\n      const distance = Math.sqrt(Math.pow(newX - x, 2) + Math.pow(newY - y, 2));\n      // Update the position only if the distance moved is greater than the threshold\n      if (distance > threshold) {\n        setClickPosition({ x: newX, y: newY });\n      }\n    };\n\n    const { x, y } = _getXandY();\n    _xAxisType.current = getTypeOfAxis(x, true) as XAxisTypes;\n    _yAxisType.current = getTypeOfAxis(y, false) as YAxisType;\n    const { data, xAxisDateFormatString, xAxisNumberFormatString, yAxisDateFormatString, yAxisNumberFormatString } =\n      props;\n    _colorScale.current = _getColorScale();\n    const { dataSet, xAxisPoints, yAxisPoints } = React.useMemo(\n      () =>\n        _createNewDataSet(\n          data,\n          xAxisDateFormatString,\n          xAxisNumberFormatString,\n          yAxisDateFormatString,\n          yAxisNumberFormatString,\n        ),\n      [\n        _createNewDataSet,\n        data,\n        xAxisDateFormatString,\n        xAxisNumberFormatString,\n        yAxisDateFormatString,\n        yAxisNumberFormatString,\n      ],\n    );\n    _dataSet.current = dataSet;\n    _stringYAxisDataPoints.current = yAxisPoints;\n    _stringXAxisDataPoints.current = xAxisPoints;\n    const calloutProps: ChartPopoverProps = {\n      ...props.calloutProps,\n      isPopoverOpen,\n      YValue: calloutYValue,\n      legend: calloutLegend,\n      color: calloutTextColor,\n      ratio,\n      descriptionMessage,\n      clickPosition,\n      ...getAccessibleDataObject(callOutAccessibilityData, 'text', false),\n      styles: {\n        calloutContentRoot: classes.calloutContentRoot!,\n      },\n    };\n    const tickParams = {\n      tickValues: props.tickValues,\n      tickFormat: props.tickFormat,\n    };\n    return !_isChartEmpty() ? (\n      <CartesianChart\n        {...props}\n        chartTitle={_getChartTitle()}\n        points={data}\n        chartType={ChartTypes.HeatMapChart}\n        xAxisType={XAxisTypes.StringAxis}\n        yAxisType={YAxisType.StringAxis}\n        calloutProps={calloutProps}\n        createYAxis={createNumericYAxis}\n        datasetForXAxisDomain={_stringXAxisDataPoints.current}\n        stringDatasetForYAxisDomain={_stringYAxisDataPoints.current}\n        createStringYAxis={createStringYAxis}\n        getDomainNRangeValues={_getDomainNRangeValues}\n        getMinMaxOfYAxis={_getMinMaxOfYAxis}\n        getmargins={_getMargins}\n        xAxisTickCount={_stringXAxisDataPoints.current.length}\n        xAxistickSize={0}\n        xAxisPadding={0.02}\n        yAxisPadding={0.02}\n        legendBars={_createLegendBars()}\n        onChartMouseLeave={_handleChartMouseLeave}\n        componentRef={cartesianChartRef}\n        tickParams={tickParams}\n        /* eslint-disable react/jsx-no-bind */\n        children={(p: ChildProps) => {\n          _xAxisScale.current = p.xScale;\n          _yAxisScale.current = p.yScalePrimary;\n          return _createRectangles();\n        }}\n      />\n    ) : (\n      <div id={_emptyChartId} role={'alert'} style={{ opacity: '0' }} aria-label={'Graph has no data to display'} />\n    );\n  },\n);\n"],"names":["React","ChartTypes","getAccessibleDataObject","getColorContrast","getTypeOfAxis","resolveCSSVariables","XAxisTypes","YAxisType","createNumericYAxis","domainRangeOfXStringAxis","createStringYAxis","useRtl","sortAxisCategories","formatToLocaleString","CartesianChart","useId","tokens","useHeatMapChartStyles","Legends","scaleLinear","d3ScaleLinear","format","d3Format","timeFormat","d3TimeFormat","toImage","HeatMapChart","forwardRef","props","xAxisCategoryOrder","yAxisCategoryOrder","data","domainValuesForColorScale","rangeValuesForColorScale","forwardedRef","classes","_stringXAxisDataPoints","useRef","_stringYAxisDataPoints","_dataSet","_colorScale","_xAxisScale","_yAxisScale","_xAxisType","_yAxisType","_calloutAnchorPoint","_emptyChartId","_margins","cartesianChartRef","_legendsRef","_isRtl","selectedLegend","setSelectedLegend","useState","activeLegend","setActiveLegend","isPopoverOpen","setPopoverOpen","calloutLegend","setCalloutLegend","calloutTextColor","setCalloutTextColor","calloutYValue","setCalloutYValue","ratio","setRatio","descriptionMessage","setDescriptionMessage","callOutAccessibilityData","setCallOutAccessibilityData","clickPosition","setClickPosition","x","y","useImperativeHandle","componentRef","chartContainer","current","opts","toSVG","_getMinMaxOfYAxis","startValue","endValue","_getDomainNRangeValues","points","margins","width","chartType","isRTL","xAxisType","barWidth","tickValues","shiftX","domainNRangeValue","NumericAxis","DateAxis","dStartValue","dEndValue","rStartValue","rEndValue","_getXandY","forEach","item","length","_getMargins","_getOpacity","legendTitle","opacity","_legendHighlighted","_noLegendHighlighted","_onRectFocus","id","focusEvent","boundingRect","currentTarget","getBoundingClientRect","clientX","left","clientY","top","height","updatePosition","legend","rectText","Number","isNaN","value","colorNeutralForeground1","_onRectMouseOver","mouseEvent","persist","_onRectBlurOrMouseOut","_handleChartMouseLeave","_getInvertedTextColor","color","colorNeutralBackground1","_createRectangles","rectangles","yAxisDataPoints","slice","reverse","yAxisDataPoint","index","xAxisDataPoint","rectElement","dataPointObject","styleRules","foregroundColor","contrastRatio","g","key","role","aria-label","_getAriaLabel","tabIndex","fillOpacity","transform","onFocus","e","onBlur","onMouseOver","onMouseOut","rect","fill","bandwidth","onClick","text","dominantBaseline","textAnchor","className","culture","useUTC","NaN","push","_onLegendHover","_onLegendLeave","_onLegendClick","_createLegendBars","legendProps","legends","title","action","hoverAction","onMouseOutAction","legendRef","_getColorScale","domain","range","_getXIndex","getTime","StringAxis","_getYIndex","xAxisStringFormatter","_getFormattedLabelForXAxisDataPoint","useCallback","point","yAxisStringFormatter","_getFormattedLabelForYAxisDataPoint","_getXAxisDataPoints","xAxisPoints","unFormattedXAxisDataPoints","_getOrderedXAxisLabels","map","xPoint","_getStringFormattedDate","xAxisDateFormatString","_getStringFormattedNumber","xAxisNumberFormatString","sortOrder","_getYAxisDataPoints","yAxisPoints","unFormattedYAxisDataPoints","_getOrderedYAxisLabels","yPoint","yAxisDateFormatString","yAxisNumberFormatString","_createNewDataSet","flattenData","yPoints","uniqueYPoints","uniqueXPoints","posX","posY","Object","keys","_getOrderedXPoints","datapoint","dataSet","formatString","date","Date","setTime","xValue","yValue","zValue","description","ariaLabel","_isChartEmpty","_getChartTitle","chartTitle","numDataPoints","reduce","acc","curr","_shouldOrderXAxisLabelsByCategoryOrder","sort","a","b","toLowerCase","_mapCategoryToValues","_shouldOrderYAxisLabelsByCategoryOrder","xPoints","result","xValueToPoints","xAxisLabels","isYAxis","categoryToValues","category","newX","newY","threshold","distance","Math","sqrt","pow","useMemo","calloutProps","YValue","styles","calloutContentRoot","tickParams","tickFormat","yAxisType","createYAxis","datasetForXAxisDomain","stringDatasetForYAxisDomain","getDomainNRangeValues","getMinMaxOfYAxis","getmargins","xAxisTickCount","xAxistickSize","xAxisPadding","yAxisPadding","legendBars","onChartMouseLeave","children","p","xScale","yScalePrimary","div","style"],"mappings":"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"}