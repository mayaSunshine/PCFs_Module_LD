{"version":3,"sources":["../src/components/LineChart/LineChart.tsx"],"sourcesContent":["'use client';\n\nimport * as React from 'react';\nimport { LineChartProps } from './LineChart.types';\nimport { useLineChartStyles } from './useLineChartStyles.styles';\nimport { Axis as D3Axis } from 'd3-axis';\nimport { select as d3Select, pointer } from 'd3-selection';\nimport { bisector } from 'd3-array';\nimport { Legend, Legends, LegendContainer } from '../Legends/index';\nimport { line as d3Line } from 'd3-shape';\nimport { max as d3Max } from 'd3-array';\nimport { useId } from '@fluentui/react-utilities';\nimport type { JSXElement } from '@fluentui/react-utilities';\nimport { find, findCalloutPoints, YAxisType } from '../../utilities/index';\nimport {\n  AccessibilityProps,\n  CartesianChart,\n  ChildProps,\n  LineChartPoints,\n  CustomizedCalloutData,\n  CustomizedCalloutDataPoint,\n  Margins,\n  RefArrayData,\n  ColorFillBarsProps,\n  LineChartGap,\n  LineChartDataPoint,\n  Chart,\n  ImageExportOptions,\n  YValueHover,\n} from '../../index';\nimport { EventsAnnotation } from './eventAnnotation/EventAnnotation';\nimport { tokens } from '@fluentui/react-theme';\nimport {\n  calloutData,\n  ChartTypes,\n  getXAxisType,\n  XAxisTypes,\n  tooltipOfAxislabels,\n  Points,\n  pointTypes,\n  getTypeOfAxis,\n  getNextColor,\n  getColorFromToken,\n  findNumericMinMaxOfY,\n  createNumericYAxis,\n  IDomainNRange,\n  domainRangeOfDateForAreaLineScatterVerticalBarCharts,\n  domainRangeOfNumericForAreaLineScatterCharts,\n  createStringYAxis,\n  useRtl,\n  getCurveFactory,\n  isScatterPolarSeries,\n  getDomainPaddingForMarkers,\n  isPlottable,\n  getRangeForScatterMarkerSize,\n} from '../../utilities/index';\nimport { ScaleLinear } from 'd3-scale';\nimport { toImage } from '../../utilities/image-export-utils';\nimport { renderScatterPolarCategoryLabels } from '../../utilities/scatterpolar-utils';\nimport { formatDateToLocaleString } from '@fluentui/chart-utilities';\n\ntype NumericAxis = D3Axis<number | { valueOf(): number }>;\nenum PointSize {\n  hoverSize = 11,\n  invisibleSize = 1,\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nconst bisect = bisector((d: any) => d.x).left;\n\nconst DEFAULT_LINE_STROKE_SIZE = 4;\n// The given shape of a icon must be 2.5 times bigger than line width (known as stroke width)\nconst PATH_MULTIPLY_SIZE = 2.5;\n\n/**\n *\n * @param x units from origin\n * @param y units from origin\n * @param w is the legnth of the each side of a shape\n * @param index index to get the shape path\n */\nconst _getPointPath = (x: number, y: number, w: number, index: number): string => {\n  const allPointPaths = [\n    // circle path\n    `M${x - w / 2} ${y}\n     A${w / 2} ${w / 2} 0 1 0 ${x + w / 2} ${y}\n     M${x - w / 2} ${y}\n     A ${w / 2} ${w / 2} 0 1 1 ${x + w / 2} ${y}\n     `,\n    //square\n    `M${x - w / 2} ${y - w / 2}\n     L${x + w / 2} ${y - w / 2}\n     L${x + w / 2} ${y + w / 2}\n     L${x - w / 2} ${y + w / 2}\n     Z`,\n    //triangle\n    `M${x - w / 2} ${y - 0.2886 * w}\n     H ${x + w / 2}\n     L${x} ${y + 0.5774 * w} Z`,\n    //diamond\n    `M${x} ${y - w / 2}\n     L${x + w / 2} ${y}\n     L${x} ${y + w / 2}\n     L${x - w / 2} ${y}\n     Z`,\n    //pyramid\n    `M${x} ${y - 0.5774 * w}\n     L${x + w / 2} ${y + 0.2886 * w}\n     L${x - w / 2} ${y + 0.2886 * w} Z`,\n    //hexagon\n    `M${x - 0.5 * w} ${y - 0.866 * w}\n     L${x + 0.5 * w} ${y - 0.866 * w}\n     L${x + w} ${y}\n     L${x + 0.5 * w} ${y + 0.866 * w}\n     L${x - 0.5 * w} ${y + 0.866 * w}\n     L${x - w} ${y}\n     Z`,\n    //pentagon\n    `M${x} ${y - 0.851 * w}\n     L${x + 0.6884 * w} ${y - 0.2633 * w}\n     L${x + 0.5001 * w} ${y + 0.6884 * w}\n     L${x - 0.5001 * w} ${y + 0.6884 * w}\n     L${x - 0.6884 * w} ${y - 0.2633 * w}\n     Z`,\n    //octagon\n    `M${x - 0.5001 * w} ${y - 1.207 * w}\n     L${x + 0.5001 * w} ${y - 1.207 * w}\n     L${x + 1.207 * w} ${y - 0.5001 * w}\n     L${x + 1.207 * w} ${y + 0.5001 * w}\n     L${x + 0.5001 * w} ${y + 1.207 * w}\n     L${x - 0.5001 * w} ${y + 1.207 * w}\n     L${x - 1.207 * w} ${y + 0.5001 * w}\n     L${x - 1.207 * w} ${y - 0.5001 * w}\n     Z`,\n  ];\n  return allPointPaths[index];\n};\n\ntype LineChartDataWithIndex = LineChartPoints & { index: number };\n\n// Create a LineChart variant which uses these default styles and this styled subcomponent.\n/**\n * Linechart component\n * {@docCategory LineChart}\n */\nexport const LineChart: React.FunctionComponent<LineChartProps> = React.forwardRef<HTMLDivElement, LineChartProps>(\n  (props, forwardedRef) => {\n    let _hasMarkersMode: boolean = false;\n    let _isXAxisDateType: boolean = false;\n    let _isScatterPolar: boolean = false;\n    let _points: LineChartDataWithIndex[] = _injectIndexPropertyInLineChartData(props.data.lineChartData);\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let _xAxisScale: any = '';\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let _yScalePrimary: any = '';\n    let _circleId: string = useId('circle');\n    let _lineId: string = useId('lineID');\n    let _borderId: string = useId('borderID');\n    let _verticalLine: string = useId('verticalLine');\n    let _colorFillBarPatternId: string = useId('colorFillBarPattern');\n    let _uniqueCallOutID: string | null = '';\n    let _refArray: RefArrayData[] = [];\n    let margins: Margins;\n    let eventLabelHeight: number = 36;\n    let lines: JSXElement[];\n    let _renderedColorFillBars: JSXElement[];\n    const _colorFillBars = React.useRef<ColorFillBarsProps[]>([]);\n    let _tooltipId: string = useId('LineChartTooltipId_');\n    let _rectId: string = useId('containerRectLD');\n    let _staticHighlightCircle: string = useId('staticHighlightCircle');\n    let _firstRenderOptimization = true;\n    let _emptyChartId: string = useId('_LineChart_empty');\n    const _colorFillBarId = useId('_colorFillBarId');\n    const _isRTL: boolean = useRtl();\n    let xAxisCalloutAccessibilityData: AccessibilityProps = {};\n    const cartesianChartRef = React.useRef<Chart>(null);\n    let _yScaleSecondary: ScaleLinear<number, number> | undefined;\n    const _legendsRef = React.useRef<LegendContainer>(null);\n\n    props.eventAnnotationProps &&\n      props.eventAnnotationProps.labelHeight &&\n      (eventLabelHeight = props.eventAnnotationProps.labelHeight);\n\n    const [hoverXValue, setHoverXValue] = React.useState<string | number>('');\n    const [activeLegend, setActiveLegend] = React.useState<string>('');\n    const [yValueHover, setYValueHover] = React.useState<YValueHover[]>([]);\n    const [selectedLegend, setSelectedLegend] = React.useState<string>('');\n    const [selectedLegendPoints, setSelectedLegendPoints] = React.useState<any[]>(\n      _injectIndexPropertyInLineChartData(props.data.lineChartData, true),\n    );\n    const [selectedColorBarLegend, setSelectedColorBarLegend] = React.useState<any[]>([]);\n    const [isSelectedLegend, setIsSelectedLegend] = React.useState<boolean>(\n      (props.legendProps?.selectedLegends?.length ?? 0) > 0,\n    );\n    const [activePoint, setActivePoint] = React.useState<string>('');\n    const [nearestCircleToHighlight, setNearestCircleToHighlight] = React.useState<LineChartDataPoint | null>(null);\n    const [dataPointCalloutProps, setDataPointCalloutProps] = React.useState<CustomizedCalloutData>();\n    const [stackCalloutProps, setStackCalloutProps] = React.useState<CustomizedCalloutData>();\n    const [clickPosition, setClickPosition] = React.useState({ x: 0, y: 0 });\n    const [isPopoverOpen, setPopoverOpen] = React.useState(false);\n    const [YValue, setYValue] = React.useState<number | string>('');\n    const [legendVal, setLegendVal] = React.useState<string>('');\n    const [lineColor, setLineColor] = React.useState<string>('');\n    const [refSelected, setRefSelected] = React.useState<HTMLElement | null>(null);\n\n    const pointsRef = React.useRef<LineChartDataWithIndex[] | []>([]);\n    const calloutPointsRef = React.useRef<Record<string, YValueHover[]>>({});\n    const classes = useLineChartStyles(props);\n    React.useEffect(() => {\n      /** note that height and width are not used to resize or set as dimesions of the chart,\n       * fitParentContainer is responisble for setting the height and width or resizing of the svg/chart\n       */\n\n      if (_points !== _injectIndexPropertyInLineChartData(props.data.lineChartData) || props.data !== _points) {\n        pointsRef.current = _injectIndexPropertyInLineChartData(props.data.lineChartData);\n        calloutPointsRef.current = calloutData(pointsRef.current);\n      }\n    }, [props.height, props.width, props.data]);\n\n    React.useImperativeHandle(\n      props.componentRef,\n      () => ({\n        chartContainer: cartesianChartRef.current?.chartContainer ?? null,\n        toImage: (opts?: ImageExportOptions): Promise<string> => {\n          return toImage(cartesianChartRef.current?.chartContainer, _legendsRef.current?.toSVG, _isRTL, opts);\n        },\n      }),\n      [],\n    );\n\n    function _getDomainNRangeValues(\n      points: LineChartPoints[],\n      margins: Margins,\n      width: number,\n      chartType: ChartTypes,\n      isRTL: boolean,\n      xAxisType: XAxisTypes,\n      barWidth: number,\n      tickValues: Date[] | number[] | undefined,\n      shiftX: number,\n    ) {\n      let domainNRangeValue: IDomainNRange;\n      if (xAxisType === XAxisTypes.NumericAxis) {\n        domainNRangeValue = domainRangeOfNumericForAreaLineScatterCharts(\n          points,\n          margins,\n          width,\n          isRTL,\n          props.xScaleType,\n          _hasMarkersMode,\n        );\n      } else if (xAxisType === XAxisTypes.DateAxis) {\n        domainNRangeValue = domainRangeOfDateForAreaLineScatterVerticalBarCharts(\n          points,\n          margins,\n          width,\n          isRTL,\n          tickValues! as Date[],\n          chartType,\n          barWidth,\n          _hasMarkersMode,\n        );\n      } else {\n        domainNRangeValue = { dStartValue: 0, dEndValue: 0, rStartValue: 0, rEndValue: 0 };\n      }\n      return domainNRangeValue;\n    }\n\n    function _injectIndexPropertyInLineChartData(\n      lineChartData?: LineChartPoints[],\n      isFilterSelectedLegends: boolean = false,\n    ): LineChartDataWithIndex[] | [] {\n      const { allowMultipleShapesForPoints = false } = props;\n      // Apply filter only if isPropChange is true\n      const filteredData = isFilterSelectedLegends\n        ? lineChartData?.filter(\n            (item: LineChartPoints) =>\n              props.legendProps?.selectedLegends?.includes(item.legend) ||\n              props.legendProps?.selectedLegend === item.legend,\n          )\n        : lineChartData;\n      _hasMarkersMode =\n        filteredData?.some((item: LineChartPoints) => item.lineOptions?.mode?.includes?.('markers')) ?? false;\n      _isScatterPolar = isScatterPolarSeries(filteredData!);\n      return filteredData\n        ? filteredData.map((item: LineChartPoints, index: number) => {\n            let color: string;\n            if (typeof item.color === 'undefined') {\n              color = getNextColor(index, 0);\n            } else {\n              color = getColorFromToken(item.color);\n            }\n            return {\n              ...item,\n              index: allowMultipleShapesForPoints ? index : -1,\n              color,\n            };\n          })\n        : [];\n    }\n\n    function updatePosition(newX: number, newY: number) {\n      const threshold = 1; // Set a threshold for movement\n      const { x, y } = clickPosition;\n      // Calculate the distance moved\n      const distance = Math.sqrt(Math.pow(newX - x, 2) + Math.pow(newY - y, 2));\n      // Update the position only if the distance moved is greater than the threshold\n      if (distance > threshold) {\n        setClickPosition({ x: newX, y: newY });\n        setPopoverOpen(true);\n      }\n    }\n\n    function _getCustomizedCallout() {\n      return props.onRenderCalloutPerStack\n        ? props.onRenderCalloutPerStack(stackCalloutProps)\n        : props.onRenderCalloutPerDataPoint\n        ? props.onRenderCalloutPerDataPoint(dataPointCalloutProps)\n        : null;\n    }\n\n    function _getNumericMinMaxOfY(\n      points: LineChartPoints[],\n      yAxisType?: YAxisType,\n      useSecondaryYScale?: boolean,\n    ): { startValue: number; endValue: number } {\n      // eslint-disable-next-line @typescript-eslint/no-shadow\n      const { startValue, endValue } = findNumericMinMaxOfY(\n        points,\n        yAxisType,\n        useSecondaryYScale,\n        useSecondaryYScale ? props.secondaryYScaleType : props.yScaleType,\n      );\n      let yPadding = { start: 0, end: 0 };\n      if (_hasMarkersMode) {\n        yPadding = getDomainPaddingForMarkers(\n          startValue,\n          endValue,\n          useSecondaryYScale ? props.secondaryYScaleType : props.yScaleType,\n        );\n      }\n      return {\n        startValue: startValue - yPadding.start,\n        endValue: endValue + yPadding.end,\n      };\n    }\n\n    function _getMargins(_margins: Margins) {\n      margins = _margins;\n    }\n\n    function _initializeLineChartData(\n      xScale: NumericAxis,\n      yScalePrimary: NumericAxis,\n      containerHeight: number,\n      containerWidth: number,\n      xElement: SVGElement | null,\n      yAxisElement?: SVGElement | null,\n      yScaleSecondary?: ScaleLinear<number, number>,\n    ) {\n      _xAxisScale = xScale;\n      _yScalePrimary = yScalePrimary;\n      _yScaleSecondary = yScaleSecondary;\n      _renderedColorFillBars = props.colorFillBars ? _createColorFillBars(containerHeight) : [];\n      lines = _createLines(xElement!, containerHeight!);\n    }\n\n    function _handleSingleLegendSelectionAction(lineChartItem: LineChartDataWithIndex | ColorFillBarsProps) {\n      if (selectedLegend === lineChartItem.legend) {\n        setSelectedLegend('');\n        _handleLegendClick(lineChartItem, null);\n      } else {\n        setSelectedLegend(lineChartItem.legend);\n        _handleLegendClick(lineChartItem, lineChartItem.legend);\n      }\n    }\n\n    function _onHoverCardHide() {\n      setSelectedLegendPoints([]);\n      setSelectedColorBarLegend([]);\n      setIsSelectedLegend(false);\n    }\n\n    function _handleLegendClick(\n      lineChartItem: LineChartDataWithIndex | ColorFillBarsProps,\n      selectedLegend: string | null | string[],\n    ): void {\n      if (lineChartItem.onLegendClick) {\n        lineChartItem.onLegendClick(selectedLegend);\n      }\n    }\n\n    function _createLegends(data: LineChartDataWithIndex[]): JSXElement {\n      const { legendProps, allowMultipleShapesForPoints = false } = props;\n      const isLegendMultiSelectEnabled = !!(legendProps && !!legendProps.canSelectMultipleLegends);\n      const mapLegendToPoints: Record<string, LineChartDataWithIndex[]> = {};\n      data.forEach((point: LineChartDataWithIndex) => {\n        if (point.legend) {\n          if (!mapLegendToPoints[point.legend]) {\n            mapLegendToPoints[point.legend] = [];\n          }\n          mapLegendToPoints[point.legend].push(point);\n        }\n      });\n      const legendDataItems: Legend[] = Object.entries(mapLegendToPoints).map(([legendTitle, points]) => {\n        const representativePoint = points[0];\n        // mapping data to the format Legends component needs\n        const legend: Legend = {\n          title: legendTitle,\n          color: representativePoint.color!,\n          action: () => {\n            if (isLegendMultiSelectEnabled) {\n              points.forEach(p => _handleMultipleLineLegendSelectionAction(p));\n            } else {\n              points.forEach(p => _handleSingleLegendSelectionAction(p));\n            }\n          },\n          onMouseOutAction: () => {\n            setActiveLegend('');\n          },\n          hoverAction: () => {\n            _handleChartMouseLeave();\n            setActiveLegend(legendTitle);\n          },\n          ...(representativePoint.legendShape && {\n            shape: representativePoint.legendShape,\n          }),\n          ...(allowMultipleShapesForPoints && {\n            shape: Points[representativePoint.index % Object.keys(pointTypes).length] as Legend['shape'],\n          }),\n        };\n        return legend;\n      });\n\n      const colorFillBarsLegendDataItems = props.colorFillBars\n        ? props.colorFillBars.map((colorFillBar: ColorFillBarsProps, index: number) => {\n            const title = colorFillBar.legend;\n            const color = getColorFromToken(colorFillBar.color);\n            const legend: Legend = {\n              title,\n              color,\n              action: () => {\n                if (isLegendMultiSelectEnabled) {\n                  _handleMultipleColorFillBarLegendSelectionAction(colorFillBar);\n                } else {\n                  _handleSingleLegendSelectionAction(colorFillBar);\n                }\n              },\n              onMouseOutAction: () => {\n                setActiveLegend('');\n              },\n              hoverAction: () => {\n                _handleChartMouseLeave();\n                setActiveLegend(title);\n              },\n              opacity: _getColorFillBarOpacity(colorFillBar),\n              stripePattern: colorFillBar.applyPattern,\n            };\n            return legend;\n          })\n        : [];\n\n      return (\n        <Legends\n          legends={[...legendDataItems, ...colorFillBarsLegendDataItems]}\n          enabledWrapLines={props.enabledLegendsWrapLines}\n          overflowText={props.legendsOverflowText}\n          {...(isLegendMultiSelectEnabled && { onLegendHoverCardLeave: _onHoverCardHide })}\n          {...props.legendProps}\n          legendRef={_legendsRef}\n        />\n      );\n    }\n\n    function _getBoxWidthOfShape(pointId: string, pointIndex: number, isLastPoint: boolean) {\n      const { allowMultipleShapesForPoints = false, strokeWidth = DEFAULT_LINE_STROKE_SIZE } = props;\n      if (allowMultipleShapesForPoints) {\n        if (activePoint === pointId) {\n          return PointSize.hoverSize;\n        } else if (pointIndex === 1 || isLastPoint) {\n          return strokeWidth * PATH_MULTIPLY_SIZE;\n        } else {\n          return PointSize.invisibleSize;\n        }\n      } else {\n        if (activePoint === pointId) {\n          return PointSize.hoverSize;\n        } else {\n          return PointSize.invisibleSize;\n        }\n      }\n    }\n\n    function _getPath(\n      xPos: number,\n      yPos: number,\n      pointId: string,\n      pointIndex: number,\n      isLastPoint: boolean,\n      pointOftheLine: number,\n    ): string {\n      const { allowMultipleShapesForPoints = false } = props;\n      let w = _getBoxWidthOfShape(pointId, pointIndex, isLastPoint);\n      const index: number = allowMultipleShapesForPoints ? pointOftheLine % Object.keys(pointTypes).length : 0;\n      const widthRatio = pointTypes[index].widthRatio;\n      w = widthRatio > 1 ? w / widthRatio : w;\n\n      return _getPointPath(xPos, yPos, w, index);\n    }\n    function _getPointFill(lineColor: string, pointId: string, pointIndex: number, isLastPoint: boolean) {\n      const { allowMultipleShapesForPoints = false } = props;\n      if (allowMultipleShapesForPoints) {\n        if (pointIndex === 1 || isLastPoint) {\n          if (activePoint === pointId) {\n            return tokens.colorNeutralBackground1;\n          } else {\n            return lineColor;\n          }\n        } else {\n          if (activePoint === pointId) {\n            return tokens.colorNeutralBackground1;\n          } else {\n            return lineColor;\n          }\n        }\n      } else {\n        if (activePoint === pointId) {\n          return tokens.colorNeutralBackground1;\n        } else {\n          return lineColor;\n        }\n      }\n    }\n\n    function _createLines(xElement: SVGElement, containerHeight: number): JSXElement[] {\n      const lines: JSXElement[] = [];\n      if (isSelectedLegend) {\n        _points = selectedLegendPoints;\n      } else {\n        _points = _injectIndexPropertyInLineChartData(props.data.lineChartData);\n      }\n      const maxMarkerSize = d3Max(_points, (point: LineChartPoints) => {\n        return d3Max(point.data, (item: LineChartDataPoint) => {\n          return item.markerSize as number;\n        });\n      })!;\n      for (let i = _points.length - 1; i >= 0; i--) {\n        const linesForLine: JSXElement[] = [];\n        const bordersForLine: JSXElement[] = [];\n        const pointsForLine: JSXElement[] = [];\n\n        const legendVal: string = _points[i].legend;\n        const lineColor: string = _points[i].color!;\n        const verticaLineHeight = containerHeight - margins.bottom! + 6;\n        const useSecondaryYScale = !!(_points[i].useSecondaryYScale && _yScaleSecondary);\n        const yScale = useSecondaryYScale ? _yScaleSecondary : _yScalePrimary;\n        const extraMaxPixels = _hasMarkersMode\n          ? getRangeForScatterMarkerSize({\n              data: _points,\n              xScale: _xAxisScale,\n              yScalePrimary: _yScalePrimary,\n              yScaleSecondary: _yScaleSecondary,\n              useSecondaryYScale,\n              xScaleType: props.xScaleType,\n              yScaleType: props.yScaleType,\n              secondaryYScaleType: props.secondaryYScaleType,\n            })\n          : 0;\n        if (_points[i].data.length === 1) {\n          // eslint-disable-next-line @typescript-eslint/no-shadow\n          const {\n            x: x1,\n            y: y1,\n            xAxisCalloutData,\n            xAxisCalloutAccessibilityData,\n          } = _points[i].data[0] as LineChartDataPoint;\n          const xPoint = _xAxisScale(x1);\n          const yPoint = yScale(y1);\n          if (isPlottable(xPoint, yPoint)) {\n            const circleId = `${_circleId}_${i}`;\n            const isLegendSelected: boolean =\n              _legendHighlighted(legendVal) || _noLegendHighlighted() || isSelectedLegend;\n            const currentMarkerSize = _points[i].data[0].markerSize!;\n            const supportsTextMode = _points[i].lineOptions?.mode?.includes('text');\n            const text = _points[i].data[0].text;\n            const targetElement = document.getElementById(circleId);\n            pointsForLine.push(\n              <>\n                <React.Fragment key={`${circleId}_fragment`}>\n                  <circle\n                    id={circleId}\n                    key={circleId}\n                    r={\n                      currentMarkerSize\n                        ? (currentMarkerSize! * extraMaxPixels) / maxMarkerSize\n                        : activePoint === circleId\n                        ? 5.5\n                        : 3.5\n                    }\n                    cx={xPoint}\n                    cy={yPoint}\n                    fill={activePoint === circleId ? tokens.colorNeutralBackground1 : lineColor}\n                    opacity={isLegendSelected ? 1 : 0.1}\n                    tabIndex={isLegendSelected ? 0 : undefined}\n                    onMouseOver={(event: React.MouseEvent<SVGElement>) =>\n                      _handleHover(\n                        x1,\n                        y1,\n                        verticaLineHeight,\n                        xAxisCalloutData,\n                        circleId,\n                        xAxisCalloutAccessibilityData,\n                        event,\n                        yScale,\n                        legendVal,\n                        lineColor,\n                        targetElement,\n                      )\n                    }\n                    onMouseMove={(event: React.MouseEvent<SVGElement>) =>\n                      _handleHover(\n                        x1,\n                        y1,\n                        verticaLineHeight,\n                        xAxisCalloutData,\n                        circleId,\n                        xAxisCalloutAccessibilityData,\n                        event,\n                        yScale,\n                        legendVal,\n                        lineColor,\n                        targetElement,\n                      )\n                    }\n                    onMouseOut={_handleMouseOut}\n                    strokeWidth={activePoint === circleId ? DEFAULT_LINE_STROKE_SIZE : 0}\n                    stroke={activePoint === circleId ? lineColor : ''}\n                    role=\"img\"\n                    aria-label={_points[i].data[0].text ?? _getAriaLabel(i, 0)}\n                    data-is-focusable={isLegendSelected}\n                    ref={(e: SVGCircleElement | null) => {\n                      _refCallback(e!, circleId);\n                    }}\n                    onFocus={event =>\n                      _handleFocus(\n                        event,\n                        circleId,\n                        x1,\n                        xAxisCalloutData,\n                        circleId,\n                        targetElement,\n                        xAxisCalloutAccessibilityData,\n                      )\n                    }\n                    onBlur={_handleMouseOut}\n                    {..._getClickHandler(_points[i].data[0].onDataPointClick)}\n                  />\n                  {!_isScatterPolar && supportsTextMode && text && (\n                    <text\n                      key={`${circleId}-label`}\n                      x={xPoint}\n                      y={\n                        yPoint +\n                        Math.max(currentMarkerSize ? (currentMarkerSize * extraMaxPixels) / maxMarkerSize : 3.5, 4) +\n                        12\n                      }\n                      className={classes.markerLabel}\n                      opacity={isLegendSelected ? 1 : 0.1}\n                    >\n                      {text}\n                    </text>\n                  )}\n                </React.Fragment>\n              </>,\n            );\n          }\n        }\n\n        let gapIndex = 0;\n        const gaps = _points[i].gaps?.sort((a, b) => a.startIndex - b.startIndex) ?? [];\n        const lineCurve = _points[i].lineOptions?.curve;\n\n        // Use path rendering technique for larger datasets to optimize performance.\n        if ((props.optimizeLargeData || lineCurve) && _points[i].data.length > 1) {\n          const line = d3Line()\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            .x((d: any) => _xAxisScale(d[0]))\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            .y((d: any) => yScale(d[1]))\n            .curve(getCurveFactory(lineCurve))\n            .defined(d => isPlottable(_xAxisScale(d[0]), yScale(d[1])));\n\n          const lineId = `${_lineId}_${i}`;\n          const borderId = `${_borderId}_${i}`;\n          const strokeWidth = _points[i].lineOptions?.strokeWidth || props.strokeWidth || DEFAULT_LINE_STROKE_SIZE;\n\n          const isLegendSelected: boolean = _legendHighlighted(legendVal) || _noLegendHighlighted() || isSelectedLegend;\n\n          const lineData: [number, number][] = [];\n          for (let k = 0; k < _points[i].data.length; k++) {\n            lineData.push([\n              _points[i].data[k].x instanceof Date\n                ? (_points[i].data[k].x as Date).getTime()\n                : (_points[i].data[k].x as number),\n              _points[i].data[k].y,\n            ]);\n          }\n\n          // Check if lines should be drawn based on mode\n          const lineMode = _points[i].lineOptions?.mode;\n          const shouldDrawLines = lineMode !== 'markers';\n          if (shouldDrawLines && isLegendSelected) {\n            const lineBorderWidth = _points[i].lineOptions?.lineBorderWidth\n              ? Number.parseFloat(_points[i].lineOptions!.lineBorderWidth!.toString())\n              : 0;\n            if (lineBorderWidth > 0) {\n              bordersForLine.push(\n                <path\n                  id={borderId}\n                  key={borderId}\n                  d={line(lineData)!}\n                  fill=\"transparent\"\n                  strokeLinecap={_points[i].lineOptions?.strokeLinecap ?? 'round'}\n                  strokeWidth={Number.parseFloat(strokeWidth.toString()) + lineBorderWidth}\n                  stroke={_points[i].lineOptions?.lineBorderColor || tokens.colorNeutralBackground1}\n                  opacity={1}\n                />,\n              );\n            }\n\n            linesForLine.push(\n              <path\n                id={lineId}\n                key={lineId}\n                d={line(lineData)!}\n                fill=\"transparent\"\n                data-is-focusable={true}\n                stroke={lineColor}\n                strokeWidth={strokeWidth}\n                strokeLinecap={_points[i].lineOptions?.strokeLinecap ?? 'round'}\n                strokeDasharray={_points[i].lineOptions?.strokeDasharray}\n                onMouseMove={event => _onMouseOverLargeDataset(i, verticaLineHeight, event, yScale)}\n                onMouseOver={event => _onMouseOverLargeDataset(i, verticaLineHeight, event, yScale)}\n                onMouseOut={_handleMouseOut}\n                {..._getClickHandler(_points[i].onLineClick)}\n                opacity={1}\n                tabIndex={isLegendSelected ? 0 : undefined}\n              />,\n            );\n          } else if (shouldDrawLines) {\n            linesForLine.push(\n              <path\n                id={lineId}\n                key={lineId}\n                d={line(lineData)!}\n                fill=\"transparent\"\n                data-is-focusable={false}\n                stroke={lineColor}\n                strokeWidth={strokeWidth}\n                strokeLinecap={_points[i].lineOptions?.strokeLinecap ?? 'round'}\n                strokeDasharray={_points[i].lineOptions?.strokeDasharray}\n                opacity={0.1}\n              />,\n            );\n          }\n\n          // Always add the highlight circle for large dataset hover\n          pointsForLine.push(\n            <circle\n              id={`${_staticHighlightCircle}_${i}`}\n              key={`${_staticHighlightCircle}_${i}`}\n              r={5.5}\n              cx={0}\n              cy={0}\n              fill={tokens.colorNeutralBackground1}\n              strokeWidth={DEFAULT_LINE_STROKE_SIZE}\n              stroke={lineColor}\n              visibility={'hidden'}\n              onMouseMove={event => _onMouseOverLargeDataset(i, verticaLineHeight, event, yScale)}\n              onMouseOver={event => _onMouseOverLargeDataset(i, verticaLineHeight, event, yScale)}\n              onMouseOut={_handleMouseOut}\n            />,\n          );\n\n          // Add individual markers if mode includes 'markers'\n          const showMarkers = !!lineMode?.includes('markers');\n          if (showMarkers) {\n            for (let k = 0; k < _points[i].data.length; k++) {\n              const { x, y } = _points[i].data[k];\n              const xPoint = _xAxisScale(x instanceof Date ? x.getTime() : x);\n              const yPoint = yScale(y);\n\n              if (isPlottable(xPoint, yPoint)) {\n                const markerSize = _points[i].data[k].markerSize;\n                const perPointColor = _points[i].data[k]?.markerColor;\n                pointsForLine.push(\n                  <circle\n                    key={`${_circleId}_${i}_${k}_marker`}\n                    r={\n                      markerSize\n                        ? (markerSize! * extraMaxPixels * 0.3) / maxMarkerSize\n                        : activePoint === _circleId\n                        ? 5.5\n                        : 3.5\n                    }\n                    cx={xPoint}\n                    cy={yPoint}\n                    fill={\n                      activePoint === _circleId\n                        ? tokens.colorNeutralBackground1\n                        : perPointColor || _points[i]?.color || lineColor\n                    }\n                    stroke={perPointColor || lineColor}\n                    strokeWidth={1}\n                    opacity={isLegendSelected ? 1 : 0.1}\n                    onMouseMove={_onMouseOverLargeDataset.bind(i, verticaLineHeight, yScale)}\n                    onMouseOver={_onMouseOverLargeDataset.bind(i, verticaLineHeight, yScale)}\n                    onMouseOut={_handleMouseOut}\n                  />,\n                );\n              }\n            }\n          }\n        } else if (!props.optimizeLargeData) {\n          for (let j = 1; j < _points[i].data.length; j++) {\n            const gapResult = _checkInGap(j, gaps, gapIndex);\n            const isInGap = gapResult.isInGap;\n            gapIndex = gapResult.gapIndex;\n\n            const lineId = `${_lineId}_${i}_${j}`;\n            const borderId = `${_borderId}_${i}_${j}`;\n            const circleId = `${_circleId}_${i}_${j}`;\n            const {\n              x: x1,\n              y: y1,\n              xAxisCalloutData,\n              xAxisCalloutAccessibilityData,\n            } = _points[i].data[j - 1] as LineChartDataPoint;\n            const { x: x2, y: y2 } = _points[i].data[j] as LineChartDataPoint;\n            const xPoint1 = _xAxisScale(x1);\n            const yPoint1 = yScale(y1);\n            const xPoint2 = _xAxisScale(x2);\n            const yPoint2 = yScale(y2);\n            const strokeWidth = _points[i].lineOptions?.strokeWidth || props.strokeWidth || DEFAULT_LINE_STROKE_SIZE;\n\n            const isLegendSelected: boolean =\n              _legendHighlighted(legendVal) || _noLegendHighlighted() || isSelectedLegend;\n\n            const currentPointHidden = _points[i].hideNonActiveDots && activePoint !== circleId;\n            const supportsTextMode = _points[i].lineOptions?.mode?.includes('text');\n            const text = _points[i].data[j - 1].text;\n            let currentMarkerSize = _points[i].data[j - 1].markerSize!;\n            if (isPlottable(xPoint1, yPoint1)) {\n              const path = _getPath(xPoint1, yPoint1, circleId, j, false, _points[i].index);\n              const targetElement = document.getElementById(circleId);\n              pointsForLine.push(\n                _points[i].lineOptions?.mode?.includes('markers') || supportsTextMode ? (\n                  <>\n                    <circle\n                      id={circleId}\n                      key={circleId}\n                      r={currentMarkerSize ? (currentMarkerSize! * extraMaxPixels) / maxMarkerSize : 4}\n                      cx={xPoint1}\n                      cy={yPoint1}\n                      data-is-focusable={isLegendSelected}\n                      onMouseOver={event =>\n                        _handleHover(\n                          x1,\n                          y1,\n                          verticaLineHeight,\n                          xAxisCalloutData,\n                          circleId,\n                          xAxisCalloutAccessibilityData,\n                          event,\n                          yScale,\n                          legendVal,\n                          lineColor,\n                          targetElement,\n                        )\n                      }\n                      onMouseMove={event =>\n                        _handleHover(\n                          x1,\n                          y1,\n                          verticaLineHeight,\n                          xAxisCalloutData,\n                          circleId,\n                          xAxisCalloutAccessibilityData,\n                          event,\n                          yScale,\n                          legendVal,\n                          lineColor,\n                          targetElement,\n                        )\n                      }\n                      onMouseOut={_handleMouseOut}\n                      onFocus={event =>\n                        _handleFocus(\n                          event,\n                          lineId,\n                          x1,\n                          xAxisCalloutData,\n                          circleId,\n                          targetElement,\n                          xAxisCalloutAccessibilityData,\n                        )\n                      }\n                      onBlur={_handleMouseOut}\n                      {..._getClickHandler(_points[i].data[j - 1].onDataPointClick)}\n                      opacity={isLegendSelected && !currentPointHidden ? 1 : 0.01}\n                      fill={_points[i].data[j - 1]?.markerColor || _getPointFill(lineColor, circleId, j, false)}\n                      stroke={_points[i].data[j - 1]?.markerColor || lineColor}\n                      strokeWidth={strokeWidth}\n                      role=\"img\"\n                      aria-label={_points[i].data[j - 1].text ?? _getAriaLabel(i, j - 1)}\n                    />\n                    {!_isScatterPolar && supportsTextMode && text && (\n                      <text\n                        key={`${circleId}-label`}\n                        x={xPoint1}\n                        y={\n                          yPoint1 +\n                          Math.max(currentMarkerSize ? (currentMarkerSize * extraMaxPixels) / maxMarkerSize : 4, 4) +\n                          12\n                        }\n                        className={classes.markerLabel}\n                        opacity={isLegendSelected && !currentPointHidden ? 1 : 0.01}\n                      >\n                        {text}\n                      </text>\n                    )}\n                  </>\n                ) : (\n                  <path\n                    id={circleId}\n                    key={circleId}\n                    d={path}\n                    data-is-focusable={isLegendSelected}\n                    onMouseOver={(event: React.MouseEvent<SVGElement>) =>\n                      _handleHover(\n                        x1,\n                        y1,\n                        verticaLineHeight,\n                        xAxisCalloutData,\n                        circleId,\n                        xAxisCalloutAccessibilityData,\n                        event,\n                        yScale,\n                        legendVal,\n                        lineColor,\n                        targetElement,\n                      )\n                    }\n                    onMouseMove={(event: React.MouseEvent<SVGElement>) =>\n                      _handleHover(\n                        x1,\n                        y1,\n                        verticaLineHeight,\n                        xAxisCalloutData,\n                        circleId,\n                        xAxisCalloutAccessibilityData,\n                        event,\n                        yScale,\n                        legendVal,\n                        lineColor,\n                        targetElement,\n                      )\n                    }\n                    onMouseOut={_handleMouseOut}\n                    onFocus={event =>\n                      _handleFocus(\n                        event,\n                        lineId,\n                        x1,\n                        xAxisCalloutData,\n                        circleId,\n                        targetElement,\n                        xAxisCalloutAccessibilityData,\n                      )\n                    }\n                    onBlur={_handleMouseOut}\n                    {..._getClickHandler(_points[i].data[j - 1].onDataPointClick)}\n                    opacity={isLegendSelected && !currentPointHidden ? 1 : 0.01}\n                    fill={_points[i].data[j - 1]?.markerColor || _getPointFill(lineColor, circleId, j, false)}\n                    stroke={_points[i].data[j - 1]?.markerColor || lineColor}\n                    strokeWidth={strokeWidth}\n                    role=\"img\"\n                    aria-label={_getAriaLabel(i, j - 1)}\n                    tabIndex={isLegendSelected ? 0 : undefined}\n                  />\n                ),\n              );\n            }\n            if (j + 1 === _points[i].data.length) {\n              // If this is last point of the line segment.\n              const lastCircleId = `${circleId}${j}L`;\n              const hiddenHoverCircleId = `${circleId}${j}D`;\n              const lastPointHidden = _points[i].hideNonActiveDots && activePoint !== lastCircleId;\n              const {\n                xAxisCalloutData: lastCirlceXCallout,\n                xAxisCalloutAccessibilityData: lastCirlceXCalloutAccessibilityData,\n              } = _points[i].data[j];\n              currentMarkerSize = _points[i].data[j].markerSize!;\n              const lastSupportsTextMode = _points[i].lineOptions?.mode?.includes('text');\n              const lastText = _points[i].data[j].text;\n              if (isPlottable(xPoint2, yPoint2)) {\n                const path = _getPath(xPoint2, yPoint2, lastCircleId, j, true, _points[i].index);\n                const targetElement = document.getElementById(lastCircleId);\n                pointsForLine.push(\n                  <React.Fragment key={`${lastCircleId}_container`}>\n                    {_points[i].lineOptions?.mode?.includes('markers') || lastSupportsTextMode ? (\n                      <>\n                        <circle\n                          id={lastCircleId}\n                          key={lastCircleId}\n                          r={currentMarkerSize ? (currentMarkerSize! * extraMaxPixels) / maxMarkerSize : 4}\n                          cx={xPoint2}\n                          cy={yPoint2}\n                          data-is-focusable={isLegendSelected}\n                          onMouseOver={event =>\n                            _handleHover(\n                              x2,\n                              y2,\n                              verticaLineHeight,\n                              lastCirlceXCallout,\n                              lastCircleId,\n                              lastCirlceXCalloutAccessibilityData,\n                              event,\n                              yScale,\n                              legendVal,\n                              lineColor,\n                              targetElement,\n                            )\n                          }\n                          onMouseMove={event =>\n                            _handleHover(\n                              x2,\n                              y2,\n                              verticaLineHeight,\n                              lastCirlceXCallout,\n                              lastCircleId,\n                              lastCirlceXCalloutAccessibilityData,\n                              event,\n                              yScale,\n                              legendVal,\n                              lineColor,\n                              targetElement,\n                            )\n                          }\n                          onMouseOut={_handleMouseOut}\n                          onFocus={event =>\n                            _handleFocus(\n                              event,\n                              lineId,\n                              x2,\n                              lastCirlceXCallout,\n                              lastCircleId,\n                              targetElement,\n                              lastCirlceXCalloutAccessibilityData,\n                            )\n                          }\n                          onBlur={_handleMouseOut}\n                          {..._getClickHandler(_points[i].data[j].onDataPointClick)}\n                          opacity={isLegendSelected && !lastPointHidden ? 1 : 0.01}\n                          fill={_getPointFill(lineColor, lastCircleId, j, true)}\n                          stroke={lineColor}\n                          strokeWidth={strokeWidth}\n                          role=\"img\"\n                          aria-label={_points[i].data[j].text ?? _getAriaLabel(i, j)}\n                        />\n                        {!_isScatterPolar && lastSupportsTextMode && lastText && (\n                          <text\n                            key={`${lastCircleId}-label`}\n                            x={xPoint2}\n                            y={\n                              yPoint2 +\n                              Math.max(\n                                currentMarkerSize ? (currentMarkerSize * extraMaxPixels) / maxMarkerSize : 4,\n                                4,\n                              ) +\n                              12\n                            }\n                            className={classes.markerLabel}\n                          >\n                            {text}\n                          </text>\n                        )}\n                      </>\n                    ) : (\n                      <path\n                        id={lastCircleId}\n                        key={lastCircleId}\n                        d={path}\n                        data-is-focusable={isLegendSelected}\n                        onMouseOver={(event: React.MouseEvent<SVGElement>) =>\n                          _handleHover(\n                            x2,\n                            y2,\n                            verticaLineHeight,\n                            lastCirlceXCallout,\n                            lastCircleId,\n                            lastCirlceXCalloutAccessibilityData,\n                            event,\n                            yScale,\n                            legendVal,\n                            lineColor,\n                            targetElement,\n                          )\n                        }\n                        onMouseMove={(event: React.MouseEvent<SVGElement>) =>\n                          _handleHover(\n                            x2,\n                            y2,\n                            verticaLineHeight,\n                            lastCirlceXCallout,\n                            lastCircleId,\n                            lastCirlceXCalloutAccessibilityData,\n                            event,\n                            yScale,\n                            legendVal,\n                            lineColor,\n                            targetElement,\n                          )\n                        }\n                        onMouseOut={_handleMouseOut}\n                        onFocus={event =>\n                          _handleFocus(\n                            event,\n                            lineId,\n                            x2,\n                            lastCirlceXCallout,\n                            lastCircleId,\n                            targetElement,\n                            lastCirlceXCalloutAccessibilityData,\n                          )\n                        }\n                        onBlur={_handleMouseOut}\n                        {..._getClickHandler(_points[i].data[j].onDataPointClick)}\n                        opacity={isLegendSelected && !lastPointHidden ? 1 : 0.01}\n                        fill={_points[i].data[j]?.markerColor || _getPointFill(lineColor, lastCircleId, j, true)}\n                        stroke={_points[i].data[j]?.markerColor || lineColor}\n                        strokeWidth={strokeWidth}\n                        role=\"img\"\n                        aria-label={_getAriaLabel(i, j)}\n                        tabIndex={isLegendSelected ? 0 : undefined}\n                      />\n                    )}\n                    {/* Dummy circle acting as magnetic latch for last callout point */}\n                    <circle\n                      id={hiddenHoverCircleId}\n                      key={hiddenHoverCircleId}\n                      r={8}\n                      cx={xPoint2}\n                      cy={yPoint2}\n                      opacity={0}\n                      width={0}\n                      onMouseOver={(event: React.MouseEvent<SVGElement>) =>\n                        _handleHover(\n                          x2,\n                          y2,\n                          verticaLineHeight,\n                          lastCirlceXCallout,\n                          lastCircleId,\n                          lastCirlceXCalloutAccessibilityData,\n                          event,\n                          yScale,\n                          legendVal,\n                          lineColor,\n                          targetElement,\n                        )\n                      }\n                      onMouseMove={(event: React.MouseEvent<SVGElement>) =>\n                        _handleHover(\n                          x2,\n                          y2,\n                          verticaLineHeight,\n                          lastCirlceXCallout,\n                          lastCircleId,\n                          lastCirlceXCalloutAccessibilityData,\n                          event,\n                          yScale,\n                          legendVal,\n                          lineColor,\n                          targetElement,\n                        )\n                      }\n                      onMouseOut={_handleMouseOut}\n                      strokeWidth={0}\n                      focusable={false}\n                      onBlur={_handleMouseOut}\n                    />\n                  </React.Fragment>,\n                );\n              }\n            }\n\n            if (\n              isPlottable(xPoint1, yPoint1) &&\n              isPlottable(xPoint2, yPoint2) &&\n              (!_hasMarkersMode || _points[i].lineOptions?.mode?.includes('lines'))\n            ) {\n              if (isLegendSelected) {\n                // don't draw line if it is in a gap\n                if (!isInGap) {\n                  const lineBorderWidth = _points[i].lineOptions?.lineBorderWidth\n                    ? Number.parseFloat(_points[i].lineOptions!.lineBorderWidth!.toString())\n                    : 0;\n                  const targetElement = document.getElementById(circleId);\n                  if (lineBorderWidth > 0) {\n                    bordersForLine.push(\n                      <line\n                        id={borderId}\n                        key={borderId}\n                        x1={xPoint1}\n                        y1={yPoint1}\n                        x2={xPoint2}\n                        y2={yPoint2}\n                        strokeLinecap={_points[i].lineOptions?.strokeLinecap ?? 'round'}\n                        strokeWidth={Number.parseFloat(strokeWidth.toString()) + lineBorderWidth}\n                        stroke={_points[i].lineOptions?.lineBorderColor || tokens.colorNeutralBackground1}\n                        opacity={1}\n                      />,\n                    );\n                  }\n\n                  linesForLine.push(\n                    <line\n                      id={lineId}\n                      key={lineId}\n                      x1={xPoint1}\n                      y1={yPoint1}\n                      x2={xPoint2}\n                      y2={yPoint2}\n                      strokeWidth={strokeWidth}\n                      ref={(e: SVGLineElement | null) => {\n                        _refCallback(e!, lineId);\n                      }}\n                      onMouseOver={event =>\n                        _handleHover(\n                          x1,\n                          y1,\n                          verticaLineHeight,\n                          xAxisCalloutData,\n                          circleId,\n                          xAxisCalloutAccessibilityData,\n                          event,\n                          yScale,\n                          legendVal,\n                          lineColor,\n                          targetElement,\n                        )\n                      }\n                      onMouseMove={event =>\n                        _handleHover(\n                          x1,\n                          y1,\n                          verticaLineHeight,\n                          xAxisCalloutData,\n                          circleId,\n                          xAxisCalloutAccessibilityData,\n                          event,\n                          yScale,\n                          legendVal,\n                          lineColor,\n                          targetElement,\n                        )\n                      }\n                      onMouseOut={_handleMouseOut}\n                      stroke={lineColor}\n                      strokeLinecap={_points[i].lineOptions?.strokeLinecap ?? 'round'}\n                      strokeDasharray={_points[i].lineOptions?.strokeDasharray}\n                      strokeDashoffset={_points[i].lineOptions?.strokeDashoffset}\n                      opacity={1}\n                      {..._getClickHandler(_points[i].onLineClick)}\n                    />,\n                  );\n                }\n              } else {\n                if (!isInGap) {\n                  linesForLine.push(\n                    <line\n                      id={lineId}\n                      key={lineId}\n                      x1={xPoint1}\n                      y1={yPoint1}\n                      x2={xPoint2}\n                      y2={yPoint2}\n                      strokeWidth={strokeWidth}\n                      stroke={lineColor}\n                      strokeLinecap={_points[i].lineOptions?.strokeLinecap ?? 'round'}\n                      strokeDasharray={_points[i].lineOptions?.strokeDasharray}\n                      strokeDashoffset={_points[i].lineOptions?.strokeDashoffset}\n                      opacity={0.1}\n                    />,\n                  );\n                }\n              }\n            }\n          }\n        }\n\n        // Add filled area for scatterpolar charts\n        const fillMode = _points[i].lineOptions?.fill;\n        const isLegendSelected: boolean = _legendHighlighted(legendVal) || _noLegendHighlighted() || isSelectedLegend;\n        if (fillMode === 'toself' && _points[i].data.length >= 3 && isLegendSelected && _isScatterPolar) {\n          const getScaledXValue = (dataPoint: LineChartDataPoint) =>\n            _xAxisScale(dataPoint.x instanceof Date ? dataPoint.x : (dataPoint.x as number));\n\n          const fillPathGenerator = d3Line<LineChartDataPoint>()\n            .x(dataPoint => getScaledXValue(dataPoint))\n            .y(dataPoint => yScale(dataPoint.y))\n            .curve(getCurveFactory(lineCurve))\n            .defined(dataPoint => isPlottable(getScaledXValue(dataPoint), yScale(dataPoint.y)));\n\n          const fillPath = fillPathGenerator(_points[i].data as LineChartDataPoint[]);\n\n          if (fillPath) {\n            linesForLine.push(\n              <path\n                key={`scatterpolar_fill_${i}`}\n                d={`${fillPath}Z`}\n                fill={lineColor}\n                fillOpacity={0.5}\n                stroke={lineColor}\n                strokeWidth={2}\n                strokeOpacity={0.8}\n                pointerEvents=\"none\"\n              />,\n            );\n          }\n        }\n\n        if (_isScatterPolar) {\n          pointsForLine.push(\n            ...renderScatterPolarCategoryLabels({\n              xAxisScale: _xAxisScale,\n              yAxisScale: yScale,\n              className: classes.markerLabel || '',\n              lineOptions: (_points[i] as Partial<LineChartPoints>)?.lineOptions,\n            }),\n          );\n        }\n\n        lines.push(\n          <g\n            key={`line_${i}`}\n            role=\"region\"\n            aria-label={`${legendVal}, line ${i + 1} of ${_points.length} with ${_points[i].data.length} data points.`}\n          >\n            {bordersForLine}\n            {linesForLine}\n            {pointsForLine}\n          </g>,\n        );\n      }\n      // Removing un wanted tooltip div from DOM, when prop not provided.\n      if (!props.showXAxisLablesTooltip) {\n        try {\n          document.getElementById(_tooltipId) && document.getElementById(_tooltipId)!.remove();\n          // eslint-disable-next-line no-empty\n        } catch (e) {}\n      }\n      // Used to display tooltip at x axis labels.\n      if (!props.wrapXAxisLables && props.showXAxisLablesTooltip) {\n        const xAxisElement = d3Select(xElement).call(_xAxisScale);\n        try {\n          document.getElementById(_tooltipId) && document.getElementById(_tooltipId)!.remove();\n          // eslint-disable-next-line no-empty\n        } catch (e) {}\n        const tooltipProps = {\n          tooltipCls: classes.tooltip!,\n          id: _tooltipId,\n          axis: xAxisElement,\n        };\n        xAxisElement && tooltipOfAxislabels(tooltipProps);\n      }\n      return lines;\n    }\n\n    function _createColorFillBars(containerHeight: number) {\n      const colorFillBars: JSXElement[] = [];\n      if (isSelectedLegend) {\n        _colorFillBars.current = selectedColorBarLegend;\n      } else {\n        _colorFillBars.current = props.colorFillBars!;\n      }\n\n      const yMinMaxValues = findNumericMinMaxOfY(_points);\n      const FILL_Y_PADDING = 3;\n      for (let i = 0; i < _colorFillBars.current.length; i++) {\n        const colorFillBar = _colorFillBars.current[i];\n        const colorFillBarId = `${_colorFillBarId}-${i}`;\n        const color = getColorFromToken(colorFillBar.color);\n\n        if (colorFillBar.applyPattern) {\n          // Using a pattern element because CSS was unable to render diagonal stripes for rect elements\n          colorFillBars.push(_getStripePattern(color, i));\n        }\n\n        for (let j = 0; j < colorFillBar.data.length; j++) {\n          const startX = colorFillBar.data[j].startX;\n          const endX = colorFillBar.data[j].endX;\n          const opacity =\n            _legendHighlighted(colorFillBar.legend) || _noLegendHighlighted() || isSelectedLegend\n              ? _getColorFillBarOpacity(colorFillBar)\n              : 0.1;\n          colorFillBars.push(\n            <rect\n              fill={colorFillBar.applyPattern ? `url(#${_colorFillBarPatternId}_${i})` : color}\n              fillOpacity={opacity}\n              x={_isRTL ? _xAxisScale(endX) : _xAxisScale(startX)}\n              y={_yScalePrimary(yMinMaxValues.endValue) - FILL_Y_PADDING}\n              width={Math.abs(_xAxisScale(endX) - _xAxisScale(startX))}\n              height={_yScalePrimary(props.yMinValue || 0) - _yScalePrimary(yMinMaxValues.endValue) + FILL_Y_PADDING}\n              key={`${colorFillBarId}${j}`}\n            />,\n          );\n        }\n      }\n      return colorFillBars;\n    }\n\n    function _getStripePattern(color: string, id: number) {\n      // This describes a tile pattern that resembles diagonal stripes\n      // For more information: https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/d\n      const stripePath = 'M-4,4 l8,-8 M0,16 l16,-16 M12,20 l8,-8';\n      return (\n        <pattern\n          id={`${_colorFillBarPatternId}_${id}`}\n          width={16}\n          height={16}\n          key={`${_colorFillBarPatternId}_${id}`}\n          patternUnits={'userSpaceOnUse'}\n        >\n          <path d={stripePath} stroke={color} strokeWidth={1.25} />\n        </pattern>\n      );\n    }\n\n    function _checkInGap(pointIndex: number, gaps: LineChartGap[], currentGapIndex: number) {\n      let gapIndex = currentGapIndex;\n      let isInGap = false;\n\n      while (gapIndex < gaps.length && pointIndex > gaps[gapIndex].endIndex) {\n        gapIndex++;\n      }\n\n      if (gapIndex < gaps.length && pointIndex > gaps[gapIndex].startIndex && pointIndex <= gaps[gapIndex].endIndex) {\n        isInGap = true;\n      }\n      return { isInGap, gapIndex };\n    }\n\n    function _refCallback(element: SVGGElement, legendTitle: string): void {\n      _refArray.push({ index: legendTitle, refElement: element });\n    }\n\n    const _onMouseOverLargeDataset = (\n      linenumber: number,\n      lineHeight: number,\n      mouseEvent: React.MouseEvent<SVGRectElement | SVGPathElement | SVGCircleElement>,\n      yScale: ScaleLinear<number, number>,\n    ) => {\n      mouseEvent.persist();\n      const { data } = props;\n      const { lineChartData } = data;\n\n      // This will get the value of the X when mouse is on the chart\n      const xOffset = _xAxisScale.invert(pointer(mouseEvent)[0], document.getElementById(_rectId)!);\n      const i = bisect(lineChartData![linenumber].data, xOffset);\n      const d0 = lineChartData![linenumber].data[i - 1] as LineChartDataPoint;\n      const d1 = lineChartData![linenumber].data[i] as LineChartDataPoint;\n      let axisType: XAxisTypes | null = null;\n      let xPointToHighlight: string | Date | number = 0;\n      let index: null | number = null;\n      if (d0 === undefined && d1 !== undefined) {\n        xPointToHighlight = d1.x;\n        index = i;\n      } else if (d0 !== undefined && d1 === undefined) {\n        xPointToHighlight = d0.x;\n        index = i - 1;\n      } else {\n        axisType = getTypeOfAxis(lineChartData![linenumber].data[0].x, true) as XAxisTypes;\n        let x0;\n        let point0;\n        let point1;\n        switch (axisType) {\n          case XAxisTypes.DateAxis:\n            x0 = new Date(xOffset).getTime();\n            point0 = (d0.x as Date).getTime();\n            point1 = (d1.x as Date).getTime();\n            xPointToHighlight = Math.abs(x0 - point0) > Math.abs(x0 - point1) ? d1.x : d0.x;\n            index = Math.abs(x0 - point0) > Math.abs(x0 - point1) ? i : i - 1;\n            break;\n          case XAxisTypes.NumericAxis:\n            x0 = xOffset as number;\n            point0 = d0.x as number;\n            point1 = d1.x as number;\n            xPointToHighlight = Math.abs(x0 - point0) > Math.abs(x0 - point1) ? d1.x : d0.x;\n            index = Math.abs(x0 - point0) > Math.abs(x0 - point1) ? i : i - 1;\n            break;\n          default:\n            break;\n        }\n      }\n\n      const { xAxisCalloutData } = lineChartData![linenumber].data[index as number];\n      const formattedDate =\n        xPointToHighlight instanceof Date\n          ? formatDateToLocaleString(xPointToHighlight, props.culture, props.useUTC as boolean)\n          : xPointToHighlight;\n      const found = findCalloutPoints(calloutPointsRef.current, xPointToHighlight) as CustomizedCalloutData | undefined;\n      const pointToHighlight: LineChartDataPoint = lineChartData![linenumber].data[index!] as LineChartDataPoint;\n      const pointToHighlightUpdated =\n        nearestCircleToHighlight === null ||\n        (nearestCircleToHighlight !== null &&\n          pointToHighlight !== null &&\n          (nearestCircleToHighlight.x !== pointToHighlight.x || nearestCircleToHighlight.y !== pointToHighlight.y));\n      // if no points need to be called out then don't show vertical line and callout card\n      if (found && pointToHighlightUpdated) {\n        _uniqueCallOutID = `#${_staticHighlightCircle}_${linenumber}`;\n\n        d3Select(`#${_staticHighlightCircle}_${linenumber}`)\n          .attr('cx', `${_xAxisScale(pointToHighlight.x)}`)\n          .attr('cy', `${yScale(pointToHighlight.y)}`)\n          .attr('visibility', 'visibility');\n\n        d3Select(`#${_verticalLine}`)\n          .attr('transform', () => `translate(${_xAxisScale(pointToHighlight.x)}, ${yScale(pointToHighlight.y)})`)\n          .attr('visibility', 'visibility')\n          .attr('y2', `${lineHeight - 5 - yScale(pointToHighlight.y)}`);\n\n        const targetElement = document.getElementById(`${_staticHighlightCircle}_${linenumber}`);\n        const rect = targetElement!.getBoundingClientRect();\n        setNearestCircleToHighlight(pointToHighlight);\n        updatePosition(rect.x, rect.y);\n        setStackCalloutProps(found!);\n        setYValueHover(found.values);\n        setDataPointCalloutProps(found!);\n        xAxisCalloutData ? setHoverXValue(xAxisCalloutData) : setHoverXValue(formattedDate);\n        setActivePoint('');\n      }\n\n      if (!found) {\n        setPopoverOpen(false);\n        setNearestCircleToHighlight(pointToHighlight);\n        setActivePoint('');\n      }\n    };\n\n    function _handleFocus(\n      event: React.FocusEvent<SVGCircleElement | SVGPathElement, Element>,\n      lineId: string,\n      x: number | Date,\n      xAxisCalloutData: string | undefined,\n      circleId: string,\n      targetElement: HTMLElement | null,\n      xAxisCalloutAccessibilityData?: AccessibilityProps,\n    ) {\n      _uniqueCallOutID = circleId;\n      const formattedData = x instanceof Date ? formatDateToLocaleString(x, props.culture, props.useUTC as boolean) : x;\n      const found = findCalloutPoints(calloutPointsRef.current, x) as CustomizedCalloutData | undefined;\n      // if no points need to be called out then don't show vertical line and callout card\n\n      if (found) {\n        d3Select(`#${_verticalLine}`)\n          .attr('transform', () => `translate(${_xAxisScale(x)}, 0)`)\n          .attr('visibility', 'visibility');\n        _refArray.forEach((obj: RefArrayData) => {\n          if (obj.index === lineId) {\n            setPopoverOpen(true);\n            xAxisCalloutData ? setHoverXValue(xAxisCalloutData) : setHoverXValue('' + formattedData);\n            setYValueHover(found.values);\n            setRefSelected(targetElement);\n            setStackCalloutProps(found!);\n            setDataPointCalloutProps(found!);\n            setActivePoint(circleId);\n          }\n        });\n      } else {\n        setActivePoint(circleId);\n      }\n    }\n\n    function _handleHover(\n      x: number | Date,\n      y: number,\n      lineHeight: number,\n      xAxisCalloutData: string | undefined,\n      circleId: string,\n      xAxisCalloutAccessibilityData: AccessibilityProps | undefined,\n      mouseEvent: React.MouseEvent<SVGElement>,\n      yScale: ScaleLinear<number, number>,\n      legendVal: string,\n      lineColor: string,\n      targetElement: HTMLElement | null,\n    ) {\n      mouseEvent?.persist();\n      const formattedData = x instanceof Date ? formatDateToLocaleString(x, props.culture, props.useUTC as boolean) : x;\n      const found = findCalloutPoints(calloutPointsRef.current, x) as CustomizedCalloutData | undefined;\n      let hoverDp: CustomizedCalloutData | undefined = undefined;\n\n      if (props.isCalloutForStack === false && found?.values) {\n        const dp = find(found.values, (val: CustomizedCalloutDataPoint) => val?.y === y);\n        if (dp) {\n          hoverDp = {\n            x,\n            values: [dp],\n          };\n        }\n      }\n      // if no points need to be called out then don't show vertical line and callout card\n      if (found) {\n        d3Select(`#${_verticalLine}`)\n          .attr('transform', () => `translate(${_xAxisScale(x)}, ${yScale(y)})`)\n          .attr('visibility', 'visibility')\n          .attr('y2', `${lineHeight - 5 - yScale(y)}`);\n\n        if (_uniqueCallOutID !== circleId) {\n          _uniqueCallOutID = circleId;\n          setRefSelected(targetElement);\n          setPopoverOpen(true);\n          xAxisCalloutData ? setHoverXValue(xAxisCalloutData) : setHoverXValue('' + formattedData);\n          setYValueHover(found.values);\n          setYValue(y);\n          setLegendVal(legendVal);\n          setLineColor(lineColor);\n          setStackCalloutProps(found!);\n          setDataPointCalloutProps(hoverDp);\n          setActivePoint(circleId);\n          setNearestCircleToHighlight(null);\n        }\n      } else {\n        setActivePoint(circleId);\n        setNearestCircleToHighlight(null);\n      }\n    }\n\n    /**\n     * Screen readers announce an element as clickable if the onClick attribute is set.\n     * This function sets the attribute only when a click event handler is provided.*/\n\n    function _getClickHandler(func?: () => void): { onClick?: () => void } {\n      if (func) {\n        return {\n          onClick: func,\n        };\n      }\n\n      return {};\n    }\n\n    function _handleMouseOut() {\n      d3Select(`#${_verticalLine}`).attr('visibility', 'hidden');\n    }\n\n    function _handleChartMouseLeave() {\n      _uniqueCallOutID = null;\n      setActivePoint('');\n      if (isPopoverOpen) {\n        setPopoverOpen(false);\n      }\n    }\n\n    function _handleMultipleLineLegendSelectionAction(selectedLine: LineChartDataWithIndex) {\n      const selectedLineIndex = selectedLegendPoints.reduce((acc, line, index) => {\n        if (acc > -1 || line.legend !== selectedLine.legend) {\n          return acc;\n        } else {\n          return index;\n        }\n      }, -1);\n\n      let selectedLines: LineChartDataWithIndex[];\n      if (selectedLineIndex === -1) {\n        selectedLines = [...selectedLegendPoints, selectedLine];\n      } else {\n        selectedLines = selectedLegendPoints\n          .slice(0, selectedLineIndex)\n          .concat(selectedLegendPoints.slice(selectedLineIndex + 1));\n      }\n\n      const areAllLineLegendsSelected = props.data && selectedLines.length === props.data.lineChartData!.length;\n\n      if (\n        areAllLineLegendsSelected &&\n        ((props.colorFillBars && props.colorFillBars.length === selectedColorBarLegend.length) || !props.colorFillBars)\n      ) {\n        // Clear all legends if all legends including color fill bar legends are selected\n        // Or clear all legends if all legends are selected and there are no color fill bars\n        _clearMultipleLegendSelections();\n      } else if (!selectedLines.length && !selectedColorBarLegend.length) {\n        // Clear all legends if no legends including color fill bar legends are selected\n        _clearMultipleLegendSelections();\n      } else {\n        // Otherwise, set state when one or more legends are selected, including color fill bar legends\n        setSelectedLegendPoints(selectedLines);\n        setIsSelectedLegend(true);\n      }\n\n      const selectedLegendTitlesToPass = selectedLines.map((line: LineChartDataWithIndex) => line.legend);\n      _handleLegendClick(selectedLine, selectedLegendTitlesToPass);\n    }\n\n    function _handleMultipleColorFillBarLegendSelectionAction(selectedColorFillBar: ColorFillBarsProps) {\n      const selectedColorFillBarIndex = selectedColorBarLegend.reduce((acc, colorFillBar, index) => {\n        if (acc > -1 || colorFillBar.legend !== selectedColorFillBar.legend) {\n          return acc;\n        } else {\n          return index;\n        }\n      }, -1);\n\n      let selectedColorFillBars: ColorFillBarsProps[];\n      if (selectedColorFillBarIndex === -1) {\n        selectedColorFillBars = [...selectedColorBarLegend, selectedColorFillBar];\n      } else {\n        selectedColorFillBars = selectedColorBarLegend\n          .slice(0, selectedColorFillBarIndex)\n          .concat(selectedColorBarLegend.slice(selectedColorFillBarIndex + 1));\n      }\n\n      const areAllColorFillBarLegendsSelected =\n        selectedColorFillBars.length === (props.colorFillBars && props.colorFillBars!.length);\n\n      if (\n        areAllColorFillBarLegendsSelected &&\n        ((props.data && props.data.lineChartData!.length === selectedLegendPoints.length) || !props.data)\n      ) {\n        // Clear all legends if all legends, including line legends, are selected\n        // Or clear all legends if all legends are selected and there is no line data\n        _clearMultipleLegendSelections();\n      } else if (!selectedColorFillBars.length && !selectedLegendPoints.length) {\n        // Clear all legends if no legends are selected, including line legends\n        _clearMultipleLegendSelections();\n      } else {\n        // set state when one or more legends are selected, including line legends\n        setSelectedColorBarLegend(selectedColorFillBars);\n        setIsSelectedLegend(true);\n      }\n\n      const selectedLegendTitlesToPass = selectedColorFillBars.map(\n        (colorFillBar: ColorFillBarsProps) => colorFillBar.legend,\n      );\n      _handleLegendClick(selectedColorFillBar, selectedLegendTitlesToPass);\n    }\n\n    function _clearMultipleLegendSelections() {\n      setSelectedColorBarLegend([]);\n      setSelectedLegendPoints([]);\n      setIsSelectedLegend(false);\n    }\n\n    /**\n     * This function checks if the given legend is highlighted or not.\n     * A legend can be highlighted in 2 ways:\n     * 1. selection: if the user clicks on it\n     * 2. hovering: if there is no selected legend and the user hovers over it*/\n\n    function _legendHighlighted(legend: string) {\n      return selectedLegend === legend || (selectedLegend === '' && activeLegend === legend);\n    }\n\n    /**\n     * This function checks if none of the legends is selected or hovered.*/\n\n    function _noLegendHighlighted() {\n      return selectedLegend === '' && activeLegend === '';\n    }\n\n    function _getColorFillBarOpacity(colorFillBar: ColorFillBarsProps) {\n      return colorFillBar.applyPattern ? 1 : 0.4;\n    }\n\n    function _getAriaLabel(lineIndex: number, pointIndex: number): string {\n      const line = _points[lineIndex];\n      const point = line.data[pointIndex];\n      const formattedDate =\n        point.x instanceof Date ? formatDateToLocaleString(point.x, props.culture, props.useUTC as boolean) : point.x;\n      const xValue = point.xAxisCalloutData || formattedDate;\n      const legend = line.legend;\n      const yValue = point.yAxisCalloutData || point.y;\n      return point.callOutAccessibilityData?.ariaLabel || `${xValue}. ${legend}, ${yValue}.`;\n    }\n\n    function _isChartEmpty(): boolean {\n      return !(\n        props.data &&\n        props.data.lineChartData &&\n        props.data.lineChartData.length > 0 &&\n        props.data.lineChartData.filter((item: LineChartPoints) => item.data.length).length > 0\n      );\n    }\n\n    const { legendProps, tickValues, tickFormat, eventAnnotationProps } = props;\n    _points = _injectIndexPropertyInLineChartData(props.data.lineChartData);\n\n    _isXAxisDateType = getXAxisType(_points);\n    let points = _points;\n    if (legendProps && !!legendProps.canSelectMultipleLegends) {\n      points = selectedLegendPoints.length >= 1 ? selectedLegendPoints : _points;\n      calloutPointsRef.current = calloutData(points);\n    }\n\n    let legendBars = null;\n    // reduce computation cost by only creating legendBars\n    // if when hideLegend is false.\n    // NOTE: they are rendered only when hideLegend is false in CartesianChart.\n    if (!props.hideLegend) {\n      legendBars = _createLegends(_points!); // ToDo: Memoize legends to improve performance.\n    }\n    const calloutProps = {\n      YValueHover: yValueHover,\n      hoverXValue: hoverXValue,\n      YValue: YValue,\n      legend: legendVal,\n      color: lineColor,\n      XValue: hoverXValue! as string,\n      descriptionMessage:\n        props.getCalloutDescriptionMessage && stackCalloutProps\n          ? props.getCalloutDescriptionMessage(stackCalloutProps)\n          : undefined,\n      'data-is-focusable': true,\n      xAxisCalloutAccessibilityData: xAxisCalloutAccessibilityData,\n      ...props.calloutProps,\n      isPopoverOpen: isPopoverOpen,\n      clickPosition: clickPosition,\n      positioning: {\n        target: refSelected,\n      },\n      isCalloutForStack: props.isCalloutForStack,\n      culture: props.culture,\n      isCartesian: true,\n      customCallout: {\n        customizedCallout: _getCustomizedCallout() !== null ? _getCustomizedCallout()! : undefined,\n        customCalloutProps: props.calloutPropsPerDataPoint\n          ? props.calloutPropsPerDataPoint(dataPointCalloutProps!)\n          : undefined,\n      },\n    };\n    const tickParams = {\n      tickValues,\n      tickFormat,\n    };\n\n    return !_isChartEmpty() ? (\n      <CartesianChart\n        {...props}\n        chartTitle={props.data.chartTitle}\n        points={points}\n        chartType={ChartTypes.LineChart}\n        calloutProps={calloutProps}\n        tickParams={tickParams}\n        legendBars={legendBars}\n        createYAxis={createNumericYAxis}\n        getmargins={_getMargins}\n        getMinMaxOfYAxis={_getNumericMinMaxOfY}\n        getGraphData={_initializeLineChartData}\n        xAxisType={_isXAxisDateType ? XAxisTypes.DateAxis : XAxisTypes.NumericAxis}\n        {...(_isScatterPolar ? { yMaxValue: 1, yMinValue: -1 } : {})}\n        getDomainNRangeValues={_getDomainNRangeValues}\n        createStringYAxis={createStringYAxis}\n        onChartMouseLeave={_handleChartMouseLeave}\n        enableFirstRenderOptimization={props.enablePerfOptimization && _firstRenderOptimization}\n        componentRef={cartesianChartRef}\n        /* eslint-disable react/jsx-no-bind */\n        // eslint-disable-next-line react/no-children-prop\n        children={(props: ChildProps) => {\n          _xAxisScale = props.xScale!;\n          _yScalePrimary = props.yScalePrimary!;\n          _yScaleSecondary = props.yScaleSecondary;\n          return (\n            <>\n              <g>\n                <line\n                  x1={0}\n                  y1={0}\n                  x2={0}\n                  y2={props.containerHeight}\n                  stroke={'#323130'}\n                  id={_verticalLine}\n                  visibility={'hidden'}\n                  strokeDasharray={'5,5'}\n                />\n                {props.optimizeLargeData ? (\n                  <rect id={_rectId} width={props.containerWidth} height={props.containerHeight} fill={'transparent'} />\n                ) : (\n                  <></>\n                )}\n                <g>\n                  {_renderedColorFillBars}\n                  {lines}\n                </g>\n                {eventAnnotationProps && (\n                  <EventsAnnotation\n                    {...eventAnnotationProps}\n                    scale={props.xScale!}\n                    chartYTop={margins.top! + eventLabelHeight}\n                    chartYBottom={props.containerHeight! - 35}\n                  />\n                )}\n              </g>\n            </>\n          );\n        }}\n      />\n    ) : (\n      <div id={_emptyChartId} role={'alert'} style={{ opacity: '0' }} aria-label={'Graph has no data to display'} />\n    );\n  },\n);\nLineChart.displayName = 'LineChart';\nLineChart.defaultProps = {\n  isCalloutForStack: true,\n};\n"],"names":["React","useLineChartStyles","select","d3Select","pointer","bisector","Legends","line","d3Line","max","d3Max","useId","find","findCalloutPoints","CartesianChart","EventsAnnotation","tokens","calloutData","ChartTypes","getXAxisType","XAxisTypes","tooltipOfAxislabels","Points","pointTypes","getTypeOfAxis","getNextColor","getColorFromToken","findNumericMinMaxOfY","createNumericYAxis","domainRangeOfDateForAreaLineScatterVerticalBarCharts","domainRangeOfNumericForAreaLineScatterCharts","createStringYAxis","useRtl","getCurveFactory","isScatterPolarSeries","getDomainPaddingForMarkers","isPlottable","getRangeForScatterMarkerSize","toImage","renderScatterPolarCategoryLabels","formatDateToLocaleString","PointSize","bisect","d","x","left","DEFAULT_LINE_STROKE_SIZE","PATH_MULTIPLY_SIZE","_getPointPath","y","w","index","allPointPaths","LineChart","forwardRef","props","forwardedRef","_hasMarkersMode","_isXAxisDateType","_isScatterPolar","_points","_injectIndexPropertyInLineChartData","data","lineChartData","_xAxisScale","_yScalePrimary","_circleId","_lineId","_borderId","_verticalLine","_colorFillBarPatternId","_uniqueCallOutID","_refArray","margins","eventLabelHeight","lines","_renderedColorFillBars","_colorFillBars","useRef","_tooltipId","_rectId","_staticHighlightCircle","_firstRenderOptimization","_emptyChartId","_colorFillBarId","_isRTL","xAxisCalloutAccessibilityData","cartesianChartRef","_yScaleSecondary","_legendsRef","eventAnnotationProps","labelHeight","hoverXValue","setHoverXValue","useState","activeLegend","setActiveLegend","yValueHover","setYValueHover","selectedLegend","setSelectedLegend","selectedLegendPoints","setSelectedLegendPoints","selectedColorBarLegend","setSelectedColorBarLegend","isSelectedLegend","setIsSelectedLegend","legendProps","selectedLegends","length","activePoint","setActivePoint","nearestCircleToHighlight","setNearestCircleToHighlight","dataPointCalloutProps","setDataPointCalloutProps","stackCalloutProps","setStackCalloutProps","clickPosition","setClickPosition","isPopoverOpen","setPopoverOpen","YValue","setYValue","legendVal","setLegendVal","lineColor","setLineColor","refSelected","setRefSelected","pointsRef","calloutPointsRef","classes","useEffect","current","height","width","useImperativeHandle","componentRef","chartContainer","opts","toSVG","_getDomainNRangeValues","points","chartType","isRTL","xAxisType","barWidth","tickValues","shiftX","domainNRangeValue","NumericAxis","xScaleType","DateAxis","dStartValue","dEndValue","rStartValue","rEndValue","isFilterSelectedLegends","allowMultipleShapesForPoints","filteredData","filter","item","includes","legend","some","lineOptions","mode","map","color","updatePosition","newX","newY","threshold","distance","Math","sqrt","pow","_getCustomizedCallout","onRenderCalloutPerStack","onRenderCalloutPerDataPoint","_getNumericMinMaxOfY","yAxisType","useSecondaryYScale","startValue","endValue","secondaryYScaleType","yScaleType","yPadding","start","end","_getMargins","_margins","_initializeLineChartData","xScale","yScalePrimary","containerHeight","containerWidth","xElement","yAxisElement","yScaleSecondary","colorFillBars","_createColorFillBars","_createLines","_handleSingleLegendSelectionAction","lineChartItem","_handleLegendClick","_onHoverCardHide","onLegendClick","_createLegends","isLegendMultiSelectEnabled","canSelectMultipleLegends","mapLegendToPoints","forEach","point","push","legendDataItems","Object","entries","legendTitle","representativePoint","title","action","p","_handleMultipleLineLegendSelectionAction","onMouseOutAction","hoverAction","_handleChartMouseLeave","legendShape","shape","keys","colorFillBarsLegendDataItems","colorFillBar","_handleMultipleColorFillBarLegendSelectionAction","opacity","_getColorFillBarOpacity","stripePattern","applyPattern","legends","enabledWrapLines","enabledLegendsWrapLines","overflowText","legendsOverflowText","onLegendHoverCardLeave","legendRef","_getBoxWidthOfShape","pointId","pointIndex","isLastPoint","strokeWidth","_getPath","xPos","yPos","pointOftheLine","widthRatio","_getPointFill","colorNeutralBackground1","maxMarkerSize","markerSize","i","linesForLine","bordersForLine","pointsForLine","verticaLineHeight","bottom","yScale","extraMaxPixels","x1","y1","xAxisCalloutData","xPoint","yPoint","circleId","isLegendSelected","_legendHighlighted","_noLegendHighlighted","currentMarkerSize","supportsTextMode","text","targetElement","document","getElementById","Fragment","key","circle","id","r","cx","cy","fill","tabIndex","undefined","onMouseOver","event","_handleHover","onMouseMove","onMouseOut","_handleMouseOut","stroke","role","aria-label","_getAriaLabel","data-is-focusable","ref","e","_refCallback","onFocus","_handleFocus","onBlur","_getClickHandler","onDataPointClick","className","markerLabel","gapIndex","gaps","sort","a","b","startIndex","lineCurve","curve","optimizeLargeData","defined","lineId","borderId","lineData","k","Date","getTime","lineMode","shouldDrawLines","lineBorderWidth","Number","parseFloat","toString","path","strokeLinecap","lineBorderColor","strokeDasharray","_onMouseOverLargeDataset","onLineClick","visibility","showMarkers","perPointColor","markerColor","bind","j","gapResult","_checkInGap","isInGap","x2","y2","xPoint1","yPoint1","xPoint2","yPoint2","currentPointHidden","hideNonActiveDots","lastCircleId","hiddenHoverCircleId","lastPointHidden","lastCirlceXCallout","lastCirlceXCalloutAccessibilityData","lastSupportsTextMode","lastText","focusable","strokeDashoffset","fillMode","getScaledXValue","dataPoint","fillPathGenerator","fillPath","fillOpacity","strokeOpacity","pointerEvents","xAxisScale","yAxisScale","g","showXAxisLablesTooltip","remove","wrapXAxisLables","xAxisElement","call","tooltipProps","tooltipCls","tooltip","axis","yMinMaxValues","FILL_Y_PADDING","colorFillBarId","_getStripePattern","startX","endX","rect","abs","yMinValue","stripePath","pattern","patternUnits","currentGapIndex","endIndex","element","refElement","linenumber","lineHeight","mouseEvent","persist","xOffset","invert","d0","d1","axisType","xPointToHighlight","x0","point0","point1","formattedDate","culture","useUTC","found","pointToHighlight","pointToHighlightUpdated","attr","getBoundingClientRect","values","formattedData","obj","hoverDp","isCalloutForStack","dp","val","func","onClick","selectedLine","selectedLineIndex","reduce","acc","selectedLines","slice","concat","areAllLineLegendsSelected","_clearMultipleLegendSelections","selectedLegendTitlesToPass","selectedColorFillBar","selectedColorFillBarIndex","selectedColorFillBars","areAllColorFillBarLegendsSelected","lineIndex","xValue","yValue","yAxisCalloutData","callOutAccessibilityData","ariaLabel","_isChartEmpty","tickFormat","legendBars","hideLegend","calloutProps","YValueHover","XValue","descriptionMessage","getCalloutDescriptionMessage","positioning","target","isCartesian","customCallout","customizedCallout","customCalloutProps","calloutPropsPerDataPoint","tickParams","chartTitle","createYAxis","getmargins","getMinMaxOfYAxis","getGraphData","yMaxValue","getDomainNRangeValues","onChartMouseLeave","enableFirstRenderOptimization","enablePerfOptimization","children","scale","chartYTop","top","chartYBottom","div","style","displayName","defaultProps"],"mappings":"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"}