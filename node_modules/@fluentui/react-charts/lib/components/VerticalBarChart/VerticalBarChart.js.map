{"version":3,"sources":["../src/components/VerticalBarChart/VerticalBarChart.tsx"],"sourcesContent":["'use client';\n\nimport * as React from 'react';\nimport { useVerticalBarChartStyles } from './useVerticalBarChartStyles.styles';\nimport { max as d3Max, min as d3Min } from 'd3-array';\nimport { line as d3Line } from 'd3-shape';\nimport { select as d3Select } from 'd3-selection';\nimport {\n  scaleLinear as d3ScaleLinear,\n  ScaleLinear as D3ScaleLinear,\n  scaleBand as d3ScaleBand,\n  scaleUtc as d3ScaleUtc,\n} from 'd3-scale';\nimport { useId } from '@fluentui/react-utilities';\nimport type { JSXElement } from '@fluentui/react-utilities';\nimport { tokens } from '@fluentui/react-theme';\nimport {\n  AccessibilityProps,\n  CartesianChart,\n  Margins,\n  Legend,\n  RefArrayData,\n  VerticalBarChartProps,\n  VerticalBarChartDataPoint,\n  Legends,\n  ChildProps,\n  YValueHover,\n  ChartPopover,\n  Chart,\n  DataPoint,\n  ImageExportOptions,\n  LegendContainer,\n} from '../../index';\nimport {\n  ChartTypes,\n  IAxisData,\n  getAccessibleDataObject,\n  XAxisTypes,\n  NumericAxis,\n  getTypeOfAxis,\n  tooltipOfAxislabels,\n  formatScientificLimitWidth,\n  getBarWidth,\n  getScalePadding,\n  isScalePaddingDefined,\n  calculateAppropriateBarWidth,\n  useRtl,\n  areArraysEqual,\n  calculateLongestLabelWidth,\n  findVerticalNumericMinMaxOfY,\n  createNumericYAxis,\n  IDomainNRange,\n  domainRangeOfVerticalNumeric,\n  domainRangeOfDateForAreaLineScatterVerticalBarCharts,\n  domainRangeOfXStringAxis,\n  createStringYAxis,\n  calcTotalWidth,\n  calcBandwidth,\n  calcRequiredWidth,\n  sortAxisCategories,\n} from '../../utilities/index';\nimport { toImage } from '../../utilities/image-export-utils';\n\nenum CircleVisbility {\n  show = 'visibility',\n  hide = 'hidden',\n}\n\nconst MIN_DOMAIN_MARGIN = 8;\n\n// Create a VerticalBarChart variant which uses these default styles and this styled subcomponent.\n/**\n * VerticalBarchart component\n * {@docCategory VerticalBarChart}\n */\nexport const VerticalBarChart: React.FunctionComponent<VerticalBarChartProps> = React.forwardRef<\n  HTMLDivElement,\n  VerticalBarChartProps\n>((_props, forwardedRef) => {\n  const props: VerticalBarChartProps = {\n    xAxisCategoryOrder: 'default',\n    maxBarWidth: 24,\n    ..._props,\n  };\n  let _points: VerticalBarChartDataPoint[] = [];\n  let _barWidth: number = 0;\n  let _colors: string[];\n  const _refArray: RefArrayData[] = [];\n  let margins: Margins;\n  const _useRtl: boolean = useRtl();\n  let _bars: JSXElement[];\n  let _xAxisLabels: string[];\n  let _yMax: number;\n  let _yMin: number;\n  let _isHavingLine: boolean = _checkForLine();\n  const _tooltipId: string = useId('VCTooltipID_');\n  let _xAxisType: XAxisTypes;\n  let _calloutAnchorPoint: VerticalBarChartDataPoint | null;\n  let _domainMargin: number;\n  const _emptyChartId: string = useId('_VBC_empty');\n  const _vbcLineId: string = useId('_VBC_line_');\n  const _vbcPointId: string = useId('_VBC_point_');\n  const _vbcBarId: string = useId('_VBC_bar_');\n  let _xAxisInnerPadding: number = 0;\n  let _xAxisOuterPadding: number = 0;\n  type ColorScale = (_p?: number) => string;\n  const cartesianChartRef = React.useRef<Chart>(null);\n  const _legendsRef = React.useRef<LegendContainer>(null);\n\n  const [color, setColor] = React.useState<string>('');\n  const [dataForHoverCard, setDataForHoverCard] = React.useState<number>(0);\n  const [activeLegend, setActiveLegend] = React.useState<string | undefined>(undefined);\n  const [xCalloutValue, setXCalloutValue] = React.useState<string | undefined>('');\n  const [yCalloutValue, setYCalloutValue] = React.useState<string | undefined>('');\n  const [activeXdataPoint, setActiveXDatapoint] = React.useState<string | number | Date | null>(null);\n  const [hoveredYValues, setYValueHover] = React.useState<YValueHover[]>();\n  const [hoverXValue, setHoverXValue] = React.useState<string | number | undefined>('');\n  const [calloutLegend, setCalloutLegend] = React.useState<string>('');\n  const [callOutAccessibilityData, setCalloutAccessibilityData] = React.useState<AccessibilityProps>();\n  const [dataPointCalloutProps, setDataPointCalloutProps] = React.useState<VerticalBarChartDataPoint>();\n  const [clickPosition, setClickPosition] = React.useState({ x: 0, y: 0 });\n  const [isPopoverOpen, setPopoverOpen] = React.useState(false);\n  const [selectedLegends, setSelectedLegends] = React.useState<string[]>(props.legendProps?.selectedLegends || []);\n  const prevPropsRef = React.useRef<VerticalBarChartProps | null>(null);\n\n  React.useImperativeHandle(\n    props.componentRef,\n    () => ({\n      chartContainer: cartesianChartRef.current?.chartContainer ?? null,\n      toImage: (opts?: ImageExportOptions): Promise<string> => {\n        return toImage(cartesianChartRef.current?.chartContainer, _legendsRef.current?.toSVG, _useRtl, opts);\n      },\n    }),\n    [],\n  );\n\n  React.useEffect(() => {\n    if (prevPropsRef.current) {\n      const prevProps = prevPropsRef.current;\n      if (!areArraysEqual(prevProps.legendProps?.selectedLegends, props.legendProps?.selectedLegends)) {\n        setSelectedLegends(props.legendProps?.selectedLegends || []);\n      }\n      if (prevProps.height !== props.height || prevProps.width !== props.width) {\n        _adjustProps();\n      }\n    }\n    prevPropsRef.current = props;\n  }, [props, prevPropsRef, _adjustProps]);\n\n  function _getDomainNRangeValues(\n    points: DataPoint[],\n    margins: Margins,\n    width: number,\n    chartType: ChartTypes,\n    isRTL: boolean,\n    xAxisType: XAxisTypes,\n    barWidth: number,\n    tickValues: Date[] | number[] | undefined,\n    shiftX: number,\n  ) {\n    let domainNRangeValue: IDomainNRange;\n    if (xAxisType === XAxisTypes.NumericAxis) {\n      domainNRangeValue = domainRangeOfVerticalNumeric(points, margins, width, isRTL, barWidth!);\n    } else if (xAxisType === XAxisTypes.DateAxis) {\n      domainNRangeValue = domainRangeOfDateForAreaLineScatterVerticalBarCharts(\n        points,\n        margins,\n        width,\n        isRTL,\n        tickValues! as Date[],\n        chartType,\n        barWidth,\n      );\n    } else {\n      domainNRangeValue = domainRangeOfXStringAxis(margins, width, isRTL);\n    }\n    return domainNRangeValue;\n  }\n\n  function _createLine(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    xScale: any,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    yScalePrimary: any,\n    containerHeight: number = 0,\n    containerWidth: number = 0,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    yScaleSecondary?: any,\n  ): React.ReactNode {\n    const isStringAxis = _xAxisType === XAxisTypes.StringAxis;\n    const colorScale = _createColors();\n    const { data, lineLegendColor = tokens.colorPaletteYellowBackground1, lineLegendText } = props;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const lineData: Array<any> = [];\n    const line: JSXElement[] = [];\n    data &&\n      data.forEach((item: VerticalBarChartDataPoint, index: number) => {\n        if (item.lineData && item.lineData.y) {\n          lineData.push({\n            x: item.x,\n            y: item.lineData!.y,\n            useSecondaryYScale: item.lineData!.useSecondaryYScale ?? false,\n            point: item,\n            index,\n          });\n        }\n      });\n    const linePath = d3Line()\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      .x((d: any) => (isStringAxis ? xScale(d.x) + 0.5 * xScale.bandwidth() : xScale(d.x)))\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      .y((d: any) => (d.useSecondaryYScale && yScaleSecondary ? yScaleSecondary(d.y) : yScalePrimary(d.y)));\n    const shouldHighlight = _legendHighlighted(lineLegendText!) || _noLegendHighlighted() ? true : false;\n    const lineBorderWidth = props.lineOptions?.lineBorderWidth\n      ? Number.parseFloat(props.lineOptions!.lineBorderWidth!.toString())\n      : 0;\n\n    if (lineBorderWidth > 0) {\n      line.push(\n        <path\n          key={_vbcLineId}\n          id={_vbcLineId}\n          opacity={shouldHighlight ? 1 : 0.1}\n          d={linePath(lineData)!}\n          fill=\"transparent\"\n          strokeLinecap=\"square\"\n          strokeWidth={3 + lineBorderWidth * 2}\n          className={classes.lineBorder}\n        />,\n      );\n    }\n    line.push(\n      <path\n        key={_vbcLineId}\n        id={_vbcLineId}\n        opacity={shouldHighlight ? 1 : 0.1}\n        d={linePath(lineData)!}\n        fill=\"transparent\"\n        strokeLinecap=\"square\"\n        strokeWidth={3}\n        stroke={lineLegendColor}\n      />,\n    );\n\n    const dots: React.ReactNode[] = lineData.map(\n      (\n        item: {\n          x: number | string;\n          y: number;\n          useSecondaryYScale: boolean;\n          point: VerticalBarChartDataPoint;\n          index: number;\n        },\n        index: number,\n      ) => {\n        // Create an object to store line point ref so that the object can be passed by reference to the focus handler\n        const circleRef: { refElement: SVGCircleElement | null } = { refElement: null };\n        return (\n          <circle\n            key={index}\n            id={`${_vbcPointId}-${index}`}\n            cx={isStringAxis ? xScale(item.x) + 0.5 * xScale.bandwidth() : xScale(item.x)}\n            cy={item.useSecondaryYScale && yScaleSecondary ? yScaleSecondary(item.y) : yScalePrimary(item.y)}\n            onMouseOver={event =>\n              _legendHighlighted(lineLegendText!)\n                ? _lineHover(item.point, event)\n                : _onBarHover(item.point, colorScale(item.y), event)\n            }\n            onMouseOut={_onBarLeave}\n            r={_getCircleVisibilityAndRadius(item.x, lineLegendText!).radius}\n            stroke={lineLegendColor}\n            fill={tokens.colorNeutralBackground1}\n            strokeWidth={3}\n            visibility={_getCircleVisibilityAndRadius(item.x, lineLegendText!).visibility}\n            onClick={item.point.lineData?.onClick}\n            // When no legend is highlighted: Line points are automatically displayed along with the bars\n            // at the same x-axis point in the stack callout. So to prevent an increase in focusable elements\n            // and avoid conveying duplicate info, make these line points non-focusable.\n            data-is-focusable={_legendHighlighted(lineLegendText!)}\n            ref={e => (circleRef.refElement = e)}\n            onFocus={event => _lineFocus(event, item.point, circleRef)}\n            onBlur={_handleChartMouseLeave}\n            tabIndex={_legendHighlighted(lineLegendText!) ? 0 : undefined}\n          />\n        );\n      },\n    );\n\n    return (\n      <>\n        {line}\n        {dots}\n      </>\n    );\n  }\n\n  function _getCircleVisibilityAndRadius(\n    xAxisPoint: string | number | Date,\n    legend: string,\n  ): { visibility: CircleVisbility; radius: number } {\n    if (!_noLegendHighlighted()) {\n      if (xAxisPoint === activeXdataPoint && _legendHighlighted(legend)) {\n        return { visibility: CircleVisbility.show, radius: 8 };\n      } else if (_legendHighlighted(legend)) {\n        // Don't hide the circle to keep it focusable. For more information,\n        // see https://fuzzbomb.github.io/accessibility-demos/visually-hidden-focus-test.html\n        return { visibility: CircleVisbility.show, radius: 0.3 };\n      } else {\n        return { visibility: CircleVisbility.hide, radius: 0 };\n      }\n    } else {\n      return {\n        visibility: activeXdataPoint === xAxisPoint ? CircleVisbility.show : CircleVisbility.hide,\n        radius: 8,\n      };\n    }\n  }\n\n  function _checkForLine(): boolean {\n    const { data } = props;\n    return data!.some((item: VerticalBarChartDataPoint) => item?.lineData?.y !== undefined);\n  }\n\n  function _adjustProps(): void {\n    _xAxisType =\n      props.data! && props.data!.length > 0\n        ? (getTypeOfAxis(props.data![0].x, true) as XAxisTypes)\n        : XAxisTypes.StringAxis;\n    _points = props.data || [];\n    _barWidth = getBarWidth(props.barWidth, props.maxBarWidth, undefined, props.mode);\n    const defaultColors: string[] = [\n      tokens.colorPaletteBlueForeground2,\n      tokens.colorPaletteCornflowerForeground2,\n      tokens.colorPaletteDarkGreenForeground2,\n      tokens.colorPaletteNavyForeground2,\n      tokens.colorPaletteDarkOrangeForeground2,\n    ];\n    _colors = props.colors || defaultColors;\n    _isHavingLine = _checkForLine();\n    _xAxisInnerPadding =\n      props.mode === 'histogram'\n        ? 0\n        : getScalePadding(\n            props.xAxisInnerPadding,\n            props.xAxisPadding,\n            _xAxisType === XAxisTypes.StringAxis ? 2 / 3 : 1 / 2,\n          );\n    _xAxisOuterPadding = getScalePadding(props.xAxisOuterPadding, props.xAxisPadding, 0);\n  }\n\n  function _getMargins(_margins: Margins) {\n    margins = _margins;\n  }\n\n  function _renderContentForBothLineAndBars(point: VerticalBarChartDataPoint): JSXElement {\n    // eslint-disable-next-line @typescript-eslint/no-shadow\n    const { YValueHover, hoverXValue } = _getCalloutContentForLineAndBar(point);\n    const content: JSXElement[] = YValueHover.map((item: YValueHover, index: number) => {\n      return (\n        <>\n          <ChartPopover\n            culture={props.culture}\n            clickPosition={clickPosition}\n            isPopoverOpen={isPopoverOpen}\n            legend={item.legend!}\n            {...(index === 0 && { XValue: `${hoverXValue || item.data}` })}\n            YValue={item.data || item.y}\n            color={item.color}\n            isCalloutForStack={false}\n          />\n        </>\n      );\n    });\n    return <>{content}</>;\n  }\n\n  function _renderContentForOnlyBars(_props: VerticalBarChartDataPoint): JSXElement {\n    return (\n      <>\n        <ChartPopover\n          XValue={_props.xAxisCalloutData || (_props.x as string)}\n          xCalloutValue={xCalloutValue}\n          yCalloutValue={yCalloutValue}\n          culture={props.culture}\n          clickPosition={clickPosition}\n          isPopoverOpen={isPopoverOpen}\n          legend={_props.legend!}\n          YValue={_props.yAxisCalloutData || _props.y}\n          color={!props.useSingleColor && _props.color ? _props.color : _createColors()(_props.y)}\n          isCalloutForStack={false}\n        />\n      </>\n    );\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-shadow\n  function _renderCallout(props?: VerticalBarChartDataPoint): JSXElement | null {\n    return props ? (_isHavingLine ? _renderContentForBothLineAndBars(props) : _renderContentForOnlyBars(props)) : null;\n  }\n\n  function _getCustomizedCallout() {\n    return props.onRenderCalloutPerDataPoint\n      ? props.onRenderCalloutPerDataPoint(dataPointCalloutProps, _renderCallout)\n      : null;\n  }\n\n  function _getGraphData(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    xScale: any,\n    yScale: NumericAxis,\n    containerHeight: number,\n    containerWidth: number,\n    xElement?: SVGElement | null,\n  ) {\n    return (_bars =\n      _xAxisType === XAxisTypes.NumericAxis\n        ? _createNumericBars(containerHeight, containerWidth, xElement!)\n        : _xAxisType === XAxisTypes.DateAxis\n        ? _createDateBars(containerHeight, containerWidth, xElement!)\n        : _createStringBars(containerHeight, containerWidth, xElement!));\n  }\n\n  function _createColors(): D3ScaleLinear<string, string> | ColorScale {\n    const increment = _colors.length <= 1 ? 1 : 1 / (_colors.length - 1);\n    const { useSingleColor = false } = props;\n    if (useSingleColor) {\n      return (_p?: number) => {\n        const { colors } = props;\n        return colors && colors.length > 0 ? colors[0] : tokens.colorPaletteBlueBackground2;\n      };\n    }\n    const domainValues = [];\n    for (let i = 0; i < _colors.length; i++) {\n      domainValues.push(increment * i * _yMax);\n    }\n    const colorScale = d3ScaleLinear<string>().domain(domainValues).range(_colors);\n    return colorScale;\n  }\n\n  function _refCallback(element: SVGRectElement, legendTitle: string): void {\n    _refArray.push({ index: legendTitle, refElement: element });\n  }\n\n  function _getCalloutContentForLineAndBar(point: VerticalBarChartDataPoint): {\n    YValueHover: YValueHover[];\n    hoverXValue: string | number | undefined;\n  } {\n    // eslint-disable-next-line @typescript-eslint/no-shadow\n    const YValueHover: YValueHover[] = [];\n    const { useSingleColor = false } = props;\n    const { data, lineLegendText, lineLegendColor = tokens.colorPaletteYellowBackground1 } = props;\n    const selectedPoint = data!.filter((xDataPoint: VerticalBarChartDataPoint) => xDataPoint.x === point.x);\n    // Check if the line legend is highlighted or no legend is highlighted\n    if (\n      _isHavingLine &&\n      selectedPoint[0].lineData?.y !== undefined &&\n      (_legendHighlighted(lineLegendText) || _noLegendHighlighted())\n    ) {\n      // Add callout data for the line\n      YValueHover.push({\n        legend: lineLegendText,\n        color: lineLegendColor,\n        y: selectedPoint[0].lineData?.y,\n        data: selectedPoint[0].lineData?.yAxisCalloutData,\n        yAxisCalloutData: selectedPoint[0].lineData?.yAxisCalloutData,\n      });\n    }\n    // Check if the bar legend is highlighted or no legend is highlighted\n    if (selectedLegends.includes(selectedPoint[0].legend!) || _noLegendHighlighted()) {\n      // Add callout data for the bar\n      YValueHover.push({\n        legend: selectedPoint[0].legend,\n        y: selectedPoint[0].y,\n        color: !useSingleColor\n          ? selectedPoint[0].color\n            ? selectedPoint[0].color\n            : _createColors()(selectedPoint[0].y)\n          : _createColors()(1),\n        data: selectedPoint[0].yAxisCalloutData,\n        yAxisCalloutData: selectedPoint[0].yAxisCalloutData,\n      });\n    }\n    // eslint-disable-next-line @typescript-eslint/no-shadow\n    const hoverXValue = point.x instanceof Date ? point.x.toLocaleString() : point.x.toString();\n    return {\n      YValueHover,\n      hoverXValue: point.xAxisCalloutData || hoverXValue,\n    };\n  }\n\n  function _onBarHover(\n    point: VerticalBarChartDataPoint,\n    // eslint-disable-next-line @typescript-eslint/no-shadow\n    color: string,\n    mouseEvent: React.MouseEvent<SVGElement>,\n  ): void {\n    mouseEvent.persist();\n\n    // eslint-disable-next-line @typescript-eslint/no-shadow\n    const { YValueHover, hoverXValue } = _getCalloutContentForLineAndBar(point);\n    if (_calloutAnchorPoint !== point) {\n      _calloutAnchorPoint = point;\n      /** Show the callout if highlighted bar is hovered and Hide it if unhighlighted bar is hovered */\n      updatePosition(mouseEvent.clientX, mouseEvent.clientY);\n      setPopoverOpen(_noLegendHighlighted() || _legendHighlighted(point.legend));\n      setDataForHoverCard(point.y);\n      setCalloutLegend(point.legend!);\n      setColor(point.color || color);\n      // To display callout value, if no callout value given, taking given point.x value as a string.\n      setXCalloutValue(\n        point.xAxisCalloutData || (point.x instanceof Date ? point.x.toLocaleDateString() : point.x.toString()),\n      );\n      setDataPointCalloutProps(point);\n      // Hovering over a bar should highlight corresponding line points only when no legend is selected\n      setActiveXDatapoint(_noLegendHighlighted() ? point.x : null);\n      setYValueHover(YValueHover);\n      setHoverXValue(hoverXValue);\n      setCalloutAccessibilityData(point.callOutAccessibilityData);\n    }\n  }\n\n  function _onBarLeave(): void {\n    /**/\n  }\n\n  function _handleChartMouseLeave(): void {\n    _calloutAnchorPoint = null;\n    setPopoverOpen(false);\n    setActiveXDatapoint(null);\n    setYValueHover([]);\n    setHoverXValue('');\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-shadow\n  function _onBarFocus(\n    event: React.FocusEvent<SVGRectElement, Element>,\n    point: VerticalBarChartDataPoint,\n    refArrayIndexNumber: number,\n    color: string,\n  ): void {\n    let x = 0;\n    let y = 0;\n\n    const targetRect = (event.target as SVGRectElement).getBoundingClientRect();\n    x = targetRect.left + targetRect.width / 2;\n    y = targetRect.top + targetRect.height / 2;\n    updatePosition(x, y);\n    // eslint-disable-next-line @typescript-eslint/no-shadow\n    const { YValueHover, hoverXValue } = _getCalloutContentForLineAndBar(point);\n    _refArray.forEach((obj: RefArrayData, index: number) => {\n      if (obj.index === point.legend! && refArrayIndexNumber === index) {\n        /** Show the callout if highlighted bar is hovered and Hide it if unhighlighted bar is hovered */\n        setPopoverOpen(_noLegendHighlighted() || _legendHighlighted(point.legend));\n        setDataForHoverCard(point.y);\n        setCalloutLegend(point.legend!);\n        setColor(point.color || color);\n        // To display callout value, if no callout value given, taking given point.x value as a string.\n        setXCalloutValue(\n          point.xAxisCalloutData || (point.x instanceof Date ? point.x.toLocaleDateString() : point.x.toString()),\n        );\n        setYCalloutValue(point.yAxisCalloutData!);\n        setDataPointCalloutProps(point);\n        // Hovering over a bar should highlight corresponding line points only when no legend is selected\n        setActiveXDatapoint(point.x);\n        setYValueHover(YValueHover);\n        setHoverXValue(hoverXValue);\n        setCalloutAccessibilityData(point.callOutAccessibilityData);\n      }\n    });\n  }\n\n  function _lineHover(point: VerticalBarChartDataPoint, mouseEvent: React.MouseEvent<SVGElement>) {\n    mouseEvent.persist();\n    _lineHoverFocus(point, mouseEvent);\n  }\n\n  function _lineFocus(\n    event: React.FocusEvent<SVGCircleElement, Element>,\n    point: VerticalBarChartDataPoint,\n    ref: { refElement: SVGCircleElement | null },\n  ) {\n    if (ref.refElement) {\n      _lineHoverFocus(point, ref.refElement);\n    }\n  }\n\n  function _lineHoverFocus(\n    point: VerticalBarChartDataPoint,\n    _refSelected: React.MouseEvent<SVGElement> | SVGCircleElement,\n  ) {\n    const { lineLegendText = '', lineLegendColor = tokens.colorPaletteYellowBackground1 } = props;\n    setPopoverOpen(_noLegendHighlighted() || _legendHighlighted(lineLegendText));\n    setCalloutLegend(lineLegendText);\n    setDataForHoverCard(point.lineData!.y);\n    setColor(lineLegendColor);\n    setXCalloutValue(\n      point.xAxisCalloutData || (point.x instanceof Date ? point.x.toLocaleDateString() : point.x.toString()),\n    );\n    setYCalloutValue(point.lineData!.yAxisCalloutData);\n    setDataPointCalloutProps(point);\n    setActiveXDatapoint(point.x);\n  }\n\n  function _getScales(\n    containerHeight: number,\n    containerWidth: number,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ): { xBarScale: any; yBarScale: any } {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    let xBarScale: any;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const yBarScale: any = d3ScaleLinear()\n      .domain([_yMin, _yMax])\n      .range([0, containerHeight - margins.bottom! - margins.top!]);\n\n    if (_xAxisType === XAxisTypes.NumericAxis) {\n      const xMax = d3Max(_points, (point: VerticalBarChartDataPoint) => point.x as number)!;\n      const xMin = d3Min(_points, (point: VerticalBarChartDataPoint) => point.x as number)!;\n      xBarScale = d3ScaleLinear()\n        .domain(_useRtl ? [xMax, xMin] : [xMin, xMax])\n        .range([margins.left! + _domainMargin, containerWidth - margins.right! - _domainMargin]);\n      if (!isScalePaddingDefined(props.xAxisInnerPadding, props.xAxisPadding) && props.mode !== 'histogram') {\n        xBarScale.nice();\n      }\n    } else if (_xAxisType === XAxisTypes.DateAxis) {\n      const sDate = d3Min(_points, (point: VerticalBarChartDataPoint) => point.x as Date)!;\n      const lDate = d3Max(_points, (point: VerticalBarChartDataPoint) => point.x as Date)!;\n      xBarScale = d3ScaleUtc()\n        .domain([sDate, lDate])\n        .range(\n          _useRtl\n            ? [containerWidth - margins.right! - _domainMargin, margins.left! + _domainMargin]\n            : [margins.left! + _domainMargin, containerWidth - margins.right! - _domainMargin],\n        );\n    } else {\n      xBarScale = d3ScaleBand()\n        .domain(_xAxisLabels)\n        .range(\n          _useRtl\n            ? [containerWidth - margins.right! - _domainMargin, margins.left! + _domainMargin]\n            : [margins.left! + _domainMargin, containerWidth - margins.right! - _domainMargin],\n        )\n        .paddingInner(_xAxisInnerPadding)\n        .paddingOuter(_xAxisOuterPadding);\n    }\n\n    return { xBarScale, yBarScale };\n  }\n\n  const classes = useVerticalBarChartStyles(props);\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  function _calculateMinBarHeight(yMin: number, yMax: number, yReferencePoint: number, yBarScale: any): number {\n    const maxHeightFromBaseline =\n      yMax < 0\n        ? Math.abs(yMin - yReferencePoint)\n        : Math.max(Math.abs(yMax - yReferencePoint), Math.abs(yMin - yReferencePoint));\n    return Math.ceil(yBarScale(maxHeightFromBaseline) / 100.0);\n  }\n\n  function _createNumericBars(containerHeight: number, containerWidth: number, xElement: SVGElement): JSXElement[] {\n    const { useSingleColor = false } = props;\n    const { xBarScale, yBarScale } = _getScales(containerHeight, containerWidth);\n    const colorScale = _createColors();\n    const yReferencePoint = _yMax < 0 ? _yMax : 0;\n    const bars = _points.map((point: VerticalBarChartDataPoint, index: number) => {\n      const shouldHighlight = _legendHighlighted(point.legend!) || _noLegendHighlighted() ? true : false;\n\n      let barHeight: number = yBarScale(point.y) - yBarScale(yReferencePoint);\n      const isHeightNegative = barHeight < 0;\n      barHeight = Math.abs(barHeight);\n      // Calculate threshold for minimum visible bar height\n      const minBarHeight = _calculateMinBarHeight(_yMin, _yMax, yReferencePoint, yBarScale);\n      let adjustedBarHeight = barHeight;\n\n      if (barHeight === 0) {\n        return <React.Fragment key={point.x as string}> </React.Fragment>;\n      }\n      // Adjust bar height if it's smaller than the threshold\n      else if (barHeight <= minBarHeight) {\n        adjustedBarHeight = minBarHeight;\n      }\n      const xPoint = xBarScale(point.x as number) - _barWidth / 2;\n      const yPoint =\n        containerHeight -\n        margins.bottom! -\n        (isHeightNegative ? -1 * adjustedBarHeight : adjustedBarHeight) -\n        yBarScale(yReferencePoint);\n      const baselineHeight = containerHeight - margins.bottom! - yBarScale(yReferencePoint);\n      return (\n        <g key={`${point.x}_${index}` as string}>\n          <rect\n            id={`${_vbcBarId}-${index}`}\n            x={xPoint}\n            y={!isHeightNegative ? yPoint : baselineHeight}\n            width={_barWidth}\n            height={adjustedBarHeight}\n            ref={(e: SVGRectElement) => {\n              _refCallback(e, point.legend!);\n            }}\n            onClick={point.onClick}\n            onMouseOver={event => _onBarHover(point, colorScale(point.y), event)}\n            aria-label={_getAriaLabel(point)}\n            role=\"img\"\n            onMouseLeave={_onBarLeave}\n            onFocus={event => _onBarFocus(event, point, index, colorScale(point.y))}\n            onBlur={_onBarLeave}\n            fill={point.color && !useSingleColor ? point.color : colorScale(point.y)}\n            tabIndex={!props.hideTooltip && shouldHighlight ? 0 : undefined}\n            opacity={shouldHighlight ? 1 : 0.1}\n            rx={props.roundCorners ? 3 : 0}\n          />\n          {_renderBarLabel(xPoint, yPoint, point.y, point.legend!, isHeightNegative)}\n        </g>\n      );\n    });\n    // Removing un wanted tooltip div from DOM, when prop not provided.\n    if (!props.showXAxisLablesTooltip) {\n      try {\n        // eslint-disable-next-line no-restricted-globals\n        document.getElementById(_tooltipId) && document.getElementById(_tooltipId)!.remove();\n        // eslint-disable-next-line no-empty\n      } catch (e) {}\n    }\n    // Used to display tooltip at x axis labels.\n    if (!props.wrapXAxisLables && props.showXAxisLablesTooltip) {\n      const xAxisElement = d3Select(xElement).call(xBarScale);\n      try {\n        // eslint-disable-next-line no-restricted-globals\n        document.getElementById(_tooltipId) && document.getElementById(_tooltipId)!.remove();\n        // eslint-disable-next-line no-empty\n      } catch (e) {}\n      const tooltipProps = {\n        tooltipCls: classes.tooltip!,\n        id: _tooltipId,\n        axis: xAxisElement,\n      };\n      xAxisElement && tooltipOfAxislabels(tooltipProps);\n    }\n    return bars;\n  }\n\n  function _createStringBars(containerHeight: number, containerWidth: number, xElement: SVGElement): JSXElement[] {\n    const { xBarScale, yBarScale } = _getScales(containerHeight, containerWidth);\n    const colorScale = _createColors();\n    const yReferencePoint = _yMax < 0 ? _yMax : 0;\n    const bars = _points.map((point: VerticalBarChartDataPoint, index: number) => {\n      const shouldHighlight = _legendHighlighted(point.legend!) || _noLegendHighlighted() ? true : false;\n      let barHeight: number = yBarScale(point.y) - yBarScale(yReferencePoint);\n      const isHeightNegative = barHeight < 0;\n      barHeight = Math.abs(barHeight);\n      // Calculate threshold for minimum visible bar height\n      const minBarHeight = _calculateMinBarHeight(_yMin, _yMax, yReferencePoint, yBarScale);\n      let adjustedBarHeight = barHeight;\n\n      if (barHeight === 0) {\n        return <React.Fragment key={point.x as string}> </React.Fragment>;\n      }\n      // Adjust bar height if it's smaller than the threshold\n      else if (barHeight <= minBarHeight) {\n        adjustedBarHeight = minBarHeight;\n      }\n      const xPoint = xBarScale(point.x);\n      const yPoint =\n        containerHeight -\n        margins.bottom! -\n        (isHeightNegative ? -1 * adjustedBarHeight : adjustedBarHeight) -\n        yBarScale(yReferencePoint);\n      const baselineHeight = containerHeight - margins.bottom! - yBarScale(yReferencePoint);\n      // Setting the bar width here is safe because there are no dependencies earlier in the code\n      // that rely on the width of bars in vertical bar charts with string x-axis.\n      _barWidth = getBarWidth(props.barWidth, props.maxBarWidth, xBarScale.bandwidth(), props.mode);\n      return (\n        <g\n          key={point.x instanceof Date ? `${point.x.getTime()}_${index}` : `${point.x}_${index}`}\n          transform={`translate(${0.5 * (xBarScale.bandwidth() - _barWidth)}, 0)`}\n        >\n          <rect\n            id={`${_vbcBarId}-${index}`}\n            x={xPoint}\n            y={!isHeightNegative ? yPoint : baselineHeight}\n            width={_barWidth}\n            height={adjustedBarHeight}\n            aria-label={_getAriaLabel(point)}\n            role=\"img\"\n            ref={(e: SVGRectElement) => {\n              _refCallback(e, point.legend!);\n            }}\n            onClick={point.onClick}\n            onMouseOver={event => _onBarHover(point, colorScale(point.y), event)}\n            onMouseLeave={_onBarLeave}\n            onBlur={_onBarLeave}\n            onFocus={event => _onBarFocus(event, point, index, colorScale(point.y))}\n            fill={point.color ? point.color : colorScale(point.y)}\n            tabIndex={!props.hideTooltip && shouldHighlight ? 0 : undefined}\n            rx={props.roundCorners ? 3 : 0}\n            opacity={shouldHighlight ? 1 : 0.1}\n          />\n          {_renderBarLabel(xPoint, yPoint, point.y, point.legend!, isHeightNegative)}\n        </g>\n      );\n    });\n\n    // Removing un wanted tooltip div from DOM, when prop not provided.\n    if (!props.showXAxisLablesTooltip) {\n      try {\n        // eslint-disable-next-line no-restricted-globals\n        document.getElementById(_tooltipId) && document.getElementById(_tooltipId)!.remove();\n        // eslint-disable-next-line no-empty\n      } catch (e) {}\n    }\n    // Used to display tooltip at x axis labels.\n    if (!props.wrapXAxisLables && props.showXAxisLablesTooltip) {\n      const xAxisElement = d3Select(xElement).call(xBarScale);\n      try {\n        // eslint-disable-next-line no-restricted-globals\n        document.getElementById(_tooltipId) && document.getElementById(_tooltipId)!.remove();\n        // eslint-disable-next-line no-empty\n      } catch (e) {}\n      const tooltipProps = {\n        tooltipCls: classes.tooltip!,\n        id: _tooltipId,\n        axis: xAxisElement,\n        showTooltip: props.showXAxisLablesTooltip,\n      };\n      xAxisElement && tooltipOfAxislabels(tooltipProps);\n    }\n    return bars;\n  }\n\n  function _createDateBars(containerHeight: number, containerWidth: number, xElement: SVGElement): JSXElement[] {\n    const { useSingleColor = false } = props;\n    const { xBarScale, yBarScale } = _getScales(containerHeight, containerWidth);\n    const colorScale = _createColors();\n    const yReferencePoint = _yMax < 0 ? _yMax : 0;\n    const bars = _points.map((point: VerticalBarChartDataPoint, index: number) => {\n      const shouldHighlight = _legendHighlighted(point.legend!) || _noLegendHighlighted() ? true : false;\n      let barHeight: number = yBarScale(point.y) - yBarScale(yReferencePoint);\n      const isHeightNegative = barHeight < 0;\n      barHeight = Math.abs(barHeight);\n      // Calculate threshold for minimum visible bar height\n      const minBarHeight = _calculateMinBarHeight(_yMin, _yMax, yReferencePoint, yBarScale);\n      let adjustedBarHeight = barHeight;\n\n      if (barHeight === 0) {\n        return <React.Fragment key={point.x as string}> </React.Fragment>;\n      }\n      // Adjust bar height if it's smaller than the threshold\n      else if (barHeight <= minBarHeight) {\n        adjustedBarHeight = minBarHeight;\n      }\n      const xPoint = xBarScale(point.x as number) - _barWidth / 2;\n      const yPoint =\n        containerHeight -\n        margins.bottom! -\n        (isHeightNegative ? -1 * adjustedBarHeight : adjustedBarHeight) -\n        yBarScale(yReferencePoint);\n      const baselineHeight = containerHeight - margins.bottom! - yBarScale(yReferencePoint);\n      return (\n        <g key={point.x instanceof Date ? `${point.x.getTime()}_${index}` : `${point.x}_${index}`}>\n          <rect\n            id={`${_vbcBarId}-${index}`}\n            x={xPoint}\n            className={classes.opacityChangeOnHover}\n            y={!isHeightNegative ? yPoint : baselineHeight}\n            width={_barWidth}\n            height={adjustedBarHeight}\n            ref={(e: SVGRectElement) => {\n              _refCallback(e, point.legend!);\n            }}\n            onClick={point.onClick}\n            onMouseOver={event => _onBarHover(point, colorScale(point.y), event)}\n            aria-label={_getAriaLabel(point)}\n            role=\"img\"\n            onMouseLeave={_onBarLeave}\n            onFocus={event => _onBarFocus(event, point, index, colorScale(point.y))}\n            onBlur={_onBarLeave}\n            fill={point.color && !useSingleColor ? point.color : colorScale(point.y)}\n            tabIndex={!props.hideTooltip && shouldHighlight ? 0 : undefined}\n            rx={props.roundCorners ? 3 : 0}\n            opacity={shouldHighlight ? 1 : 0.1}\n          />\n          {_renderBarLabel(xPoint, yPoint, point.y, point.legend!, isHeightNegative)}\n        </g>\n      );\n    });\n    // Removing un wanted tooltip div from DOM, when prop not provided.\n    if (!props.showXAxisLablesTooltip) {\n      try {\n        // eslint-disable-next-line no-restricted-globals\n        document.getElementById(_tooltipId) && document.getElementById(_tooltipId)!.remove();\n        // eslint-disable-next-line no-empty\n      } catch (e) {}\n    }\n    // Used to display tooltip at x axis labels.\n    if (!props.wrapXAxisLables && props.showXAxisLablesTooltip) {\n      const xAxisElement = d3Select(xElement).call(xBarScale);\n      try {\n        // eslint-disable-next-line no-restricted-globals\n        document.getElementById(_tooltipId) && document.getElementById(_tooltipId)!.remove();\n        // eslint-disable-next-line no-empty\n      } catch (e) {}\n      const tooltipProps = {\n        tooltipCls: classes.tooltip!,\n        id: _tooltipId,\n        axis: xAxisElement,\n      };\n      xAxisElement && tooltipOfAxislabels(tooltipProps);\n    }\n    return bars;\n  }\n\n  function _onLegendHover(legendTitle: string): void {\n    setActiveLegend(legendTitle);\n  }\n\n  function _onLegendLeave(): void {\n    setActiveLegend(undefined);\n  }\n\n  function _getLegendData(data: VerticalBarChartDataPoint[]): JSXElement {\n    const { useSingleColor } = props;\n    const { lineLegendText, lineLegendColor = tokens.colorPaletteYellowForeground1 } = props;\n    const actions: Legend[] = [];\n    const mapLegendToColor: Record<string, string> = {};\n    data.forEach((point: VerticalBarChartDataPoint, _index: number) => {\n      // eslint-disable-next-line @typescript-eslint/no-shadow\n      const color: string = !useSingleColor ? point.color! : _createColors()(1);\n      mapLegendToColor[point.legend!] = color;\n    });\n    Object.entries(mapLegendToColor).forEach(([legendTitle, color]) => {\n      // mapping data to the format Legends component needs\n      const legend: Legend = {\n        title: legendTitle,\n        color,\n        hoverAction: () => {\n          _handleChartMouseLeave();\n          _onLegendHover(legendTitle);\n        },\n        onMouseOutAction: () => {\n          _onLegendLeave();\n        },\n      };\n      actions.push(legend);\n    });\n    if (_isHavingLine && lineLegendText && lineLegendColor) {\n      const lineLegend: Legend = {\n        title: lineLegendText,\n        color: lineLegendColor,\n        hoverAction: () => {\n          _handleChartMouseLeave();\n          _onLegendHover(lineLegendText);\n        },\n        onMouseOutAction: () => {\n          _onLegendLeave();\n        },\n        isLineLegendInBarChart: true,\n      };\n      actions.unshift(lineLegend);\n    }\n    const legends = (\n      <Legends\n        legends={actions}\n        enabledWrapLines={props.enabledLegendsWrapLines}\n        overflowText={props.legendsOverflowText}\n        {...props.legendProps}\n        selectedLegends={selectedLegends}\n        onChange={_onLegendSelectionChange}\n        legendRef={_legendsRef}\n      />\n    );\n    return legends;\n  }\n\n  function _onLegendSelectionChange(\n    legendsSelected: string[],\n    event: React.MouseEvent<HTMLButtonElement>,\n    currentLegend?: Legend,\n  ): void {\n    if (props.legendProps?.canSelectMultipleLegends) {\n      setSelectedLegends(legendsSelected);\n    } else {\n      setSelectedLegends(legendsSelected.slice(-1));\n    }\n\n    if (props.legendProps?.onChange) {\n      props.legendProps.onChange(legendsSelected, event, currentLegend);\n    }\n  }\n\n  function _getAxisData(yAxisData: IAxisData) {\n    if (yAxisData && yAxisData.yAxisDomainValues.length) {\n      const { yAxisDomainValues: domainValue } = yAxisData;\n      _yMax = Math.max(domainValue[domainValue.length - 1], props.yMaxValue || 0);\n      _yMin = Math.min(domainValue[0], props.yMinValue || 0);\n    }\n  }\n\n  /**\n   * This function checks if the given legend is highlighted or not.\n   * A legend can be highlighted in 2 ways:\n   * 1. selection: if the user clicks on it\n   * 2. hovering: if there is no selected legend and the user hovers over it\n   */\n  function _legendHighlighted(legendTitle: string | undefined): boolean {\n    return _getHighlightedLegend().includes(legendTitle!);\n  }\n\n  /**\n   * This function checks if none of the legends is selected or hovered.\n   */\n  function _noLegendHighlighted(): boolean {\n    return _getHighlightedLegend().length === 0;\n  }\n\n  function _getHighlightedLegend() {\n    return selectedLegends.length > 0 ? selectedLegends : activeLegend ? [activeLegend] : [];\n  }\n\n  function _getAriaLabel(point: VerticalBarChartDataPoint): string {\n    const xValue = point.xAxisCalloutData\n      ? point.xAxisCalloutData\n      : point.x instanceof Date\n      ? point.x.toLocaleString()\n      : point.x;\n    const legend = point.legend;\n    const yValue = point.yAxisCalloutData || point.y;\n    const lineLegend = props.lineLegendText || 'Line';\n    const lineYValue = point.lineData?.yAxisCalloutData || point.lineData?.y;\n    return (\n      point.callOutAccessibilityData?.ariaLabel ||\n      `${xValue}. ` +\n        (legend ? `${legend}, ` : '') +\n        `${yValue}.` +\n        (typeof lineYValue !== 'undefined' ? ` ${lineLegend}, ${lineYValue}.` : '')\n    );\n  }\n\n  function _renderBarLabel(xPoint: number, yPoint: number, barValue: number, legend: string, isNegativeBar: boolean) {\n    if (props.hideLabels || _barWidth < 16 || !(_legendHighlighted(legend) || _noLegendHighlighted())) {\n      return null;\n    }\n\n    return (\n      <text\n        x={xPoint + _barWidth / 2}\n        y={isNegativeBar ? yPoint + 12 : yPoint - 6}\n        textAnchor=\"middle\"\n        className={classes.barLabel}\n        aria-hidden={true}\n        style={{ direction: 'ltr', unicodeBidi: 'isolate' }}\n      >\n        {typeof props.yAxisTickFormat === 'function'\n          ? props.yAxisTickFormat(barValue)\n          : formatScientificLimitWidth(barValue)}\n      </text>\n    );\n  }\n\n  function _getDomainMargins(containerWidth: number): Margins {\n    _domainMargin = MIN_DOMAIN_MARGIN;\n\n    const mapX: Record<string, number | string | Date> = {};\n    props.data?.forEach(point => {\n      if (point.x instanceof Date) {\n        mapX[point.x.getTime()] = point.x;\n      } else {\n        mapX[point.x] = point.x;\n      }\n    });\n    const uniqueX = Object.values(mapX);\n\n    /** Total width available to render the bars */\n    const totalWidth = calcTotalWidth(containerWidth, margins, MIN_DOMAIN_MARGIN);\n\n    if (_xAxisType === XAxisTypes.StringAxis) {\n      if (isScalePaddingDefined(props.xAxisOuterPadding, props.xAxisPadding)) {\n        // Setting the domain margin for string x-axis to 0 because the xAxisOuterPadding prop is now available\n        // to adjust the space before the first bar and after the last bar.\n        _domainMargin = 0;\n      } else if (props.barWidth !== 'auto' && props.mode !== 'histogram') {\n        // Update the bar width so that when CartesianChart rerenders,\n        // the following calculations don't use the previous bar width.\n        _barWidth = getBarWidth(props.barWidth, props.maxBarWidth);\n        /** Total width required to render the bars. Directly proportional to bar width */\n        const reqWidth = calcRequiredWidth(_barWidth, uniqueX.length, _xAxisInnerPadding);\n\n        if (totalWidth >= reqWidth) {\n          // Center align the chart by setting equal left and right margins for domain\n          _domainMargin = MIN_DOMAIN_MARGIN + (totalWidth - reqWidth) / 2;\n        }\n      } else if (['plotly', 'histogram'].includes(props.mode!) && uniqueX.length > 1) {\n        // Calculate the remaining width after rendering bars at their maximum allowable width\n        const bandwidth = calcBandwidth(totalWidth, uniqueX.length, _xAxisInnerPadding);\n        const barWidth = getBarWidth(props.barWidth, props.maxBarWidth, bandwidth, props.mode);\n        let reqWidth = calcRequiredWidth(barWidth, uniqueX.length, _xAxisInnerPadding);\n        const margin1 = (totalWidth - reqWidth) / 2;\n\n        let margin2 = Number.POSITIVE_INFINITY;\n        // This logic may introduce gaps between histogram bars when the barWidth is restricted.\n        // So disable it for histogram mode.\n        if (props.mode !== 'histogram') {\n          // Calculate the remaining width after accounting for the space required to render x-axis labels\n          const step = calculateLongestLabelWidth(uniqueX as string[]) + 20;\n          reqWidth = (uniqueX.length - _xAxisInnerPadding) * step;\n          margin2 = (totalWidth - reqWidth) / 2;\n        }\n\n        _domainMargin = MIN_DOMAIN_MARGIN + Math.max(0, Math.min(margin1, margin2));\n      }\n    } else {\n      if (props.mode === 'histogram') {\n        // Try center-aligning the bars to eliminate any gaps caused by a restricted barWidth.\n        // This only works if the bin centers are consistent across all legend groups; otherwise,\n        // the calculated domainMargin may be too small.\n        const barWidth = props.maxBarWidth!;\n        const reqWidth = calcRequiredWidth(barWidth, uniqueX.length, _xAxisInnerPadding);\n        _domainMargin += Math.max(0, (totalWidth - reqWidth) / 2);\n      }\n\n      // The histogram may appear distorted when bin centers/sizes vary across different legend groups.\n      // Currently, we calculate the appropriate bar width using the closest unique x-values to make\n      // the bars of the same legend group adjacent. But these x-values can come from different legend groups\n      // and result in misleading visuals. Even if we compute bar widths separately within each group,\n      // we still lack support for rendering bars with different widths and must use the minimum width,\n      // which can cause the same issue.\n      // Solution: Instead of estimating the appropriate bar width, render each bar to span the full range\n      // of its corresponding bin explicitly.\n      _barWidth = getBarWidth(\n        props.barWidth,\n        props.maxBarWidth,\n        calculateAppropriateBarWidth(\n          uniqueX as number[] | Date[],\n          calcTotalWidth(containerWidth, margins, _domainMargin),\n          _xAxisInnerPadding,\n        ),\n        props.mode,\n      );\n      _domainMargin += _barWidth / 2;\n      _domainMargin += _barWidth / 2;\n    }\n\n    return {\n      ...margins,\n      left: margins.left! + _domainMargin,\n      right: margins.right! + _domainMargin,\n    };\n  }\n\n  function _isChartEmpty(): boolean {\n    return _points.length === 0 || (_points.every(point => point.y === 0) && !_isHavingLine);\n  }\n\n  function _getOrderedXAxisLabels() {\n    if (_xAxisType !== XAxisTypes.StringAxis) {\n      return [];\n    }\n\n    return sortAxisCategories(_mapCategoryToValues(), props.xAxisCategoryOrder);\n  }\n\n  function _mapCategoryToValues() {\n    const categoryToValues: Record<string, number[]> = {};\n    _points.forEach(point => {\n      const xValue = point.x as string;\n      if (!categoryToValues[xValue]) {\n        categoryToValues[xValue] = [];\n      }\n      categoryToValues[xValue].push(point.y);\n      if (point.lineData) {\n        categoryToValues[xValue].push(point.lineData.y);\n      }\n    });\n    return categoryToValues;\n  }\n\n  function updatePosition(newX: number, newY: number) {\n    const threshold = 1; // Set a threshold for movement\n    const { x, y } = clickPosition;\n    // Calculate the distance moved\n    const distance = Math.sqrt(Math.pow(newX - x, 2) + Math.pow(newY - y, 2));\n    // Update the position only if the distance moved is greater than the threshold\n    if (distance > threshold) {\n      setClickPosition({ x: newX, y: newY });\n      setPopoverOpen(true);\n    }\n  }\n\n  _adjustProps();\n  _xAxisLabels = _getOrderedXAxisLabels();\n  _yMax = Math.max(d3Max(_points, (point: VerticalBarChartDataPoint) => point.y)!, props.yMaxValue || 0);\n  _yMin = Math.min(d3Min(_points, (point: VerticalBarChartDataPoint) => point.y)!, props.yMinValue || 0);\n  const legendBars: JSXElement = _getLegendData(_points);\n  const calloutProps = {\n    ...(_isHavingLine && {\n      YValueHover: hoveredYValues,\n      hoverXValue: hoverXValue,\n    }),\n    color: color,\n    legend: calloutLegend,\n    XValue: xCalloutValue,\n    YValue: yCalloutValue ? yCalloutValue : dataForHoverCard,\n    ...props.calloutProps,\n    ...getAccessibleDataObject(callOutAccessibilityData),\n    clickPosition: clickPosition,\n    isPopoverOpen: isPopoverOpen,\n    isCalloutForStack: _isHavingLine && (_noLegendHighlighted() || _getHighlightedLegend().length > 1),\n    culture: props.culture,\n    isCartesian: true,\n    customCallout: {\n      customizedCallout: _getCustomizedCallout() != null ? _getCustomizedCallout()! : undefined,\n      customCalloutProps: props.calloutPropsPerDataPoint\n        ? props.calloutPropsPerDataPoint(dataPointCalloutProps!)\n        : undefined,\n    },\n  };\n\n  const tickParams = {\n    tickValues: props.tickValues,\n    tickFormat: props.tickFormat,\n  };\n  return !_isChartEmpty() ? (\n    <CartesianChart\n      {...props}\n      points={_points}\n      chartType={ChartTypes.VerticalBarChart}\n      xAxisType={_xAxisType!}\n      createYAxis={createNumericYAxis}\n      calloutProps={calloutProps}\n      tickParams={tickParams}\n      {...(_isHavingLine && _noLegendHighlighted() && { isCalloutForStack: true })}\n      legendBars={legendBars}\n      datasetForXAxisDomain={_xAxisLabels}\n      barwidth={_barWidth}\n      createStringYAxis={createStringYAxis}\n      getmargins={_getMargins}\n      getMinMaxOfYAxis={findVerticalNumericMinMaxOfY}\n      getGraphData={_getGraphData}\n      getDomainNRangeValues={_getDomainNRangeValues}\n      getAxisData={_getAxisData}\n      onChartMouseLeave={_handleChartMouseLeave}\n      getDomainMargins={_getDomainMargins}\n      {...(_xAxisType! === XAxisTypes.StringAxis && {\n        xAxisInnerPadding: _xAxisInnerPadding,\n        xAxisOuterPadding: _xAxisOuterPadding,\n      })}\n      componentRef={cartesianChartRef}\n      showRoundOffXTickValues={\n        !isScalePaddingDefined(props.xAxisInnerPadding, props.xAxisPadding) && props.mode !== 'histogram'\n      }\n      /* eslint-disable react/jsx-no-bind */\n      // eslint-disable-next-line react/no-children-prop\n      children={(props: ChildProps) => {\n        return (\n          <>\n            <g>{_bars}</g>\n            {_isHavingLine && (\n              <g>\n                {_createLine(\n                  props.xScale!,\n                  props.yScalePrimary!,\n                  props.containerHeight,\n                  props.containerWidth,\n                  props.yScaleSecondary,\n                )}\n              </g>\n            )}\n          </>\n        );\n      }}\n    />\n  ) : (\n    <div id={_emptyChartId} role={'alert'} style={{ opacity: '0' }} aria-label={'Graph has no data to display'} />\n  );\n});\nVerticalBarChart.displayName = 'VerticalBarChart';\n"],"names":["React","useVerticalBarChartStyles","max","d3Max","min","d3Min","line","d3Line","select","d3Select","scaleLinear","d3ScaleLinear","scaleBand","d3ScaleBand","scaleUtc","d3ScaleUtc","useId","tokens","CartesianChart","Legends","ChartPopover","ChartTypes","getAccessibleDataObject","XAxisTypes","getTypeOfAxis","tooltipOfAxislabels","formatScientificLimitWidth","getBarWidth","getScalePadding","isScalePaddingDefined","calculateAppropriateBarWidth","useRtl","areArraysEqual","calculateLongestLabelWidth","findVerticalNumericMinMaxOfY","createNumericYAxis","domainRangeOfVerticalNumeric","domainRangeOfDateForAreaLineScatterVerticalBarCharts","domainRangeOfXStringAxis","createStringYAxis","calcTotalWidth","calcBandwidth","calcRequiredWidth","sortAxisCategories","toImage","CircleVisbility","MIN_DOMAIN_MARGIN","VerticalBarChart","forwardRef","_props","forwardedRef","props","xAxisCategoryOrder","maxBarWidth","_points","_barWidth","_colors","_refArray","margins","_useRtl","_bars","_xAxisLabels","_yMax","_yMin","_isHavingLine","_checkForLine","_tooltipId","_xAxisType","_calloutAnchorPoint","_domainMargin","_emptyChartId","_vbcLineId","_vbcPointId","_vbcBarId","_xAxisInnerPadding","_xAxisOuterPadding","cartesianChartRef","useRef","_legendsRef","color","setColor","useState","dataForHoverCard","setDataForHoverCard","activeLegend","setActiveLegend","undefined","xCalloutValue","setXCalloutValue","yCalloutValue","setYCalloutValue","activeXdataPoint","setActiveXDatapoint","hoveredYValues","setYValueHover","hoverXValue","setHoverXValue","calloutLegend","setCalloutLegend","callOutAccessibilityData","setCalloutAccessibilityData","dataPointCalloutProps","setDataPointCalloutProps","clickPosition","setClickPosition","x","y","isPopoverOpen","setPopoverOpen","selectedLegends","setSelectedLegends","legendProps","prevPropsRef","useImperativeHandle","componentRef","chartContainer","current","opts","toSVG","useEffect","prevProps","height","width","_adjustProps","_getDomainNRangeValues","points","chartType","isRTL","xAxisType","barWidth","tickValues","shiftX","domainNRangeValue","NumericAxis","DateAxis","_createLine","xScale","yScalePrimary","containerHeight","containerWidth","yScaleSecondary","isStringAxis","StringAxis","colorScale","_createColors","data","lineLegendColor","colorPaletteYellowBackground1","lineLegendText","lineData","forEach","item","index","push","useSecondaryYScale","point","linePath","d","bandwidth","shouldHighlight","_legendHighlighted","_noLegendHighlighted","lineBorderWidth","lineOptions","Number","parseFloat","toString","path","key","id","opacity","fill","strokeLinecap","strokeWidth","className","classes","lineBorder","stroke","dots","map","circleRef","refElement","circle","cx","cy","onMouseOver","event","_lineHover","_onBarHover","onMouseOut","_onBarLeave","r","_getCircleVisibilityAndRadius","radius","colorNeutralBackground1","visibility","onClick","data-is-focusable","ref","e","onFocus","_lineFocus","onBlur","_handleChartMouseLeave","tabIndex","xAxisPoint","legend","some","length","mode","defaultColors","colorPaletteBlueForeground2","colorPaletteCornflowerForeground2","colorPaletteDarkGreenForeground2","colorPaletteNavyForeground2","colorPaletteDarkOrangeForeground2","colors","xAxisInnerPadding","xAxisPadding","xAxisOuterPadding","_getMargins","_margins","_renderContentForBothLineAndBars","YValueHover","_getCalloutContentForLineAndBar","content","culture","XValue","YValue","isCalloutForStack","_renderContentForOnlyBars","xAxisCalloutData","yAxisCalloutData","useSingleColor","_renderCallout","_getCustomizedCallout","onRenderCalloutPerDataPoint","_getGraphData","yScale","xElement","_createNumericBars","_createDateBars","_createStringBars","increment","_p","colorPaletteBlueBackground2","domainValues","i","domain","range","_refCallback","element","legendTitle","selectedPoint","filter","xDataPoint","includes","Date","toLocaleString","mouseEvent","persist","updatePosition","clientX","clientY","toLocaleDateString","_onBarFocus","refArrayIndexNumber","targetRect","target","getBoundingClientRect","left","top","obj","_lineHoverFocus","_refSelected","_getScales","xBarScale","yBarScale","bottom","xMax","xMin","right","nice","sDate","lDate","paddingInner","paddingOuter","_calculateMinBarHeight","yMin","yMax","yReferencePoint","maxHeightFromBaseline","Math","abs","ceil","bars","barHeight","isHeightNegative","minBarHeight","adjustedBarHeight","Fragment","xPoint","yPoint","baselineHeight","g","rect","aria-label","_getAriaLabel","role","onMouseLeave","hideTooltip","rx","roundCorners","_renderBarLabel","showXAxisLablesTooltip","document","getElementById","remove","wrapXAxisLables","xAxisElement","call","tooltipProps","tooltipCls","tooltip","axis","getTime","transform","showTooltip","opacityChangeOnHover","_onLegendHover","_onLegendLeave","_getLegendData","colorPaletteYellowForeground1","actions","mapLegendToColor","_index","Object","entries","title","hoverAction","onMouseOutAction","lineLegend","isLineLegendInBarChart","unshift","legends","enabledWrapLines","enabledLegendsWrapLines","overflowText","legendsOverflowText","onChange","_onLegendSelectionChange","legendRef","legendsSelected","currentLegend","canSelectMultipleLegends","slice","_getAxisData","yAxisData","yAxisDomainValues","domainValue","yMaxValue","yMinValue","_getHighlightedLegend","xValue","yValue","lineYValue","ariaLabel","barValue","isNegativeBar","hideLabels","text","textAnchor","barLabel","aria-hidden","style","direction","unicodeBidi","yAxisTickFormat","_getDomainMargins","mapX","uniqueX","values","totalWidth","reqWidth","margin1","margin2","POSITIVE_INFINITY","step","_isChartEmpty","every","_getOrderedXAxisLabels","_mapCategoryToValues","categoryToValues","newX","newY","threshold","distance","sqrt","pow","legendBars","calloutProps","isCartesian","customCallout","customizedCallout","customCalloutProps","calloutPropsPerDataPoint","tickParams","tickFormat","createYAxis","datasetForXAxisDomain","barwidth","getmargins","getMinMaxOfYAxis","getGraphData","getDomainNRangeValues","getAxisData","onChartMouseLeave","getDomainMargins","showRoundOffXTickValues","children","div","displayName"],"mappings":"AAAA;AAEA,YAAYA,WAAW,QAAQ;AAC/B,SAASC,yBAAyB,QAAQ,qCAAqC;AAC/E,SAASC,OAAOC,KAAK,EAAEC,OAAOC,KAAK,QAAQ,WAAW;AACtD,SAASC,QAAQC,MAAM,QAAQ,WAAW;AAC1C,SAASC,UAAUC,QAAQ,QAAQ,eAAe;AAClD,SACEC,eAAeC,aAAa,EAE5BC,aAAaC,WAAW,EACxBC,YAAYC,UAAU,QACjB,WAAW;AAClB,SAASC,KAAK,QAAQ,4BAA4B;AAElD,SAASC,MAAM,QAAQ,wBAAwB;AAC/C,SAEEC,cAAc,EAMdC,OAAO,EAGPC,YAAY,QAKP,cAAc;AACrB,SACEC,UAAU,EAEVC,uBAAuB,EACvBC,UAAU,EAEVC,aAAa,EACbC,mBAAmB,EACnBC,0BAA0B,EAC1BC,WAAW,EACXC,eAAe,EACfC,qBAAqB,EACrBC,4BAA4B,EAC5BC,MAAM,EACNC,cAAc,EACdC,0BAA0B,EAC1BC,4BAA4B,EAC5BC,kBAAkB,EAElBC,4BAA4B,EAC5BC,oDAAoD,EACpDC,wBAAwB,EACxBC,iBAAiB,EACjBC,cAAc,EACdC,aAAa,EACbC,iBAAiB,EACjBC,kBAAkB,QACb,wBAAwB;AAC/B,SAASC,OAAO,QAAQ,qCAAqC;AAE7D,IAAA,AAAKC,yCAAAA;;;WAAAA;EAAAA;AAKL,MAAMC,oBAAoB;AAE1B,kGAAkG;AAClG;;;CAGC,GACD,OAAO,MAAMC,iCAAmE/C,MAAMgD,UAAU,CAG9F,CAACC,QAAQC;QA4C8DC;IA3CvE,MAAMA,QAA+B;QACnCC,oBAAoB;QACpBC,aAAa;QACb,GAAGJ,MAAM;IACX;IACA,IAAIK,UAAuC,EAAE;IAC7C,IAAIC,YAAoB;IACxB,IAAIC;IACJ,MAAMC,YAA4B,EAAE;IACpC,IAAIC;IACJ,MAAMC,UAAmB5B;IACzB,IAAI6B;IACJ,IAAIC;IACJ,IAAIC;IACJ,IAAIC;IACJ,IAAIC,gBAAyBC;IAC7B,MAAMC,aAAqBlD,MAAM;IACjC,IAAImD;IACJ,IAAIC;IACJ,IAAIC;IACJ,MAAMC,gBAAwBtD,MAAM;IACpC,MAAMuD,aAAqBvD,MAAM;IACjC,MAAMwD,cAAsBxD,MAAM;IAClC,MAAMyD,YAAoBzD,MAAM;IAChC,IAAI0D,qBAA6B;IACjC,IAAIC,qBAA6B;IAEjC,MAAMC,oBAAoB5E,MAAM6E,MAAM,CAAQ;IAC9C,MAAMC,cAAc9E,MAAM6E,MAAM,CAAkB;IAElD,MAAM,CAACE,OAAOC,SAAS,GAAGhF,MAAMiF,QAAQ,CAAS;IACjD,MAAM,CAACC,kBAAkBC,oBAAoB,GAAGnF,MAAMiF,QAAQ,CAAS;IACvE,MAAM,CAACG,cAAcC,gBAAgB,GAAGrF,MAAMiF,QAAQ,CAAqBK;IAC3E,MAAM,CAACC,eAAeC,iBAAiB,GAAGxF,MAAMiF,QAAQ,CAAqB;IAC7E,MAAM,CAACQ,eAAeC,iBAAiB,GAAG1F,MAAMiF,QAAQ,CAAqB;IAC7E,MAAM,CAACU,kBAAkBC,oBAAoB,GAAG5F,MAAMiF,QAAQ,CAAgC;IAC9F,MAAM,CAACY,gBAAgBC,eAAe,GAAG9F,MAAMiF,QAAQ;IACvD,MAAM,CAACc,aAAaC,eAAe,GAAGhG,MAAMiF,QAAQ,CAA8B;IAClF,MAAM,CAACgB,eAAeC,iBAAiB,GAAGlG,MAAMiF,QAAQ,CAAS;IACjE,MAAM,CAACkB,0BAA0BC,4BAA4B,GAAGpG,MAAMiF,QAAQ;IAC9E,MAAM,CAACoB,uBAAuBC,yBAAyB,GAAGtG,MAAMiF,QAAQ;IACxE,MAAM,CAACsB,eAAeC,iBAAiB,GAAGxG,MAAMiF,QAAQ,CAAC;QAAEwB,GAAG;QAAGC,GAAG;IAAE;IACtE,MAAM,CAACC,eAAeC,eAAe,GAAG5G,MAAMiF,QAAQ,CAAC;IACvD,MAAM,CAAC4B,iBAAiBC,mBAAmB,GAAG9G,MAAMiF,QAAQ,CAAW9B,EAAAA,qBAAAA,MAAM4D,WAAW,cAAjB5D,yCAAAA,mBAAmB0D,eAAe,KAAI,EAAE;IAC/G,MAAMG,eAAehH,MAAM6E,MAAM,CAA+B;IAEhE7E,MAAMiH,mBAAmB,CACvB9D,MAAM+D,YAAY,EAClB;YACkBtC;YAAAA;eADX;YACLuC,gBAAgBvC,CAAAA,6CAAAA,6BAAAA,kBAAkBwC,OAAO,cAAzBxC,iDAAAA,2BAA2BuC,cAAc,cAAzCvC,uDAAAA,4CAA6C;YAC7DhC,SAAS,CAACyE;oBACOzC,4BAA2CE;gBAA1D,OAAOlC,SAAQgC,6BAAAA,kBAAkBwC,OAAO,cAAzBxC,iDAAAA,2BAA2BuC,cAAc,GAAErC,sBAAAA,YAAYsC,OAAO,cAAnBtC,0CAAAA,oBAAqBwC,KAAK,EAAE3D,SAAS0D;YACjG;QACF;OACA,EAAE;IAGJrH,MAAMuH,SAAS,CAAC;QACd,IAAIP,aAAaI,OAAO,EAAE;gBAEJI,wBAAwCrE;YAD5D,MAAMqE,YAAYR,aAAaI,OAAO;YACtC,IAAI,CAACpF,gBAAewF,yBAAAA,UAAUT,WAAW,cAArBS,6CAAAA,uBAAuBX,eAAe,GAAE1D,qBAAAA,MAAM4D,WAAW,cAAjB5D,yCAAAA,mBAAmB0D,eAAe,GAAG;oBAC5E1D;gBAAnB2D,mBAAmB3D,EAAAA,sBAAAA,MAAM4D,WAAW,cAAjB5D,0CAAAA,oBAAmB0D,eAAe,KAAI,EAAE;YAC7D;YACA,IAAIW,UAAUC,MAAM,KAAKtE,MAAMsE,MAAM,IAAID,UAAUE,KAAK,KAAKvE,MAAMuE,KAAK,EAAE;gBACxEC;YACF;QACF;QACAX,aAAaI,OAAO,GAAGjE;IACzB,GAAG;QAACA;QAAO6D;QAAcW;KAAa;IAEtC,SAASC,uBACPC,MAAmB,EACnBnE,OAAgB,EAChBgE,KAAa,EACbI,SAAqB,EACrBC,KAAc,EACdC,SAAqB,EACrBC,QAAgB,EAChBC,UAAyC,EACzCC,MAAc;QAEd,IAAIC;QACJ,IAAIJ,cAAczG,WAAW8G,WAAW,EAAE;YACxCD,oBAAoBhG,6BAA6ByF,QAAQnE,SAASgE,OAAOK,OAAOE;QAClF,OAAO,IAAID,cAAczG,WAAW+G,QAAQ,EAAE;YAC5CF,oBAAoB/F,qDAClBwF,QACAnE,SACAgE,OACAK,OACAG,YACAJ,WACAG;QAEJ,OAAO;YACLG,oBAAoB9F,yBAAyBoB,SAASgE,OAAOK;QAC/D;QACA,OAAOK;IACT;IAEA,SAASG,YACP,8DAA8D;IAC9DC,MAAW,EACX,8DAA8D;IAC9DC,aAAkB,EAClBC,kBAA0B,CAAC,EAC3BC,iBAAyB,CAAC,EAC1B,8DAA8D;IAC9DC,eAAqB;YA0BGzF;QAxBxB,MAAM0F,eAAe1E,eAAe5C,WAAWuH,UAAU;QACzD,MAAMC,aAAaC;QACnB,MAAM,EAAEC,IAAI,EAAEC,kBAAkBjI,OAAOkI,6BAA6B,EAAEC,cAAc,EAAE,GAAGjG;QACzF,8DAA8D;QAC9D,MAAMkG,WAAuB,EAAE;QAC/B,MAAM/I,OAAqB,EAAE;QAC7B2I,QACEA,KAAKK,OAAO,CAAC,CAACC,MAAiCC;YAC7C,IAAID,KAAKF,QAAQ,IAAIE,KAAKF,QAAQ,CAAC3C,CAAC,EAAE;oBAId6C;gBAHtBF,SAASI,IAAI,CAAC;oBACZhD,GAAG8C,KAAK9C,CAAC;oBACTC,GAAG6C,KAAKF,QAAQ,CAAE3C,CAAC;oBACnBgD,oBAAoBH,CAAAA,oCAAAA,KAAKF,QAAQ,CAAEK,kBAAkB,cAAjCH,+CAAAA,oCAAqC;oBACzDI,OAAOJ;oBACPC;gBACF;YACF;QACF;QACF,MAAMI,WAAWrJ,QACf,8DAA8D;SAC7DkG,CAAC,CAAC,CAACoD,IAAYhB,eAAeL,OAAOqB,EAAEpD,CAAC,IAAI,MAAM+B,OAAOsB,SAAS,KAAKtB,OAAOqB,EAAEpD,CAAC,EAClF,8DAA8D;SAC7DC,CAAC,CAAC,CAACmD,IAAYA,EAAEH,kBAAkB,IAAId,kBAAkBA,gBAAgBiB,EAAEnD,CAAC,IAAI+B,cAAcoB,EAAEnD,CAAC;QACpG,MAAMqD,kBAAkBC,mBAAmBZ,mBAAoBa,yBAAyB,OAAO;QAC/F,MAAMC,kBAAkB/G,EAAAA,qBAAAA,MAAMgH,WAAW,cAAjBhH,yCAAAA,mBAAmB+G,eAAe,IACtDE,OAAOC,UAAU,CAAClH,MAAMgH,WAAW,CAAED,eAAe,CAAEI,QAAQ,MAC9D;QAEJ,IAAIJ,kBAAkB,GAAG;YACvB5J,KAAKmJ,IAAI,eACP,oBAACc;gBACCC,KAAKjG;gBACLkG,IAAIlG;gBACJmG,SAASX,kBAAkB,IAAI;gBAC/BF,GAAGD,SAASP;gBACZsB,MAAK;gBACLC,eAAc;gBACdC,aAAa,IAAIX,kBAAkB;gBACnCY,WAAWC,QAAQC,UAAU;;QAGnC;QACA1K,KAAKmJ,IAAI,eACP,oBAACc;YACCC,KAAKjG;YACLkG,IAAIlG;YACJmG,SAASX,kBAAkB,IAAI;YAC/BF,GAAGD,SAASP;YACZsB,MAAK;YACLC,eAAc;YACdC,aAAa;YACbI,QAAQ/B;;QAIZ,MAAMgC,OAA0B7B,SAAS8B,GAAG,CAC1C,CACE5B,MAOAC;gBAqBaD;YAnBb,8GAA8G;YAC9G,MAAM6B,YAAqD;gBAAEC,YAAY;YAAK;YAC9E,qBACE,oBAACC;gBACCd,KAAKhB;gBACLiB,IAAI,GAAGjG,YAAY,CAAC,EAAEgF,OAAO;gBAC7B+B,IAAI1C,eAAeL,OAAOe,KAAK9C,CAAC,IAAI,MAAM+B,OAAOsB,SAAS,KAAKtB,OAAOe,KAAK9C,CAAC;gBAC5E+E,IAAIjC,KAAKG,kBAAkB,IAAId,kBAAkBA,gBAAgBW,KAAK7C,CAAC,IAAI+B,cAAcc,KAAK7C,CAAC;gBAC/F+E,aAAaC,CAAAA,QACX1B,mBAAmBZ,kBACfuC,WAAWpC,KAAKI,KAAK,EAAE+B,SACvBE,YAAYrC,KAAKI,KAAK,EAAEZ,WAAWQ,KAAK7C,CAAC,GAAGgF;gBAElDG,YAAYC;gBACZC,GAAGC,8BAA8BzC,KAAK9C,CAAC,EAAE2C,gBAAiB6C,MAAM;gBAChEhB,QAAQ/B;gBACRyB,MAAM1J,OAAOiL,uBAAuB;gBACpCrB,aAAa;gBACbsB,YAAYH,8BAA8BzC,KAAK9C,CAAC,EAAE2C,gBAAiB+C,UAAU;gBAC7EC,OAAO,GAAE7C,uBAAAA,KAAKI,KAAK,CAACN,QAAQ,cAAnBE,2CAAAA,qBAAqB6C,OAAO;gBACrC,6FAA6F;gBAC7F,iGAAiG;gBACjG,4EAA4E;gBAC5EC,qBAAmBrC,mBAAmBZ;gBACtCkD,KAAKC,CAAAA,IAAMnB,UAAUC,UAAU,GAAGkB;gBAClCC,SAASd,CAAAA,QAASe,WAAWf,OAAOnC,KAAKI,KAAK,EAAEyB;gBAChDsB,QAAQC;gBACRC,UAAU5C,mBAAmBZ,kBAAmB,IAAI9D;;QAG1D;QAGF,qBACE,0CACGhF,MACA4K;IAGP;IAEA,SAASc,8BACPa,UAAkC,EAClCC,MAAc;QAEd,IAAI,CAAC7C,wBAAwB;YAC3B,IAAI4C,eAAelH,oBAAoBqE,mBAAmB8C,SAAS;gBACjE,OAAO;oBAAEX,UAAU;oBAAwBF,QAAQ;gBAAE;YACvD,OAAO,IAAIjC,mBAAmB8C,SAAS;gBACrC,oEAAoE;gBACpE,qFAAqF;gBACrF,OAAO;oBAAEX,UAAU;oBAAwBF,QAAQ;gBAAI;YACzD,OAAO;gBACL,OAAO;oBAAEE,UAAU;oBAAwBF,QAAQ;gBAAE;YACvD;QACF,OAAO;YACL,OAAO;gBACLE,YAAYxG,qBAAqBkH;gBACjCZ,QAAQ;YACV;QACF;IACF;IAEA,SAAShI;QACP,MAAM,EAAEgF,IAAI,EAAE,GAAG9F;QACjB,OAAO8F,KAAM8D,IAAI,CAAC,CAACxD;gBAAoCA;mBAAAA,CAAAA,iBAAAA,4BAAAA,iBAAAA,KAAMF,QAAQ,cAAdE,qCAAAA,eAAgB7C,CAAC,MAAKpB;;IAC/E;IAEA,SAASqC;QACPxD,aACEhB,MAAM8F,IAAI,IAAK9F,MAAM8F,IAAI,CAAE+D,MAAM,GAAG,IAC/BxL,cAAc2B,MAAM8F,IAAI,AAAC,CAAC,EAAE,CAACxC,CAAC,EAAE,QACjClF,WAAWuH,UAAU;QAC3BxF,UAAUH,MAAM8F,IAAI,IAAI,EAAE;QAC1B1F,YAAY5B,YAAYwB,MAAM8E,QAAQ,EAAE9E,MAAME,WAAW,EAAEiC,WAAWnC,MAAM8J,IAAI;QAChF,MAAMC,gBAA0B;YAC9BjM,OAAOkM,2BAA2B;YAClClM,OAAOmM,iCAAiC;YACxCnM,OAAOoM,gCAAgC;YACvCpM,OAAOqM,2BAA2B;YAClCrM,OAAOsM,iCAAiC;SACzC;QACD/J,UAAUL,MAAMqK,MAAM,IAAIN;QAC1BlJ,gBAAgBC;QAChBS,qBACEvB,MAAM8J,IAAI,KAAK,cACX,IACArL,gBACEuB,MAAMsK,iBAAiB,EACvBtK,MAAMuK,YAAY,EAClBvJ,eAAe5C,WAAWuH,UAAU,GAAG,IAAI,IAAI,IAAI;QAE3DnE,qBAAqB/C,gBAAgBuB,MAAMwK,iBAAiB,EAAExK,MAAMuK,YAAY,EAAE;IACpF;IAEA,SAASE,YAAYC,QAAiB;QACpCnK,UAAUmK;IACZ;IAEA,SAASC,iCAAiCnE,KAAgC;QACxE,wDAAwD;QACxD,MAAM,EAAEoE,WAAW,EAAEhI,WAAW,EAAE,GAAGiI,gCAAgCrE;QACrE,MAAMsE,UAAwBF,YAAY5C,GAAG,CAAC,CAAC5B,MAAmBC;YAChE,qBACE,wDACE,oBAACpI;gBACC8M,SAAS/K,MAAM+K,OAAO;gBACtB3H,eAAeA;gBACfI,eAAeA;gBACfmG,QAAQvD,KAAKuD,MAAM;gBAClB,GAAItD,UAAU,KAAK;oBAAE2E,QAAQ,GAAGpI,eAAewD,KAAKN,IAAI,EAAE;gBAAC,CAAC;gBAC7DmF,QAAQ7E,KAAKN,IAAI,IAAIM,KAAK7C,CAAC;gBAC3B3B,OAAOwE,KAAKxE,KAAK;gBACjBsJ,mBAAmB;;QAI3B;QACA,qBAAO,0CAAGJ;IACZ;IAEA,SAASK,0BAA0BrL,MAAiC;QAClE,qBACE,wDACE,oBAAC7B;YACC+M,QAAQlL,OAAOsL,gBAAgB,IAAKtL,OAAOwD,CAAC;YAC5ClB,eAAeA;YACfE,eAAeA;YACfyI,SAAS/K,MAAM+K,OAAO;YACtB3H,eAAeA;YACfI,eAAeA;YACfmG,QAAQ7J,OAAO6J,MAAM;YACrBsB,QAAQnL,OAAOuL,gBAAgB,IAAIvL,OAAOyD,CAAC;YAC3C3B,OAAO,CAAC5B,MAAMsL,cAAc,IAAIxL,OAAO8B,KAAK,GAAG9B,OAAO8B,KAAK,GAAGiE,gBAAgB/F,OAAOyD,CAAC;YACtF2H,mBAAmB;;IAI3B;IAEA,wDAAwD;IACxD,SAASK,eAAevL,KAAiC;QACvD,OAAOA,QAASa,gBAAgB8J,iCAAiC3K,SAASmL,0BAA0BnL,SAAU;IAChH;IAEA,SAASwL;QACP,OAAOxL,MAAMyL,2BAA2B,GACpCzL,MAAMyL,2BAA2B,CAACvI,uBAAuBqI,kBACzD;IACN;IAEA,SAASG,cACP,8DAA8D;IAC9DrG,MAAW,EACXsG,MAAmB,EACnBpG,eAAuB,EACvBC,cAAsB,EACtBoG,QAA4B;QAE5B,OAAQnL,QACNO,eAAe5C,WAAW8G,WAAW,GACjC2G,mBAAmBtG,iBAAiBC,gBAAgBoG,YACpD5K,eAAe5C,WAAW+G,QAAQ,GAClC2G,gBAAgBvG,iBAAiBC,gBAAgBoG,YACjDG,kBAAkBxG,iBAAiBC,gBAAgBoG;IAC3D;IAEA,SAAS/F;QACP,MAAMmG,YAAY3L,QAAQwJ,MAAM,IAAI,IAAI,IAAI,IAAKxJ,CAAAA,QAAQwJ,MAAM,GAAG,CAAA;QAClE,MAAM,EAAEyB,iBAAiB,KAAK,EAAE,GAAGtL;QACnC,IAAIsL,gBAAgB;YAClB,OAAO,CAACW;gBACN,MAAM,EAAE5B,MAAM,EAAE,GAAGrK;gBACnB,OAAOqK,UAAUA,OAAOR,MAAM,GAAG,IAAIQ,MAAM,CAAC,EAAE,GAAGvM,OAAOoO,2BAA2B;YACrF;QACF;QACA,MAAMC,eAAe,EAAE;QACvB,IAAK,IAAIC,IAAI,GAAGA,IAAI/L,QAAQwJ,MAAM,EAAEuC,IAAK;YACvCD,aAAa7F,IAAI,CAAC0F,YAAYI,IAAIzL;QACpC;QACA,MAAMiF,aAAapI,gBAAwB6O,MAAM,CAACF,cAAcG,KAAK,CAACjM;QACtE,OAAOuF;IACT;IAEA,SAAS2G,aAAaC,OAAuB,EAAEC,WAAmB;QAChEnM,UAAUgG,IAAI,CAAC;YAAED,OAAOoG;YAAavE,YAAYsE;QAAQ;IAC3D;IAEA,SAAS3B,gCAAgCrE,KAAgC;YAYrEkG;QARF,wDAAwD;QACxD,MAAM9B,cAA6B,EAAE;QACrC,MAAM,EAAEU,iBAAiB,KAAK,EAAE,GAAGtL;QACnC,MAAM,EAAE8F,IAAI,EAAEG,cAAc,EAAEF,kBAAkBjI,OAAOkI,6BAA6B,EAAE,GAAGhG;QACzF,MAAM0M,gBAAgB5G,KAAM6G,MAAM,CAAC,CAACC,aAA0CA,WAAWtJ,CAAC,KAAKkD,MAAMlD,CAAC;QACtG,sEAAsE;QACtE,IACEzC,iBACA6L,EAAAA,2BAAAA,aAAa,CAAC,EAAE,CAACxG,QAAQ,cAAzBwG,+CAAAA,yBAA2BnJ,CAAC,MAAKpB,aAChC0E,CAAAA,mBAAmBZ,mBAAmBa,sBAAqB,GAC5D;gBAKK4F,2BACGA,2BACYA;YANpB,gCAAgC;YAChC9B,YAAYtE,IAAI,CAAC;gBACfqD,QAAQ1D;gBACRrE,OAAOmE;gBACPxC,CAAC,GAAEmJ,4BAAAA,aAAa,CAAC,EAAE,CAACxG,QAAQ,cAAzBwG,gDAAAA,0BAA2BnJ,CAAC;gBAC/BuC,IAAI,GAAE4G,4BAAAA,aAAa,CAAC,EAAE,CAACxG,QAAQ,cAAzBwG,gDAAAA,0BAA2BrB,gBAAgB;gBACjDA,gBAAgB,GAAEqB,4BAAAA,aAAa,CAAC,EAAE,CAACxG,QAAQ,cAAzBwG,gDAAAA,0BAA2BrB,gBAAgB;YAC/D;QACF;QACA,qEAAqE;QACrE,IAAI3H,gBAAgBmJ,QAAQ,CAACH,aAAa,CAAC,EAAE,CAAC/C,MAAM,KAAM7C,wBAAwB;YAChF,+BAA+B;YAC/B8D,YAAYtE,IAAI,CAAC;gBACfqD,QAAQ+C,aAAa,CAAC,EAAE,CAAC/C,MAAM;gBAC/BpG,GAAGmJ,aAAa,CAAC,EAAE,CAACnJ,CAAC;gBACrB3B,OAAO,CAAC0J,iBACJoB,aAAa,CAAC,EAAE,CAAC9K,KAAK,GACpB8K,aAAa,CAAC,EAAE,CAAC9K,KAAK,GACtBiE,gBAAgB6G,aAAa,CAAC,EAAE,CAACnJ,CAAC,IACpCsC,gBAAgB;gBACpBC,MAAM4G,aAAa,CAAC,EAAE,CAACrB,gBAAgB;gBACvCA,kBAAkBqB,aAAa,CAAC,EAAE,CAACrB,gBAAgB;YACrD;QACF;QACA,wDAAwD;QACxD,MAAMzI,cAAc4D,MAAMlD,CAAC,YAAYwJ,OAAOtG,MAAMlD,CAAC,CAACyJ,cAAc,KAAKvG,MAAMlD,CAAC,CAAC6D,QAAQ;QACzF,OAAO;YACLyD;YACAhI,aAAa4D,MAAM4E,gBAAgB,IAAIxI;QACzC;IACF;IAEA,SAAS6F,YACPjC,KAAgC,EAChC,wDAAwD;IACxD5E,KAAa,EACboL,UAAwC;QAExCA,WAAWC,OAAO;QAElB,wDAAwD;QACxD,MAAM,EAAErC,WAAW,EAAEhI,WAAW,EAAE,GAAGiI,gCAAgCrE;QACrE,IAAIvF,wBAAwBuF,OAAO;YACjCvF,sBAAsBuF;YACtB,+FAA+F,GAC/F0G,eAAeF,WAAWG,OAAO,EAAEH,WAAWI,OAAO;YACrD3J,eAAeqD,0BAA0BD,mBAAmBL,MAAMmD,MAAM;YACxE3H,oBAAoBwE,MAAMjD,CAAC;YAC3BR,iBAAiByD,MAAMmD,MAAM;YAC7B9H,SAAS2E,MAAM5E,KAAK,IAAIA;YACxB,+FAA+F;YAC/FS,iBACEmE,MAAM4E,gBAAgB,IAAK5E,CAAAA,MAAMlD,CAAC,YAAYwJ,OAAOtG,MAAMlD,CAAC,CAAC+J,kBAAkB,KAAK7G,MAAMlD,CAAC,CAAC6D,QAAQ,EAAC;YAEvGhE,yBAAyBqD;YACzB,iGAAiG;YACjG/D,oBAAoBqE,yBAAyBN,MAAMlD,CAAC,GAAG;YACvDX,eAAeiI;YACf/H,eAAeD;YACfK,4BAA4BuD,MAAMxD,wBAAwB;QAC5D;IACF;IAEA,SAAS2F;IACP,EAAE,GACJ;IAEA,SAASa;QACPvI,sBAAsB;QACtBwC,eAAe;QACfhB,oBAAoB;QACpBE,eAAe,EAAE;QACjBE,eAAe;IACjB;IAEA,wDAAwD;IACxD,SAASyK,YACP/E,KAAgD,EAChD/B,KAAgC,EAChC+G,mBAA2B,EAC3B3L,KAAa;QAEb,IAAI0B,IAAI;QACR,IAAIC,IAAI;QAER,MAAMiK,aAAa,AAACjF,MAAMkF,MAAM,CAAoBC,qBAAqB;QACzEpK,IAAIkK,WAAWG,IAAI,GAAGH,WAAWjJ,KAAK,GAAG;QACzChB,IAAIiK,WAAWI,GAAG,GAAGJ,WAAWlJ,MAAM,GAAG;QACzC4I,eAAe5J,GAAGC;QAClB,wDAAwD;QACxD,MAAM,EAAEqH,WAAW,EAAEhI,WAAW,EAAE,GAAGiI,gCAAgCrE;QACrElG,UAAU6F,OAAO,CAAC,CAAC0H,KAAmBxH;YACpC,IAAIwH,IAAIxH,KAAK,KAAKG,MAAMmD,MAAM,IAAK4D,wBAAwBlH,OAAO;gBAChE,+FAA+F,GAC/F5C,eAAeqD,0BAA0BD,mBAAmBL,MAAMmD,MAAM;gBACxE3H,oBAAoBwE,MAAMjD,CAAC;gBAC3BR,iBAAiByD,MAAMmD,MAAM;gBAC7B9H,SAAS2E,MAAM5E,KAAK,IAAIA;gBACxB,+FAA+F;gBAC/FS,iBACEmE,MAAM4E,gBAAgB,IAAK5E,CAAAA,MAAMlD,CAAC,YAAYwJ,OAAOtG,MAAMlD,CAAC,CAAC+J,kBAAkB,KAAK7G,MAAMlD,CAAC,CAAC6D,QAAQ,EAAC;gBAEvG5E,iBAAiBiE,MAAM6E,gBAAgB;gBACvClI,yBAAyBqD;gBACzB,iGAAiG;gBACjG/D,oBAAoB+D,MAAMlD,CAAC;gBAC3BX,eAAeiI;gBACf/H,eAAeD;gBACfK,4BAA4BuD,MAAMxD,wBAAwB;YAC5D;QACF;IACF;IAEA,SAASwF,WAAWhC,KAAgC,EAAEwG,UAAwC;QAC5FA,WAAWC,OAAO;QAClBa,gBAAgBtH,OAAOwG;IACzB;IAEA,SAAS1D,WACPf,KAAkD,EAClD/B,KAAgC,EAChC2C,GAA4C;QAE5C,IAAIA,IAAIjB,UAAU,EAAE;YAClB4F,gBAAgBtH,OAAO2C,IAAIjB,UAAU;QACvC;IACF;IAEA,SAAS4F,gBACPtH,KAAgC,EAChCuH,YAA6D;QAE7D,MAAM,EAAE9H,iBAAiB,EAAE,EAAEF,kBAAkBjI,OAAOkI,6BAA6B,EAAE,GAAGhG;QACxFyD,eAAeqD,0BAA0BD,mBAAmBZ;QAC5DlD,iBAAiBkD;QACjBjE,oBAAoBwE,MAAMN,QAAQ,CAAE3C,CAAC;QACrC1B,SAASkE;QACT1D,iBACEmE,MAAM4E,gBAAgB,IAAK5E,CAAAA,MAAMlD,CAAC,YAAYwJ,OAAOtG,MAAMlD,CAAC,CAAC+J,kBAAkB,KAAK7G,MAAMlD,CAAC,CAAC6D,QAAQ,EAAC;QAEvG5E,iBAAiBiE,MAAMN,QAAQ,CAAEmF,gBAAgB;QACjDlI,yBAAyBqD;QACzB/D,oBAAoB+D,MAAMlD,CAAC;IAC7B;IAEA,SAAS0K,WACPzI,eAAuB,EACvBC,cAAsB;QAGtB,8DAA8D;QAC9D,IAAIyI;QACJ,8DAA8D;QAC9D,MAAMC,YAAiB1Q,gBACpB6O,MAAM,CAAC;YAACzL;YAAOD;SAAM,EACrB2L,KAAK,CAAC;YAAC;YAAG/G,kBAAkBhF,QAAQ4N,MAAM,GAAI5N,QAAQqN,GAAG;SAAE;QAE9D,IAAI5M,eAAe5C,WAAW8G,WAAW,EAAE;YACzC,MAAMkJ,OAAOpR,MAAMmD,SAAS,CAACqG,QAAqCA,MAAMlD,CAAC;YACzE,MAAM+K,OAAOnR,MAAMiD,SAAS,CAACqG,QAAqCA,MAAMlD,CAAC;YACzE2K,YAAYzQ,gBACT6O,MAAM,CAAC7L,UAAU;gBAAC4N;gBAAMC;aAAK,GAAG;gBAACA;gBAAMD;aAAK,EAC5C9B,KAAK,CAAC;gBAAC/L,QAAQoN,IAAI,GAAIzM;gBAAesE,iBAAiBjF,QAAQ+N,KAAK,GAAIpN;aAAc;YACzF,IAAI,CAACxC,sBAAsBsB,MAAMsK,iBAAiB,EAAEtK,MAAMuK,YAAY,KAAKvK,MAAM8J,IAAI,KAAK,aAAa;gBACrGmE,UAAUM,IAAI;YAChB;QACF,OAAO,IAAIvN,eAAe5C,WAAW+G,QAAQ,EAAE;YAC7C,MAAMqJ,QAAQtR,MAAMiD,SAAS,CAACqG,QAAqCA,MAAMlD,CAAC;YAC1E,MAAMmL,QAAQzR,MAAMmD,SAAS,CAACqG,QAAqCA,MAAMlD,CAAC;YAC1E2K,YAAYrQ,aACTyO,MAAM,CAAC;gBAACmC;gBAAOC;aAAM,EACrBnC,KAAK,CACJ9L,UACI;gBAACgF,iBAAiBjF,QAAQ+N,KAAK,GAAIpN;gBAAeX,QAAQoN,IAAI,GAAIzM;aAAc,GAChF;gBAACX,QAAQoN,IAAI,GAAIzM;gBAAesE,iBAAiBjF,QAAQ+N,KAAK,GAAIpN;aAAc;QAE1F,OAAO;YACL+M,YAAYvQ,cACT2O,MAAM,CAAC3L,cACP4L,KAAK,CACJ9L,UACI;gBAACgF,iBAAiBjF,QAAQ+N,KAAK,GAAIpN;gBAAeX,QAAQoN,IAAI,GAAIzM;aAAc,GAChF;gBAACX,QAAQoN,IAAI,GAAIzM;gBAAesE,iBAAiBjF,QAAQ+N,KAAK,GAAIpN;aAAc,EAErFwN,YAAY,CAACnN,oBACboN,YAAY,CAACnN;QAClB;QAEA,OAAO;YAAEyM;YAAWC;QAAU;IAChC;IAEA,MAAMtG,UAAU9K,0BAA0BkD;IAE1C,8DAA8D;IAC9D,SAAS4O,uBAAuBC,IAAY,EAAEC,IAAY,EAAEC,eAAuB,EAAEb,SAAc;QACjG,MAAMc,wBACJF,OAAO,IACHG,KAAKC,GAAG,CAACL,OAAOE,mBAChBE,KAAKlS,GAAG,CAACkS,KAAKC,GAAG,CAACJ,OAAOC,kBAAkBE,KAAKC,GAAG,CAACL,OAAOE;QACjE,OAAOE,KAAKE,IAAI,CAACjB,UAAUc,yBAAyB;IACtD;IAEA,SAASnD,mBAAmBtG,eAAuB,EAAEC,cAAsB,EAAEoG,QAAoB;QAC/F,MAAM,EAAEN,iBAAiB,KAAK,EAAE,GAAGtL;QACnC,MAAM,EAAEiO,SAAS,EAAEC,SAAS,EAAE,GAAGF,WAAWzI,iBAAiBC;QAC7D,MAAMI,aAAaC;QACnB,MAAMkJ,kBAAkBpO,QAAQ,IAAIA,QAAQ;QAC5C,MAAMyO,OAAOjP,QAAQ6H,GAAG,CAAC,CAACxB,OAAkCH;YAC1D,MAAMO,kBAAkBC,mBAAmBL,MAAMmD,MAAM,KAAM7C,yBAAyB,OAAO;YAE7F,IAAIuI,YAAoBnB,UAAU1H,MAAMjD,CAAC,IAAI2K,UAAUa;YACvD,MAAMO,mBAAmBD,YAAY;YACrCA,YAAYJ,KAAKC,GAAG,CAACG;YACrB,qDAAqD;YACrD,MAAME,eAAeX,uBAAuBhO,OAAOD,OAAOoO,iBAAiBb;YAC3E,IAAIsB,oBAAoBH;YAExB,IAAIA,cAAc,GAAG;gBACnB,qBAAO,oBAACxS,MAAM4S,QAAQ;oBAACpI,KAAKb,MAAMlD,CAAC;mBAAY;YACjD,OAEK,IAAI+L,aAAaE,cAAc;gBAClCC,oBAAoBD;YACtB;YACA,MAAMG,SAASzB,UAAUzH,MAAMlD,CAAC,IAAclD,YAAY;YAC1D,MAAMuP,SACJpK,kBACAhF,QAAQ4N,MAAM,GACbmB,CAAAA,mBAAmB,CAAC,IAAIE,oBAAoBA,iBAAgB,IAC7DtB,UAAUa;YACZ,MAAMa,iBAAiBrK,kBAAkBhF,QAAQ4N,MAAM,GAAID,UAAUa;YACrE,qBACE,oBAACc;gBAAExI,KAAK,GAAGb,MAAMlD,CAAC,CAAC,CAAC,EAAE+C,OAAO;6BAC3B,oBAACyJ;gBACCxI,IAAI,GAAGhG,UAAU,CAAC,EAAE+E,OAAO;gBAC3B/C,GAAGoM;gBACHnM,GAAG,CAAC+L,mBAAmBK,SAASC;gBAChCrL,OAAOnE;gBACPkE,QAAQkL;gBACRrG,KAAK,CAACC;oBACJmD,aAAanD,GAAG5C,MAAMmD,MAAM;gBAC9B;gBACAV,SAASzC,MAAMyC,OAAO;gBACtBX,aAAaC,CAAAA,QAASE,YAAYjC,OAAOZ,WAAWY,MAAMjD,CAAC,GAAGgF;gBAC9DwH,cAAYC,cAAcxJ;gBAC1ByJ,MAAK;gBACLC,cAAcvH;gBACdU,SAASd,CAAAA,QAAS+E,YAAY/E,OAAO/B,OAAOH,OAAOT,WAAWY,MAAMjD,CAAC;gBACrEgG,QAAQZ;gBACRnB,MAAMhB,MAAM5E,KAAK,IAAI,CAAC0J,iBAAiB9E,MAAM5E,KAAK,GAAGgE,WAAWY,MAAMjD,CAAC;gBACvEkG,UAAU,CAACzJ,MAAMmQ,WAAW,IAAIvJ,kBAAkB,IAAIzE;gBACtDoF,SAASX,kBAAkB,IAAI;gBAC/BwJ,IAAIpQ,MAAMqQ,YAAY,GAAG,IAAI;gBAE9BC,gBAAgBZ,QAAQC,QAAQnJ,MAAMjD,CAAC,EAAEiD,MAAMmD,MAAM,EAAG2F;QAG/D;QACA,mEAAmE;QACnE,IAAI,CAACtP,MAAMuQ,sBAAsB,EAAE;YACjC,IAAI;gBACF,iDAAiD;gBACjDC,SAASC,cAAc,CAAC1P,eAAeyP,SAASC,cAAc,CAAC1P,YAAa2P,MAAM;YAClF,oCAAoC;YACtC,EAAE,OAAOtH,GAAG,CAAC;QACf;QACA,4CAA4C;QAC5C,IAAI,CAACpJ,MAAM2Q,eAAe,IAAI3Q,MAAMuQ,sBAAsB,EAAE;YAC1D,MAAMK,eAAetT,SAASsO,UAAUiF,IAAI,CAAC5C;YAC7C,IAAI;gBACF,iDAAiD;gBACjDuC,SAASC,cAAc,CAAC1P,eAAeyP,SAASC,cAAc,CAAC1P,YAAa2P,MAAM;YAClF,oCAAoC;YACtC,EAAE,OAAOtH,GAAG,CAAC;YACb,MAAM0H,eAAe;gBACnBC,YAAYnJ,QAAQoJ,OAAO;gBAC3B1J,IAAIvG;gBACJkQ,MAAML;YACR;YACAA,gBAAgBtS,oBAAoBwS;QACtC;QACA,OAAO1B;IACT;IAEA,SAASrD,kBAAkBxG,eAAuB,EAAEC,cAAsB,EAAEoG,QAAoB;QAC9F,MAAM,EAAEqC,SAAS,EAAEC,SAAS,EAAE,GAAGF,WAAWzI,iBAAiBC;QAC7D,MAAMI,aAAaC;QACnB,MAAMkJ,kBAAkBpO,QAAQ,IAAIA,QAAQ;QAC5C,MAAMyO,OAAOjP,QAAQ6H,GAAG,CAAC,CAACxB,OAAkCH;YAC1D,MAAMO,kBAAkBC,mBAAmBL,MAAMmD,MAAM,KAAM7C,yBAAyB,OAAO;YAC7F,IAAIuI,YAAoBnB,UAAU1H,MAAMjD,CAAC,IAAI2K,UAAUa;YACvD,MAAMO,mBAAmBD,YAAY;YACrCA,YAAYJ,KAAKC,GAAG,CAACG;YACrB,qDAAqD;YACrD,MAAME,eAAeX,uBAAuBhO,OAAOD,OAAOoO,iBAAiBb;YAC3E,IAAIsB,oBAAoBH;YAExB,IAAIA,cAAc,GAAG;gBACnB,qBAAO,oBAACxS,MAAM4S,QAAQ;oBAACpI,KAAKb,MAAMlD,CAAC;mBAAY;YACjD,OAEK,IAAI+L,aAAaE,cAAc;gBAClCC,oBAAoBD;YACtB;YACA,MAAMG,SAASzB,UAAUzH,MAAMlD,CAAC;YAChC,MAAMqM,SACJpK,kBACAhF,QAAQ4N,MAAM,GACbmB,CAAAA,mBAAmB,CAAC,IAAIE,oBAAoBA,iBAAgB,IAC7DtB,UAAUa;YACZ,MAAMa,iBAAiBrK,kBAAkBhF,QAAQ4N,MAAM,GAAID,UAAUa;YACrE,2FAA2F;YAC3F,4EAA4E;YAC5E3O,YAAY5B,YAAYwB,MAAM8E,QAAQ,EAAE9E,MAAME,WAAW,EAAE+N,UAAUtH,SAAS,IAAI3G,MAAM8J,IAAI;YAC5F,qBACE,oBAAC+F;gBACCxI,KAAKb,MAAMlD,CAAC,YAAYwJ,OAAO,GAAGtG,MAAMlD,CAAC,CAAC4N,OAAO,GAAG,CAAC,EAAE7K,OAAO,GAAG,GAAGG,MAAMlD,CAAC,CAAC,CAAC,EAAE+C,OAAO;gBACtF8K,WAAW,CAAC,UAAU,EAAE,MAAOlD,CAAAA,UAAUtH,SAAS,KAAKvG,SAAQ,EAAG,IAAI,CAAC;6BAEvE,oBAAC0P;gBACCxI,IAAI,GAAGhG,UAAU,CAAC,EAAE+E,OAAO;gBAC3B/C,GAAGoM;gBACHnM,GAAG,CAAC+L,mBAAmBK,SAASC;gBAChCrL,OAAOnE;gBACPkE,QAAQkL;gBACRO,cAAYC,cAAcxJ;gBAC1ByJ,MAAK;gBACL9G,KAAK,CAACC;oBACJmD,aAAanD,GAAG5C,MAAMmD,MAAM;gBAC9B;gBACAV,SAASzC,MAAMyC,OAAO;gBACtBX,aAAaC,CAAAA,QAASE,YAAYjC,OAAOZ,WAAWY,MAAMjD,CAAC,GAAGgF;gBAC9D2H,cAAcvH;gBACdY,QAAQZ;gBACRU,SAASd,CAAAA,QAAS+E,YAAY/E,OAAO/B,OAAOH,OAAOT,WAAWY,MAAMjD,CAAC;gBACrEiE,MAAMhB,MAAM5E,KAAK,GAAG4E,MAAM5E,KAAK,GAAGgE,WAAWY,MAAMjD,CAAC;gBACpDkG,UAAU,CAACzJ,MAAMmQ,WAAW,IAAIvJ,kBAAkB,IAAIzE;gBACtDiO,IAAIpQ,MAAMqQ,YAAY,GAAG,IAAI;gBAC7B9I,SAASX,kBAAkB,IAAI;gBAEhC0J,gBAAgBZ,QAAQC,QAAQnJ,MAAMjD,CAAC,EAAEiD,MAAMmD,MAAM,EAAG2F;QAG/D;QAEA,mEAAmE;QACnE,IAAI,CAACtP,MAAMuQ,sBAAsB,EAAE;YACjC,IAAI;gBACF,iDAAiD;gBACjDC,SAASC,cAAc,CAAC1P,eAAeyP,SAASC,cAAc,CAAC1P,YAAa2P,MAAM;YAClF,oCAAoC;YACtC,EAAE,OAAOtH,GAAG,CAAC;QACf;QACA,4CAA4C;QAC5C,IAAI,CAACpJ,MAAM2Q,eAAe,IAAI3Q,MAAMuQ,sBAAsB,EAAE;YAC1D,MAAMK,eAAetT,SAASsO,UAAUiF,IAAI,CAAC5C;YAC7C,IAAI;gBACF,iDAAiD;gBACjDuC,SAASC,cAAc,CAAC1P,eAAeyP,SAASC,cAAc,CAAC1P,YAAa2P,MAAM;YAClF,oCAAoC;YACtC,EAAE,OAAOtH,GAAG,CAAC;YACb,MAAM0H,eAAe;gBACnBC,YAAYnJ,QAAQoJ,OAAO;gBAC3B1J,IAAIvG;gBACJkQ,MAAML;gBACNQ,aAAapR,MAAMuQ,sBAAsB;YAC3C;YACAK,gBAAgBtS,oBAAoBwS;QACtC;QACA,OAAO1B;IACT;IAEA,SAAStD,gBAAgBvG,eAAuB,EAAEC,cAAsB,EAAEoG,QAAoB;QAC5F,MAAM,EAAEN,iBAAiB,KAAK,EAAE,GAAGtL;QACnC,MAAM,EAAEiO,SAAS,EAAEC,SAAS,EAAE,GAAGF,WAAWzI,iBAAiBC;QAC7D,MAAMI,aAAaC;QACnB,MAAMkJ,kBAAkBpO,QAAQ,IAAIA,QAAQ;QAC5C,MAAMyO,OAAOjP,QAAQ6H,GAAG,CAAC,CAACxB,OAAkCH;YAC1D,MAAMO,kBAAkBC,mBAAmBL,MAAMmD,MAAM,KAAM7C,yBAAyB,OAAO;YAC7F,IAAIuI,YAAoBnB,UAAU1H,MAAMjD,CAAC,IAAI2K,UAAUa;YACvD,MAAMO,mBAAmBD,YAAY;YACrCA,YAAYJ,KAAKC,GAAG,CAACG;YACrB,qDAAqD;YACrD,MAAME,eAAeX,uBAAuBhO,OAAOD,OAAOoO,iBAAiBb;YAC3E,IAAIsB,oBAAoBH;YAExB,IAAIA,cAAc,GAAG;gBACnB,qBAAO,oBAACxS,MAAM4S,QAAQ;oBAACpI,KAAKb,MAAMlD,CAAC;mBAAY;YACjD,OAEK,IAAI+L,aAAaE,cAAc;gBAClCC,oBAAoBD;YACtB;YACA,MAAMG,SAASzB,UAAUzH,MAAMlD,CAAC,IAAclD,YAAY;YAC1D,MAAMuP,SACJpK,kBACAhF,QAAQ4N,MAAM,GACbmB,CAAAA,mBAAmB,CAAC,IAAIE,oBAAoBA,iBAAgB,IAC7DtB,UAAUa;YACZ,MAAMa,iBAAiBrK,kBAAkBhF,QAAQ4N,MAAM,GAAID,UAAUa;YACrE,qBACE,oBAACc;gBAAExI,KAAKb,MAAMlD,CAAC,YAAYwJ,OAAO,GAAGtG,MAAMlD,CAAC,CAAC4N,OAAO,GAAG,CAAC,EAAE7K,OAAO,GAAG,GAAGG,MAAMlD,CAAC,CAAC,CAAC,EAAE+C,OAAO;6BACvF,oBAACyJ;gBACCxI,IAAI,GAAGhG,UAAU,CAAC,EAAE+E,OAAO;gBAC3B/C,GAAGoM;gBACH/H,WAAWC,QAAQyJ,oBAAoB;gBACvC9N,GAAG,CAAC+L,mBAAmBK,SAASC;gBAChCrL,OAAOnE;gBACPkE,QAAQkL;gBACRrG,KAAK,CAACC;oBACJmD,aAAanD,GAAG5C,MAAMmD,MAAM;gBAC9B;gBACAV,SAASzC,MAAMyC,OAAO;gBACtBX,aAAaC,CAAAA,QAASE,YAAYjC,OAAOZ,WAAWY,MAAMjD,CAAC,GAAGgF;gBAC9DwH,cAAYC,cAAcxJ;gBAC1ByJ,MAAK;gBACLC,cAAcvH;gBACdU,SAASd,CAAAA,QAAS+E,YAAY/E,OAAO/B,OAAOH,OAAOT,WAAWY,MAAMjD,CAAC;gBACrEgG,QAAQZ;gBACRnB,MAAMhB,MAAM5E,KAAK,IAAI,CAAC0J,iBAAiB9E,MAAM5E,KAAK,GAAGgE,WAAWY,MAAMjD,CAAC;gBACvEkG,UAAU,CAACzJ,MAAMmQ,WAAW,IAAIvJ,kBAAkB,IAAIzE;gBACtDiO,IAAIpQ,MAAMqQ,YAAY,GAAG,IAAI;gBAC7B9I,SAASX,kBAAkB,IAAI;gBAEhC0J,gBAAgBZ,QAAQC,QAAQnJ,MAAMjD,CAAC,EAAEiD,MAAMmD,MAAM,EAAG2F;QAG/D;QACA,mEAAmE;QACnE,IAAI,CAACtP,MAAMuQ,sBAAsB,EAAE;YACjC,IAAI;gBACF,iDAAiD;gBACjDC,SAASC,cAAc,CAAC1P,eAAeyP,SAASC,cAAc,CAAC1P,YAAa2P,MAAM;YAClF,oCAAoC;YACtC,EAAE,OAAOtH,GAAG,CAAC;QACf;QACA,4CAA4C;QAC5C,IAAI,CAACpJ,MAAM2Q,eAAe,IAAI3Q,MAAMuQ,sBAAsB,EAAE;YAC1D,MAAMK,eAAetT,SAASsO,UAAUiF,IAAI,CAAC5C;YAC7C,IAAI;gBACF,iDAAiD;gBACjDuC,SAASC,cAAc,CAAC1P,eAAeyP,SAASC,cAAc,CAAC1P,YAAa2P,MAAM;YAClF,oCAAoC;YACtC,EAAE,OAAOtH,GAAG,CAAC;YACb,MAAM0H,eAAe;gBACnBC,YAAYnJ,QAAQoJ,OAAO;gBAC3B1J,IAAIvG;gBACJkQ,MAAML;YACR;YACAA,gBAAgBtS,oBAAoBwS;QACtC;QACA,OAAO1B;IACT;IAEA,SAASkC,eAAe7E,WAAmB;QACzCvK,gBAAgBuK;IAClB;IAEA,SAAS8E;QACPrP,gBAAgBC;IAClB;IAEA,SAASqP,eAAe1L,IAAiC;QACvD,MAAM,EAAEwF,cAAc,EAAE,GAAGtL;QAC3B,MAAM,EAAEiG,cAAc,EAAEF,kBAAkBjI,OAAO2T,6BAA6B,EAAE,GAAGzR;QACnF,MAAM0R,UAAoB,EAAE;QAC5B,MAAMC,mBAA2C,CAAC;QAClD7L,KAAKK,OAAO,CAAC,CAACK,OAAkCoL;YAC9C,wDAAwD;YACxD,MAAMhQ,QAAgB,CAAC0J,iBAAiB9E,MAAM5E,KAAK,GAAIiE,gBAAgB;YACvE8L,gBAAgB,CAACnL,MAAMmD,MAAM,CAAE,GAAG/H;QACpC;QACAiQ,OAAOC,OAAO,CAACH,kBAAkBxL,OAAO,CAAC,CAAC,CAACsG,aAAa7K,MAAM;YAC5D,qDAAqD;YACrD,MAAM+H,SAAiB;gBACrBoI,OAAOtF;gBACP7K;gBACAoQ,aAAa;oBACXxI;oBACA8H,eAAe7E;gBACjB;gBACAwF,kBAAkB;oBAChBV;gBACF;YACF;YACAG,QAAQpL,IAAI,CAACqD;QACf;QACA,IAAI9I,iBAAiBoF,kBAAkBF,iBAAiB;YACtD,MAAMmM,aAAqB;gBACzBH,OAAO9L;gBACPrE,OAAOmE;gBACPiM,aAAa;oBACXxI;oBACA8H,eAAerL;gBACjB;gBACAgM,kBAAkB;oBAChBV;gBACF;gBACAY,wBAAwB;YAC1B;YACAT,QAAQU,OAAO,CAACF;QAClB;QACA,MAAMG,wBACJ,oBAACrU;YACCqU,SAASX;YACTY,kBAAkBtS,MAAMuS,uBAAuB;YAC/CC,cAAcxS,MAAMyS,mBAAmB;YACtC,GAAGzS,MAAM4D,WAAW;YACrBF,iBAAiBA;YACjBgP,UAAUC;YACVC,WAAWjR;;QAGf,OAAO0Q;IACT;IAEA,SAASM,yBACPE,eAAyB,EACzBtK,KAA0C,EAC1CuK,aAAsB;YAElB9S,oBAMAA;QANJ,KAAIA,qBAAAA,MAAM4D,WAAW,cAAjB5D,yCAAAA,mBAAmB+S,wBAAwB,EAAE;YAC/CpP,mBAAmBkP;QACrB,OAAO;YACLlP,mBAAmBkP,gBAAgBG,KAAK,CAAC,CAAC;QAC5C;QAEA,KAAIhT,sBAAAA,MAAM4D,WAAW,cAAjB5D,0CAAAA,oBAAmB0S,QAAQ,EAAE;YAC/B1S,MAAM4D,WAAW,CAAC8O,QAAQ,CAACG,iBAAiBtK,OAAOuK;QACrD;IACF;IAEA,SAASG,aAAaC,SAAoB;QACxC,IAAIA,aAAaA,UAAUC,iBAAiB,CAACtJ,MAAM,EAAE;YACnD,MAAM,EAAEsJ,mBAAmBC,WAAW,EAAE,GAAGF;YAC3CvS,QAAQsO,KAAKlS,GAAG,CAACqW,WAAW,CAACA,YAAYvJ,MAAM,GAAG,EAAE,EAAE7J,MAAMqT,SAAS,IAAI;YACzEzS,QAAQqO,KAAKhS,GAAG,CAACmW,WAAW,CAAC,EAAE,EAAEpT,MAAMsT,SAAS,IAAI;QACtD;IACF;IAEA;;;;;GAKC,GACD,SAASzM,mBAAmB4F,WAA+B;QACzD,OAAO8G,wBAAwB1G,QAAQ,CAACJ;IAC1C;IAEA;;GAEC,GACD,SAAS3F;QACP,OAAOyM,wBAAwB1J,MAAM,KAAK;IAC5C;IAEA,SAAS0J;QACP,OAAO7P,gBAAgBmG,MAAM,GAAG,IAAInG,kBAAkBzB,eAAe;YAACA;SAAa,GAAG,EAAE;IAC1F;IAEA,SAAS+N,cAAcxJ,KAAgC;YASlCA,iBAAoCA,kBAErDA;QAVF,MAAMgN,SAAShN,MAAM4E,gBAAgB,GACjC5E,MAAM4E,gBAAgB,GACtB5E,MAAMlD,CAAC,YAAYwJ,OACnBtG,MAAMlD,CAAC,CAACyJ,cAAc,KACtBvG,MAAMlD,CAAC;QACX,MAAMqG,SAASnD,MAAMmD,MAAM;QAC3B,MAAM8J,SAASjN,MAAM6E,gBAAgB,IAAI7E,MAAMjD,CAAC;QAChD,MAAM2O,aAAalS,MAAMiG,cAAc,IAAI;QAC3C,MAAMyN,aAAalN,EAAAA,kBAAAA,MAAMN,QAAQ,cAAdM,sCAAAA,gBAAgB6E,gBAAgB,OAAI7E,mBAAAA,MAAMN,QAAQ,cAAdM,uCAAAA,iBAAgBjD,CAAC;QACxE,OACEiD,EAAAA,kCAAAA,MAAMxD,wBAAwB,cAA9BwD,sDAAAA,gCAAgCmN,SAAS,KACzC,GAAGH,OAAO,EAAE,CAAC,GACV7J,CAAAA,SAAS,GAAGA,OAAO,EAAE,CAAC,GAAG,EAAC,IAC3B,GAAG8J,OAAO,CAAC,CAAC,GACX,CAAA,OAAOC,eAAe,cAAc,CAAC,CAAC,EAAExB,WAAW,EAAE,EAAEwB,WAAW,CAAC,CAAC,GAAG,EAAC;IAE/E;IAEA,SAASpD,gBAAgBZ,MAAc,EAAEC,MAAc,EAAEiE,QAAgB,EAAEjK,MAAc,EAAEkK,aAAsB;QAC/G,IAAI7T,MAAM8T,UAAU,IAAI1T,YAAY,MAAM,CAAEyG,CAAAA,mBAAmB8C,WAAW7C,sBAAqB,GAAI;YACjG,OAAO;QACT;QAEA,qBACE,oBAACiN;YACCzQ,GAAGoM,SAAStP,YAAY;YACxBmD,GAAGsQ,gBAAgBlE,SAAS,KAAKA,SAAS;YAC1CqE,YAAW;YACXrM,WAAWC,QAAQqM,QAAQ;YAC3BC,eAAa;YACbC,OAAO;gBAAEC,WAAW;gBAAOC,aAAa;YAAU;WAEjD,OAAOrU,MAAMsU,eAAe,KAAK,aAC9BtU,MAAMsU,eAAe,CAACV,YACtBrV,2BAA2BqV;IAGrC;IAEA,SAASW,kBAAkB/O,cAAsB;YAI/CxF;QAHAkB,gBAAgBvB;QAEhB,MAAM6U,OAA+C,CAAC;SACtDxU,cAAAA,MAAM8F,IAAI,cAAV9F,kCAAAA,YAAYmG,OAAO,CAACK,CAAAA;YAClB,IAAIA,MAAMlD,CAAC,YAAYwJ,MAAM;gBAC3B0H,IAAI,CAAChO,MAAMlD,CAAC,CAAC4N,OAAO,GAAG,GAAG1K,MAAMlD,CAAC;YACnC,OAAO;gBACLkR,IAAI,CAAChO,MAAMlD,CAAC,CAAC,GAAGkD,MAAMlD,CAAC;YACzB;QACF;QACA,MAAMmR,UAAU5C,OAAO6C,MAAM,CAACF;QAE9B,6CAA6C,GAC7C,MAAMG,aAAatV,eAAemG,gBAAgBjF,SAASZ;QAE3D,IAAIqB,eAAe5C,WAAWuH,UAAU,EAAE;YACxC,IAAIjH,sBAAsBsB,MAAMwK,iBAAiB,EAAExK,MAAMuK,YAAY,GAAG;gBACtE,uGAAuG;gBACvG,mEAAmE;gBACnErJ,gBAAgB;YAClB,OAAO,IAAIlB,MAAM8E,QAAQ,KAAK,UAAU9E,MAAM8J,IAAI,KAAK,aAAa;gBAClE,8DAA8D;gBAC9D,+DAA+D;gBAC/D1J,YAAY5B,YAAYwB,MAAM8E,QAAQ,EAAE9E,MAAME,WAAW;gBACzD,gFAAgF,GAChF,MAAM0U,WAAWrV,kBAAkBa,WAAWqU,QAAQ5K,MAAM,EAAEtI;gBAE9D,IAAIoT,cAAcC,UAAU;oBAC1B,4EAA4E;oBAC5E1T,gBAAgBvB,oBAAoB,AAACgV,CAAAA,aAAaC,QAAO,IAAK;gBAChE;YACF,OAAO,IAAI;gBAAC;gBAAU;aAAY,CAAC/H,QAAQ,CAAC7M,MAAM8J,IAAI,KAAM2K,QAAQ5K,MAAM,GAAG,GAAG;gBAC9E,sFAAsF;gBACtF,MAAMlD,YAAYrH,cAAcqV,YAAYF,QAAQ5K,MAAM,EAAEtI;gBAC5D,MAAMuD,WAAWtG,YAAYwB,MAAM8E,QAAQ,EAAE9E,MAAME,WAAW,EAAEyG,WAAW3G,MAAM8J,IAAI;gBACrF,IAAI8K,WAAWrV,kBAAkBuF,UAAU2P,QAAQ5K,MAAM,EAAEtI;gBAC3D,MAAMsT,UAAU,AAACF,CAAAA,aAAaC,QAAO,IAAK;gBAE1C,IAAIE,UAAU7N,OAAO8N,iBAAiB;gBACtC,wFAAwF;gBACxF,oCAAoC;gBACpC,IAAI/U,MAAM8J,IAAI,KAAK,aAAa;oBAC9B,gGAAgG;oBAChG,MAAMkL,OAAOlW,2BAA2B2V,WAAuB;oBAC/DG,WAAW,AAACH,CAAAA,QAAQ5K,MAAM,GAAGtI,kBAAiB,IAAKyT;oBACnDF,UAAU,AAACH,CAAAA,aAAaC,QAAO,IAAK;gBACtC;gBAEA1T,gBAAgBvB,oBAAoBsP,KAAKlS,GAAG,CAAC,GAAGkS,KAAKhS,GAAG,CAAC4X,SAASC;YACpE;QACF,OAAO;YACL,IAAI9U,MAAM8J,IAAI,KAAK,aAAa;gBAC9B,sFAAsF;gBACtF,yFAAyF;gBACzF,gDAAgD;gBAChD,MAAMhF,WAAW9E,MAAME,WAAW;gBAClC,MAAM0U,WAAWrV,kBAAkBuF,UAAU2P,QAAQ5K,MAAM,EAAEtI;gBAC7DL,iBAAiB+N,KAAKlS,GAAG,CAAC,GAAG,AAAC4X,CAAAA,aAAaC,QAAO,IAAK;YACzD;YAEA,iGAAiG;YACjG,8FAA8F;YAC9F,uGAAuG;YACvG,gGAAgG;YAChG,iGAAiG;YACjG,kCAAkC;YAClC,oGAAoG;YACpG,uCAAuC;YACvCxU,YAAY5B,YACVwB,MAAM8E,QAAQ,EACd9E,MAAME,WAAW,EACjBvB,6BACE8V,SACApV,eAAemG,gBAAgBjF,SAASW,gBACxCK,qBAEFvB,MAAM8J,IAAI;YAEZ5I,iBAAiBd,YAAY;YAC7Bc,iBAAiBd,YAAY;QAC/B;QAEA,OAAO;YACL,GAAGG,OAAO;YACVoN,MAAMpN,QAAQoN,IAAI,GAAIzM;YACtBoN,OAAO/N,QAAQ+N,KAAK,GAAIpN;QAC1B;IACF;IAEA,SAAS+T;QACP,OAAO9U,QAAQ0J,MAAM,KAAK,KAAM1J,QAAQ+U,KAAK,CAAC1O,CAAAA,QAASA,MAAMjD,CAAC,KAAK,MAAM,CAAC1C;IAC5E;IAEA,SAASsU;QACP,IAAInU,eAAe5C,WAAWuH,UAAU,EAAE;YACxC,OAAO,EAAE;QACX;QAEA,OAAOnG,mBAAmB4V,wBAAwBpV,MAAMC,kBAAkB;IAC5E;IAEA,SAASmV;QACP,MAAMC,mBAA6C,CAAC;QACpDlV,QAAQgG,OAAO,CAACK,CAAAA;YACd,MAAMgN,SAAShN,MAAMlD,CAAC;YACtB,IAAI,CAAC+R,gBAAgB,CAAC7B,OAAO,EAAE;gBAC7B6B,gBAAgB,CAAC7B,OAAO,GAAG,EAAE;YAC/B;YACA6B,gBAAgB,CAAC7B,OAAO,CAAClN,IAAI,CAACE,MAAMjD,CAAC;YACrC,IAAIiD,MAAMN,QAAQ,EAAE;gBAClBmP,gBAAgB,CAAC7B,OAAO,CAAClN,IAAI,CAACE,MAAMN,QAAQ,CAAC3C,CAAC;YAChD;QACF;QACA,OAAO8R;IACT;IAEA,SAASnI,eAAeoI,IAAY,EAAEC,IAAY;QAChD,MAAMC,YAAY,GAAG,+BAA+B;QACpD,MAAM,EAAElS,CAAC,EAAEC,CAAC,EAAE,GAAGH;QACjB,+BAA+B;QAC/B,MAAMqS,WAAWxG,KAAKyG,IAAI,CAACzG,KAAK0G,GAAG,CAACL,OAAOhS,GAAG,KAAK2L,KAAK0G,GAAG,CAACJ,OAAOhS,GAAG;QACtE,+EAA+E;QAC/E,IAAIkS,WAAWD,WAAW;YACxBnS,iBAAiB;gBAAEC,GAAGgS;gBAAM/R,GAAGgS;YAAK;YACpC9R,eAAe;QACjB;IACF;IAEAe;IACA9D,eAAeyU;IACfxU,QAAQsO,KAAKlS,GAAG,CAACC,MAAMmD,SAAS,CAACqG,QAAqCA,MAAMjD,CAAC,GAAIvD,MAAMqT,SAAS,IAAI;IACpGzS,QAAQqO,KAAKhS,GAAG,CAACC,MAAMiD,SAAS,CAACqG,QAAqCA,MAAMjD,CAAC,GAAIvD,MAAMsT,SAAS,IAAI;IACpG,MAAMsC,aAAyBpE,eAAerR;IAC9C,MAAM0V,eAAe;QACnB,GAAIhV,iBAAiB;YACnB+J,aAAalI;YACbE,aAAaA;QACf,CAAC;QACDhB,OAAOA;QACP+H,QAAQ7G;QACRkI,QAAQ5I;QACR6I,QAAQ3I,gBAAgBA,gBAAgBP;QACxC,GAAG/B,MAAM6V,YAAY;QACrB,GAAG1X,wBAAwB6E,yBAAyB;QACpDI,eAAeA;QACfI,eAAeA;QACf0H,mBAAmBrK,iBAAkBiG,CAAAA,0BAA0ByM,wBAAwB1J,MAAM,GAAG,CAAA;QAChGkB,SAAS/K,MAAM+K,OAAO;QACtB+K,aAAa;QACbC,eAAe;YACbC,mBAAmBxK,2BAA2B,OAAOA,0BAA2BrJ;YAChF8T,oBAAoBjW,MAAMkW,wBAAwB,GAC9ClW,MAAMkW,wBAAwB,CAAChT,yBAC/Bf;QACN;IACF;IAEA,MAAMgU,aAAa;QACjBpR,YAAY/E,MAAM+E,UAAU;QAC5BqR,YAAYpW,MAAMoW,UAAU;IAC9B;IACA,OAAO,CAACnB,gCACN,oBAAClX;QACE,GAAGiC,KAAK;QACT0E,QAAQvE;QACRwE,WAAWzG,WAAW0B,gBAAgB;QACtCiF,WAAW7D;QACXqV,aAAarX;QACb6W,cAAcA;QACdM,YAAYA;QACX,GAAItV,iBAAiBiG,0BAA0B;YAAEoE,mBAAmB;QAAK,CAAC;QAC3E0K,YAAYA;QACZU,uBAAuB5V;QACvB6V,UAAUnW;QACVhB,mBAAmBA;QACnBoX,YAAY/L;QACZgM,kBAAkB1X;QAClB2X,cAAchL;QACdiL,uBAAuBlS;QACvBmS,aAAa3D;QACb4D,mBAAmBrN;QACnBsN,kBAAkBvC;QACjB,GAAIvT,eAAgB5C,WAAWuH,UAAU,IAAI;YAC5C2E,mBAAmB/I;YACnBiJ,mBAAmBhJ;QACrB,CAAC;QACDuC,cAActC;QACdsV,yBACE,CAACrY,sBAAsBsB,MAAMsK,iBAAiB,EAAEtK,MAAMuK,YAAY,KAAKvK,MAAM8J,IAAI,KAAK;QAExF,oCAAoC,GACpC,kDAAkD;QAClDkN,UAAU,CAAChX;YACT,qBACE,wDACE,oBAAC6P,WAAGpP,QACHI,+BACC,oBAACgP,WACEzK,YACCpF,MAAMqF,MAAM,EACZrF,MAAMsF,aAAa,EACnBtF,MAAMuF,eAAe,EACrBvF,MAAMwF,cAAc,EACpBxF,MAAMyF,eAAe;QAMjC;uBAGF,oBAACwR;QAAI3P,IAAInG;QAAe8O,MAAM;QAASkE,OAAO;YAAE5M,SAAS;QAAI;QAAGwI,cAAY;;AAEhF,GAAG;AACHnQ,iBAAiBsX,WAAW,GAAG"}