{"version":3,"sources":["../src/components/HorizontalBarChartWithAxis/HorizontalBarChartWithAxis.tsx"],"sourcesContent":["'use client';\n\nimport * as React from 'react';\nimport { max as d3Max, min as d3Min } from 'd3-array';\nimport { scaleLinear as d3ScaleLinear, ScaleLinear as D3ScaleLinear, scaleBand as d3ScaleBand } from 'd3-scale';\nimport { Legend, LegendContainer } from '../../components/Legends/Legends.types';\nimport { Legends } from '../../components/Legends/Legends';\nimport { useId } from '@fluentui/react-utilities';\nimport type { JSXElement } from '@fluentui/react-utilities';\nimport {\n  AccessibilityProps,\n  HorizontalBarChartWithAxisDataPoint,\n  RefArrayData,\n  Margins,\n  ChartPopoverProps,\n  Chart,\n  ImageExportOptions,\n} from '../../index';\nimport { ChildProps } from '../CommonComponents/CartesianChart.types';\nimport { CartesianChart } from '../CommonComponents/CartesianChart';\nimport { HorizontalBarChartWithAxisProps } from './HorizontalBarChartWithAxis.types';\nimport { ChartPopover } from '../CommonComponents/ChartPopover';\nimport {\n  ChartTypes,\n  IAxisData,\n  getAccessibleDataObject,\n  YAxisType,\n  XAxisTypes,\n  NumericAxis,\n  StringAxis,\n  getTypeOfAxis,\n  getNextColor,\n  findHBCWANumericMinMaxOfY,\n  createYAxisForHorizontalBarChartWithAxis,\n  IDomainNRange,\n  domainRangeOfNumericForHorizontalBarChartWithAxis,\n  createStringYAxisForHorizontalBarChartWithAxis,\n  areArraysEqual,\n  useRtl,\n  DataVizPalette,\n  getColorFromToken,\n  computeLongestBars,\n  groupChartDataByYValue,\n  MIN_DOMAIN_MARGIN,\n  sortAxisCategories,\n} from '../../utilities/index';\nimport { getClosestPairDiffAndRange } from '../../utilities/vbc-utils';\nimport { toImage } from '../../utilities/image-export-utils';\ntype ColorScale = (_p?: number) => string;\n\nexport const HorizontalBarChartWithAxis: React.FunctionComponent<HorizontalBarChartWithAxisProps> = React.forwardRef<\n  HTMLDivElement,\n  HorizontalBarChartWithAxisProps\n>((props = { yAxisCategoryOrder: 'default' }, forwardedRef) => {\n  const _refArray: RefArrayData[] = [];\n  const _calloutId: string = useId('callout');\n  const _isRtl: boolean = useRtl();\n  const _xAxisType: XAxisTypes =\n    props.data! && props.data!.length > 0\n      ? (getTypeOfAxis(props.data![0].x, true) as XAxisTypes)\n      : XAxisTypes.NumericAxis;\n  const _yAxisType: YAxisType =\n    props.data! && props.data!.length > 0\n      ? (getTypeOfAxis(props.data![0].y, false) as YAxisType)\n      : YAxisType.StringAxis;\n  const _emptyChartId: string = useId('_HBCWithAxis_empty');\n  let _points: HorizontalBarChartWithAxisDataPoint[] = [];\n  let _barHeight: number = 0;\n  let _colors: string[] = [];\n  let _margins: Margins;\n  let _bars: JSXElement[];\n  let _yAxisLabels: string[];\n  let _xMax: number;\n  let _calloutAnchorPoint: HorizontalBarChartWithAxisDataPoint | null;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  let _longestBarPositiveTotalValue: number;\n  let _longestBarNegativeTotalValue: number;\n  let _domainMargin: number = MIN_DOMAIN_MARGIN;\n  let _yAxisPadding: number = props.yAxisPadding ?? 0.5;\n  const cartesianChartRef = React.useRef<Chart>(null);\n  const X_ORIGIN: number = 0;\n  const _legendsRef = React.useRef<LegendContainer>(null);\n\n  const [color, setColor] = React.useState<string>('');\n  const [dataForHoverCard, setDataForHoverCard] = React.useState<number>(0);\n  const [isLegendSelected, setIsLegendSelected] = React.useState<boolean>(\n    (props.legendProps?.selectedLegends && props.legendProps.selectedLegends.length > 0) ||\n      props.legendProps?.selectedLegend !== undefined,\n  );\n  const [isLegendHovered, setIsLegendHovered] = React.useState<boolean>(false);\n  const [selectedLegendTitle, setSelectedLegendTitle] = React.useState<string>(props.legendProps?.selectedLegend ?? '');\n  const [xCalloutValue, setXCalloutValue] = React.useState<string>('');\n  const [yCalloutValue, setYCalloutValue] = React.useState<string>('');\n  const [selectedLegends, setSelectedLegends] = React.useState<string[]>(props.legendProps?.selectedLegends || []);\n  const [dataPointCalloutProps, setDataPointCalloutProps] = React.useState<HorizontalBarChartWithAxisDataPoint>();\n  const [callOutAccessibilityData, setCallOutAccessibilityData] = React.useState<AccessibilityProps>();\n  const [isPopoverOpen, setPopoverOpen] = React.useState<boolean>(false);\n  const [clickPosition, setClickPosition] = React.useState({ x: 0, y: 0 });\n  const prevPropsRef = React.useRef<HorizontalBarChartWithAxisProps | null>(null);\n\n  React.useEffect(() => {\n    if (prevPropsRef.current) {\n      const prevProps = prevPropsRef.current;\n      if (!areArraysEqual(prevProps.legendProps?.selectedLegends, props.legendProps?.selectedLegends)) {\n        setSelectedLegends(props.legendProps?.selectedLegends || []);\n      }\n    }\n    prevPropsRef.current = props;\n  }, [props]);\n\n  React.useImperativeHandle(\n    props.componentRef,\n    () => ({\n      chartContainer: cartesianChartRef.current?.chartContainer ?? null,\n      toImage: (opts?: ImageExportOptions): Promise<string> => {\n        return toImage(cartesianChartRef.current?.chartContainer, _legendsRef.current?.toSVG, _isRtl, opts);\n      },\n    }),\n    [],\n  );\n\n  function _adjustProps(): void {\n    _points = props.data || [];\n    _barHeight = props.barHeight || 32;\n    const defaultPalette: string[] = [\n      getColorFromToken(DataVizPalette.color6),\n      getColorFromToken(DataVizPalette.color1),\n      getColorFromToken(DataVizPalette.color5),\n      getColorFromToken(DataVizPalette.color7),\n    ];\n    _colors = props.colors! || defaultPalette;\n  }\n\n  function _getMargins(margins: Margins) {\n    _margins = margins;\n  }\n\n  function _renderContentForOnlyBars(point: HorizontalBarChartWithAxisDataPoint): JSXElement {\n    const { useSingleColor = false } = props;\n    let selectedPointIndex = 0;\n    props.data!.forEach((yDataPoint: HorizontalBarChartWithAxisDataPoint, index: number) => {\n      if (yDataPoint.y === point.y) {\n        selectedPointIndex = index;\n      }\n    });\n    // eslint-disable-next-line @typescript-eslint/no-shadow\n    let color: string;\n    if (useSingleColor) {\n      //if useSingle color , then check if user has given a palette or not\n      // and pick the first color from that or else from our paltette.\n      color = props.colors ? _createColors()(1) : getNextColor(1, 0);\n    } else {\n      color = point.color ? point.color : props.colors ? _createColors()(point.x) : getNextColor(selectedPointIndex, 0);\n    }\n    return (\n      <>\n        <ChartPopover\n          XValue={point.xAxisCalloutData || point.x.toString()}\n          legend={point.legend}\n          YValue={point.yAxisCalloutData || point.y}\n          color={color}\n          culture={props.culture}\n          clickPosition={clickPosition}\n          isPopoverOpen={isPopoverOpen}\n        />\n      </>\n    );\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-shadow\n  function _renderCallout(props?: HorizontalBarChartWithAxisDataPoint): JSXElement | null {\n    return props ? _renderContentForOnlyBars(props) : null;\n  }\n\n  function _getCustomizedCallout() {\n    return props.onRenderCalloutPerDataPoint\n      ? props.onRenderCalloutPerDataPoint(dataPointCalloutProps, _renderCallout)\n      : null;\n  }\n\n  function _getGraphData(\n    xScale: NumericAxis,\n    yScale: NumericAxis | StringAxis,\n    containerHeight: number,\n    containerWidth: number,\n    xElement?: SVGElement | null,\n    yElement?: SVGElement | null,\n  ) {\n    const stackedChartData = groupChartDataByYValue(_points);\n    const longestBars = computeLongestBars(stackedChartData, X_ORIGIN);\n    _longestBarPositiveTotalValue = longestBars.longestPositiveBar;\n    _longestBarNegativeTotalValue = longestBars.longestNegativeBar;\n\n    const { xBarScale, yBarScale } =\n      _yAxisType === YAxisType.NumericAxis\n        ? _getScales(containerHeight, containerWidth, true)\n        : _getScales(containerHeight, containerWidth, false);\n    const xRange = xBarScale.range();\n    let allBars: JSXElement[] = [];\n    // when the chart mounts, the xRange[1] is sometimes seen to be < 0 (like -40) while xRange[0] > 0.\n    if (xRange[0] < xRange[1]) {\n      allBars = stackedChartData\n        .map(singleBarData =>\n          _yAxisType === YAxisType.NumericAxis\n            ? _createNumericBars(\n                containerHeight,\n                containerWidth,\n                xElement!,\n                yElement!,\n                singleBarData,\n                xBarScale,\n                yBarScale,\n              )\n            : _createStringBars(\n                containerHeight,\n                containerWidth,\n                xElement!,\n                yElement!,\n                singleBarData,\n                xBarScale,\n                yBarScale,\n              ),\n        )\n        .flat();\n    }\n\n    return (_bars = allBars);\n  }\n\n  function _createColors(): D3ScaleLinear<string, string> | ColorScale {\n    const increment = _colors.length <= 1 ? 1 : 1 / (_colors.length - 1);\n    const { useSingleColor = false } = props;\n    if (useSingleColor) {\n      return (_p?: number) => {\n        const { colors } = props;\n        return colors && colors.length > 0 ? colors[0] : getColorFromToken(DataVizPalette.color16);\n      };\n    }\n    const domainValues = [];\n    for (let i = 0; i < _colors.length; i++) {\n      domainValues.push(increment * i * _xMax);\n    }\n    const colorScale = d3ScaleLinear<string>().domain(domainValues).range(_colors);\n    return colorScale;\n  }\n\n  function _refCallback(element: SVGRectElement, legendTitle: string): void {\n    _refArray.push({ index: legendTitle, refElement: element });\n  }\n\n  function _onBarHover(\n    point: HorizontalBarChartWithAxisDataPoint,\n    // eslint-disable-next-line @typescript-eslint/no-shadow\n    color: string,\n    mouseEvent: React.MouseEvent<SVGElement, MouseEvent>,\n  ): void {\n    mouseEvent.persist();\n    // eslint-disable-next-line @typescript-eslint/no-shadow\n    if ((isLegendSelected === false || _isLegendHighlighted(point.legend)) && _calloutAnchorPoint !== point) {\n      _calloutAnchorPoint = point;\n      setPopoverOpen(true);\n      _updatePosition(mouseEvent.clientX, mouseEvent.clientY);\n      setDataForHoverCard(point.x);\n      setSelectedLegendTitle(point.legend!);\n      setColor(props.useSingleColor || props.enableGradient ? color : point.color!);\n      // To display callout value, if no callout value given, taking given point.x value as a string.\n      setXCalloutValue(point.yAxisCalloutData! || point.y.toString());\n      setYCalloutValue(point.xAxisCalloutData || point.x.toString());\n      setDataPointCalloutProps(point);\n      setCallOutAccessibilityData(point.callOutAccessibilityData);\n    }\n  }\n\n  function _onBarLeave(): void {\n    setPopoverOpen(false);\n  }\n\n  function _handleChartMouseLeave(): void {\n    _calloutAnchorPoint = null;\n    setPopoverOpen(false);\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-shadow\n  function _onBarFocus(\n    event: React.FocusEvent<SVGRectElement, Element>,\n    point: HorizontalBarChartWithAxisDataPoint,\n    refArrayIndexNumber: number,\n    color: string,\n  ): void {\n    let cx = 0;\n    let cy = 0;\n\n    const targetRect = (event.target as SVGRectElement).getBoundingClientRect();\n    cx = targetRect.left + targetRect.width / 2;\n    cy = targetRect.top + targetRect.height / 2;\n    _updatePosition(cx, cy);\n    if ((isLegendSelected === false || _isLegendHighlighted(point.legend)) && _calloutAnchorPoint !== point) {\n      // eslint-disable-next-line @typescript-eslint/no-shadow\n      _refArray.forEach((obj: RefArrayData, index: number) => {\n        if (refArrayIndexNumber === index) {\n          setPopoverOpen(true);\n          setSelectedLegendTitle(point.legend!);\n          setDataForHoverCard(point.x);\n          setColor(props.useSingleColor ? color : point.color!);\n          setXCalloutValue(point.yAxisCalloutData || point.y.toString());\n          setYCalloutValue(point.xAxisCalloutData! || point.x.toString());\n          setDataPointCalloutProps(point);\n          setCallOutAccessibilityData(point.callOutAccessibilityData);\n        }\n      });\n    }\n  }\n\n  function _getScales(\n    containerHeight: number,\n    containerWidth: number,\n    isNumericScale: boolean,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  ): { xBarScale: any; yBarScale: any } {\n    const xMax = _longestBarPositiveTotalValue;\n    const xMin = _longestBarNegativeTotalValue;\n    const xDomain = [Math.min(X_ORIGIN, xMin), Math.max(X_ORIGIN, xMax)];\n    if (isNumericScale) {\n      const yMax = d3Max(_points, (point: HorizontalBarChartWithAxisDataPoint) => point.y as number)!;\n      const yMin = d3Min(_points, (point: HorizontalBarChartWithAxisDataPoint) => point.y as number)!;\n      const yDomainMax = Math.max(yMax, props.yMaxValue || 0);\n      // Default to 0 if yMinValue is not provided.\n      const yMinProp = props.yMinValue || 0;\n      const yDomainMin = Math.min(yMin, yMinProp);\n      const xBarScale = d3ScaleLinear()\n        .domain(xDomain)\n        .nice()\n        .range([_margins.left!, containerWidth - _margins.right!]);\n      const yBarScale = d3ScaleLinear()\n        .domain([yDomainMin, yDomainMax])\n        .range([containerHeight - (_margins.bottom! + _domainMargin), _margins.top! + _domainMargin]);\n      return { xBarScale, yBarScale };\n    } else {\n      // please note these padding default values must be consistent in here\n      // and CatrtesianChartBase w for more details refer example\n      // http://using-d3js.com/04_07_ordinal_scales.html\n      const yBarScale = d3ScaleBand()\n        .domain(_yAxisLabels)\n        .range([containerHeight - (_margins.bottom! + _domainMargin), _margins.top! + _domainMargin])\n        .padding(_yAxisPadding);\n\n      const xBarScale = d3ScaleLinear()\n        .domain(xDomain)\n        .nice()\n        .range([_margins.left!, containerWidth - _margins.right!]);\n      return { xBarScale, yBarScale };\n    }\n  }\n\n  function _createNumericBars(\n    containerHeight: number,\n    containerWidth: number,\n    xElement: SVGElement,\n    yElement: SVGElement,\n    singleBarData: HorizontalBarChartWithAxisDataPoint[],\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    xBarScale: any,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    yBarScale: any,\n  ): JSXElement[] {\n    const { useSingleColor = false } = props;\n    const sortedBars: HorizontalBarChartWithAxisDataPoint[] = [...singleBarData];\n    sortedBars.sort((a, b) => {\n      const aValue = typeof a.y === 'number' ? a.y : parseFloat(a.y);\n      const bValue = typeof b.y === 'number' ? b.y : parseFloat(b.y);\n      return bValue - aValue;\n    });\n\n    let prevWidthPositive = 0;\n    let prevWidthNegative = 0;\n    let prevPoint = 0;\n\n    const totalPositiveBars = singleBarData.filter(\n      (point: HorizontalBarChartWithAxisDataPoint) => point.x >= X_ORIGIN,\n    ).length;\n    const totalNegativeBars = singleBarData.length - totalPositiveBars;\n    let currPositiveCounter = 0;\n    let currNegativeCounter = 0;\n\n    const bars = sortedBars.map((point: HorizontalBarChartWithAxisDataPoint, index: number) => {\n      let shouldHighlight = true;\n      if (isLegendHovered || isLegendSelected) {\n        shouldHighlight = _isLegendHighlighted(point.legend);\n      }\n      if (point.x >= X_ORIGIN) {\n        ++currPositiveCounter;\n      }\n      if (point.x < X_ORIGIN) {\n        ++currNegativeCounter;\n      }\n      const barStartX = _isRtl\n        ? containerWidth -\n          (_margins.right! + Math.max(xBarScale(point.x + X_ORIGIN), xBarScale(X_ORIGIN)) - _margins.left!)\n        : Math.min(xBarScale(point.x + X_ORIGIN), xBarScale(X_ORIGIN));\n      const barHeight: number = Math.max(yBarScale(point.y), 0);\n      if (barHeight < 1) {\n        return <React.Fragment key={point.x}> </React.Fragment>;\n      }\n      let startColor: string;\n      if (useSingleColor) {\n        //if useSingle color , then check if user has given a palette or not\n        // and pick the first color from that or else from our paltette.\n        startColor = props.colors ? _createColors()(1) : getNextColor(1, 0);\n      } else {\n        startColor = props.colors ? _createColors()(point.x) : getNextColor(index, 0);\n      }\n\n      startColor = point.color && !useSingleColor ? point.color : startColor;\n\n      const prevBarWidth = Math.abs(xBarScale(prevPoint + X_ORIGIN) - xBarScale(X_ORIGIN));\n      prevPoint > X_ORIGIN ? (prevWidthPositive += prevBarWidth) : (prevWidthNegative += prevBarWidth);\n      const currentWidth = Math.abs(xBarScale(point.x + X_ORIGIN) - xBarScale(X_ORIGIN));\n      const gapWidthLTR =\n        currentWidth > 2 &&\n        ((point.x > X_ORIGIN && currPositiveCounter !== totalPositiveBars) ||\n          (point.x < X_ORIGIN && (totalPositiveBars !== 0 || currNegativeCounter > 1)))\n          ? 2\n          : 0;\n      const gapWidthRTL =\n        currentWidth > 2 &&\n        ((point.x > X_ORIGIN && (totalNegativeBars !== 0 || currPositiveCounter > 1)) ||\n          (point.x < X_ORIGIN && currNegativeCounter !== totalNegativeBars))\n          ? 2\n          : 0;\n      let xStart = X_ORIGIN;\n      if (_isRtl) {\n        xStart = point.x > X_ORIGIN ? barStartX - prevWidthPositive : barStartX + prevWidthNegative;\n      } else {\n        xStart = point.x > X_ORIGIN ? barStartX + prevWidthPositive : barStartX - prevWidthNegative;\n      }\n      prevPoint = point.x;\n\n      return (\n        <React.Fragment key={`${index}_${point.x}`}>\n          <rect\n            key={point.y}\n            x={xStart}\n            y={yBarScale(point.y) - _barHeight / 2}\n            data-is-focusable={shouldHighlight}\n            width={currentWidth - (_isRtl ? gapWidthRTL : gapWidthLTR)}\n            height={_barHeight}\n            ref={(e: SVGRectElement) => {\n              _refCallback(e, point.legend!);\n            }}\n            rx={props.roundCorners ? 3 : 0}\n            onClick={point.onClick}\n            onMouseOver={(event: React.MouseEvent<SVGElement, MouseEvent>) => _onBarHover(point, startColor, event)}\n            aria-label={_getAriaLabel(point)}\n            role=\"img\"\n            aria-labelledby={`toolTip${_calloutId}`}\n            onMouseLeave={_onBarLeave}\n            onFocus={event => _onBarFocus(event, point, index, startColor)}\n            onBlur={_onBarLeave}\n            fill={startColor}\n            opacity={shouldHighlight ? 1 : 0.1}\n            tabIndex={point.legend !== '' ? 0 : undefined}\n          />\n        </React.Fragment>\n      );\n    });\n    return bars;\n  }\n\n  function _getUniqueYValues() {\n    const mapY: Record<string, number | string> = {};\n    props.data?.forEach((point: HorizontalBarChartWithAxisDataPoint) => {\n      mapY[point.y] = point.y;\n    });\n    const uniqueY = Object.values(mapY);\n    return uniqueY;\n  }\n\n  function _calculateAppropriateBarHeight(data: number[] | Date[], totalWidth: number, innerPadding: number) {\n    const result = getClosestPairDiffAndRange(data);\n    if (!result || result[1] === 0) {\n      return 16;\n    }\n    const closestPairDiff = result[0];\n    let range = result[1];\n    const yMax = d3Max(_points, (point: HorizontalBarChartWithAxisDataPoint) => point.y as number)!;\n    // Since we are always rendering from 0 to yMax, we need to ensure that the range is at least yMax\n    // to calculate the bar height correctly.\n    range = Math.max(range, yMax);\n    // Refer to https://microsoft.github.io/fluentui-charting-contrib/docs/rfcs/fix-overlapping-bars-on-continuous-axes\n    // for the derivation of the following formula.\n    const barWidth = Math.floor(\n      (totalWidth * closestPairDiff * (1 - innerPadding)) / (range + closestPairDiff * (1 - innerPadding)),\n    );\n    return barWidth;\n  }\n\n  function _getDomainMarginsForHorizontalBarChart(containerHeight: number): Margins {\n    _domainMargin = MIN_DOMAIN_MARGIN;\n    const uniqueY = _getUniqueYValues();\n    /** Rate at which the space between the bars changes wrt the bar height */\n    _yAxisPadding = _yAxisPadding === 1 ? 0.99 : _yAxisPadding;\n    const barGapRate = _yAxisPadding / (1 - _yAxisPadding);\n    const numBars = uniqueY.length + (uniqueY.length - 1) * barGapRate;\n    // Total height available to render the bars\n    const totalHeight = containerHeight - (_margins.top! + MIN_DOMAIN_MARGIN) - (_margins.bottom! + MIN_DOMAIN_MARGIN);\n    if (_yAxisType !== YAxisType.StringAxis) {\n      // Calculate bar height dynamically\n      _barHeight =\n        props.barHeight || _calculateAppropriateBarHeight(uniqueY as number[] | Date[], totalHeight, _yAxisPadding);\n      _barHeight = Math.max(_barHeight, 1);\n      _domainMargin += _barHeight / 2;\n    } else {\n      // Calculate the appropriate bar height\n      _barHeight = props.barHeight || totalHeight / numBars;\n      /** Total height required to render the bars. Directly proportional to bar height */\n      const reqHeight = numBars * _barHeight;\n      if (totalHeight >= reqHeight) {\n        // Center align the chart by setting equal left and right margins for domain\n        _domainMargin = MIN_DOMAIN_MARGIN + (totalHeight - reqHeight) / 2;\n      }\n    }\n\n    return {\n      ..._margins,\n      top: _margins.top! + _domainMargin,\n      bottom: _margins.bottom! + _domainMargin,\n    };\n  }\n\n  function _createStringBars(\n    containerHeight: number,\n    containerWidth: number,\n    xElement: SVGElement,\n    yElement: SVGElement,\n    singleBarData: HorizontalBarChartWithAxisDataPoint[],\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    xBarScale: any,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    yBarScale: any,\n  ): JSXElement[] {\n    const { useSingleColor = false } = props;\n    let prevWidthPositive = 0;\n    let prevWidthNegative = 0;\n    let prevPoint = 0;\n    const totalPositiveBars = singleBarData.filter(\n      (point: HorizontalBarChartWithAxisDataPoint) => point.x >= X_ORIGIN,\n    ).length;\n    const totalNegativeBars = singleBarData.length - totalPositiveBars;\n    let currPositiveCounter = 0;\n    let currNegativeCounter = 0;\n    const bars = singleBarData.map((point: HorizontalBarChartWithAxisDataPoint, index: number) => {\n      let shouldHighlight = true;\n      if (isLegendHovered || isLegendSelected) {\n        shouldHighlight = _isLegendHighlighted(point.legend);\n      }\n      if (point.x >= X_ORIGIN) {\n        ++currPositiveCounter;\n      }\n      if (point.x < X_ORIGIN) {\n        ++currNegativeCounter;\n      }\n      const barStartX = _isRtl\n        ? containerWidth -\n          (_margins.right! + Math.max(xBarScale(point.x + X_ORIGIN), xBarScale(X_ORIGIN)) - _margins.left!)\n        : Math.min(xBarScale(point.x + X_ORIGIN), xBarScale(X_ORIGIN));\n      const barHeight: number = Math.max(yBarScale(point.y), 0);\n      if (barHeight < 1) {\n        return <React.Fragment key={point.x}> </React.Fragment>;\n      }\n      let startColor: string;\n      if (useSingleColor) {\n        //if useSingle color , then check if user has given a palette or not\n        // and pick the first color from that or else from our paltette.\n        startColor = props.colors ? _createColors()(1) : getNextColor(1, 0);\n      } else {\n        startColor = props.colors ? _createColors()(point.x) : getNextColor(index, 0);\n      }\n\n      startColor = point.color && !useSingleColor ? point.color : startColor;\n      const prevBarWidth = Math.abs(xBarScale(prevPoint + X_ORIGIN) - xBarScale(X_ORIGIN));\n      prevPoint > 0 ? (prevWidthPositive += prevBarWidth) : (prevWidthNegative += prevBarWidth);\n      const currentWidth = Math.abs(xBarScale(point.x + X_ORIGIN) - xBarScale(X_ORIGIN));\n      const gapWidthLTR =\n        currentWidth > 2 &&\n        ((point.x > X_ORIGIN && currPositiveCounter !== totalPositiveBars) ||\n          (point.x < X_ORIGIN && (totalPositiveBars !== 0 || currNegativeCounter > 1)))\n          ? 2\n          : 0;\n      const gapWidthRTL =\n        currentWidth > 2 &&\n        ((point.x > X_ORIGIN && (totalNegativeBars !== 0 || currPositiveCounter > 1)) ||\n          (point.x < X_ORIGIN && currNegativeCounter !== totalNegativeBars))\n          ? 2\n          : 0;\n      prevPoint = point.x;\n      let xStart = X_ORIGIN;\n      if (_isRtl) {\n        xStart = point.x > X_ORIGIN ? barStartX - prevWidthPositive : barStartX + prevWidthNegative;\n      } else {\n        xStart = point.x > X_ORIGIN ? barStartX + prevWidthPositive : barStartX - prevWidthNegative;\n      }\n      return (\n        <React.Fragment key={`${index}_${point.x}`}>\n          <rect\n            transform={`translate(0,${0.5 * (yBarScale.bandwidth() - _barHeight)})`}\n            key={point.x}\n            x={xStart}\n            y={yBarScale(point.y)}\n            rx={props.roundCorners ? 3 : 0}\n            width={currentWidth - (_isRtl ? gapWidthRTL : gapWidthLTR)}\n            height={_barHeight}\n            aria-labelledby={`toolTip${_calloutId}`}\n            aria-label={_getAriaLabel(point)}\n            role=\"img\"\n            ref={(e: SVGRectElement) => {\n              _refCallback(e, point.legend!);\n            }}\n            onClick={point.onClick}\n            onMouseOver={(event: React.MouseEvent<SVGElement, MouseEvent>) => _onBarHover(point, startColor, event)}\n            onMouseLeave={_onBarLeave}\n            onBlur={_onBarLeave}\n            data-is-focusable={shouldHighlight}\n            opacity={shouldHighlight ? 1 : 0.1}\n            onFocus={event => _onBarFocus(event, point, index, startColor)}\n            fill={startColor}\n            tabIndex={point.legend !== '' ? 0 : undefined}\n          />\n        </React.Fragment>\n      );\n    });\n    return bars;\n  }\n\n  function _onLegendHover(customMessage: string): void {\n    if (!_isLegendSelected()) {\n      setIsLegendHovered(true);\n      setSelectedLegendTitle(customMessage);\n    }\n  }\n\n  function _onLegendLeave(isLegendFocused?: boolean): void {\n    if (!!isLegendFocused || !_isLegendSelected()) {\n      setIsLegendHovered(false);\n      setSelectedLegendTitle('');\n      setIsLegendSelected(isLegendFocused ? false : _isLegendSelected());\n    }\n  }\n\n  function _getLegendData(data: HorizontalBarChartWithAxisDataPoint[]): JSXElement {\n    const { useSingleColor } = props;\n    const actions: Legend[] = [];\n    const mapLegendToColor: Record<string, string> = {};\n\n    data.forEach((point: HorizontalBarChartWithAxisDataPoint, _index: number) => {\n      // eslint-disable-next-line @typescript-eslint/no-shadow\n      const color: string = useSingleColor ? (props.colors ? _createColors()(1) : getNextColor(1, 0)) : point.color!;\n\n      mapLegendToColor[point.legend!] = color;\n    });\n    Object.entries(mapLegendToColor).forEach(([legendTitle, color]) => {\n      // mapping data to the format Legends component needs\n      const legend: Legend = {\n        title: legendTitle,\n        color,\n        hoverAction: () => {\n          _handleChartMouseLeave();\n          _onLegendHover(legendTitle);\n        },\n        // eslint-disable-next-line @typescript-eslint/no-shadow\n        onMouseOutAction: (isLegendSelected?: boolean) => {\n          _onLegendLeave(isLegendSelected);\n        },\n      };\n      actions.push(legend);\n    });\n    const legends = (\n      <Legends\n        legends={actions}\n        enabledWrapLines={props.enabledLegendsWrapLines}\n        overflowText={props.legendsOverflowText}\n        {...props.legendProps}\n        onChange={_onLegendSelectionChange}\n        legendRef={_legendsRef}\n      />\n    );\n    return legends;\n  }\n\n  function _isLegendSelected(): boolean {\n    return isLegendSelected!;\n  }\n\n  /**\n   * This function checks if the given legend is highlighted or not.\n   * A legend can be highlighted in 2 ways:\n   * 1. selection: if the user clicks on it\n   * 2. hovering: if there is no selected legend and the user hovers over it\n   */\n  function _isLegendHighlighted(legend?: string) {\n    return _getHighlightedLegend().includes(legend!);\n  }\n\n  function _getHighlightedLegend() {\n    return selectedLegends.length > 0 ? selectedLegends : selectedLegendTitle ? [selectedLegendTitle] : [];\n  }\n\n  function _onLegendSelectionChange(\n    // eslint-disable-next-line @typescript-eslint/no-shadow\n    selectedLegends: string[],\n    event: React.MouseEvent<HTMLButtonElement>,\n    currentLegend?: Legend,\n  ): void {\n    if (props.legendProps?.canSelectMultipleLegends) {\n      setSelectedLegends(selectedLegends);\n      setSelectedLegendTitle(currentLegend?.title!);\n    } else {\n      setSelectedLegends(selectedLegends.slice(-1));\n      setSelectedLegendTitle(currentLegend?.title!);\n    }\n    setIsLegendSelected(selectedLegends.length > 0);\n    if (props.legendProps?.onChange) {\n      props.legendProps.onChange(selectedLegends, event, currentLegend);\n    }\n  }\n\n  function _getAxisData(yAxisData: IAxisData) {\n    if (yAxisData && yAxisData.yAxisDomainValues.length) {\n      // For HBCWA x and y Values are swapped\n      const { yAxisDomainValues: domainValue } = yAxisData;\n      _xMax = Math.max(domainValue[domainValue.length - 1], props.xMaxValue || 0);\n    }\n  }\n  function _getAriaLabel(point: HorizontalBarChartWithAxisDataPoint): string {\n    const xValue = point.xAxisCalloutData || point.x;\n    const yValue = point.yAxisCalloutData || point.y;\n    return point.callOutAccessibilityData?.ariaLabel || `${xValue}. ` + `${yValue}.`;\n  }\n\n  function _getChartTitle(): string {\n    const { chartTitle, data } = props;\n    return (chartTitle ? `${chartTitle}. ` : '') + `Horizontal bar chart with ${data?.length || 0} bars. `;\n  }\n\n  function _getOrderedYAxisLabels() {\n    const shouldOrderYAxisLabelsByCategoryOrder =\n      _yAxisType === YAxisType.StringAxis && props.yAxisCategoryOrder !== 'default';\n    if (!shouldOrderYAxisLabelsByCategoryOrder) {\n      // Keep the original ordering logic as the default behavior to ensure backward compatibility\n      const reversedBars = [..._points].reverse();\n      return reversedBars.map((point: HorizontalBarChartWithAxisDataPoint) => point.y as string);\n    }\n\n    return sortAxisCategories(_mapCategoryToValues(), props.yAxisCategoryOrder);\n  }\n\n  function _mapCategoryToValues() {\n    const categoryToValues: Record<string, number[]> = {};\n    _points.forEach(point => {\n      if (!categoryToValues[point.y]) {\n        categoryToValues[point.y] = [];\n      }\n      categoryToValues[point.y].push(point.x);\n    });\n    return categoryToValues;\n  }\n\n  function _isChartEmpty(): boolean {\n    return !(props.data && props.data.length > 0);\n  }\n\n  function _updatePosition(newX: number, newY: number): void {\n    const threshold = 1; // Set a threshold for movement\n    const { x, y } = clickPosition;\n\n    // Calculate the distance moved\n    const distance = Math.sqrt(Math.pow(newX - x, 2) + Math.pow(newY - y, 2));\n    // Update the position only if the distance moved is greater than the threshold\n    if (distance > threshold) {\n      setClickPosition({ x: newX, y: newY });\n      setPopoverOpen(true);\n    }\n  }\n\n  function _getDomainNRangeValues(\n    points: HorizontalBarChartWithAxisDataPoint[],\n    margins: Margins,\n    width: number,\n    chartType: ChartTypes,\n    isRTL: boolean,\n    xAxisType: XAxisTypes,\n    barWidth: number,\n    tickValues: Date[] | number[] | undefined,\n    shiftX: number,\n  ) {\n    let domainNRangeValue: IDomainNRange;\n    if (xAxisType === XAxisTypes.NumericAxis) {\n      domainNRangeValue = domainRangeOfNumericForHorizontalBarChartWithAxis(\n        points,\n        margins,\n        width,\n        isRTL,\n        shiftX,\n        X_ORIGIN,\n      );\n    } else {\n      domainNRangeValue = { dStartValue: 0, dEndValue: 0, rStartValue: 0, rEndValue: 0 };\n    }\n    return domainNRangeValue;\n  }\n\n  if (!_isChartEmpty()) {\n    _adjustProps();\n    const calloutProps: ChartPopoverProps = {\n      color: color,\n      legend: selectedLegendTitle,\n      XValue: xCalloutValue,\n      YValue: yCalloutValue ? yCalloutValue : dataForHoverCard,\n      ...props.calloutProps,\n      ...getAccessibleDataObject(callOutAccessibilityData),\n      customCallout: {\n        customizedCallout: _getCustomizedCallout() !== null ? _getCustomizedCallout()! : undefined,\n        customCalloutProps: props.calloutPropsPerDataPoint\n          ? props.calloutPropsPerDataPoint(dataPointCalloutProps!)\n          : undefined,\n      },\n      isCartesian: true,\n      isPopoverOpen,\n      clickPosition,\n    };\n    const tickParams = {\n      tickValues: props.tickValues,\n      tickFormat: props.tickFormat,\n    };\n\n    _yAxisLabels = _getOrderedYAxisLabels();\n    _xMax = Math.max(d3Max(_points, (point: HorizontalBarChartWithAxisDataPoint) => point.x)!, props.xMaxValue || 0);\n    const legendBars: JSXElement = _getLegendData(_points);\n    return (\n      <CartesianChart\n        yAxisPadding={_yAxisPadding}\n        {...props}\n        chartTitle={_getChartTitle()}\n        points={_points}\n        chartType={ChartTypes.HorizontalBarChartWithAxis}\n        xAxisType={_xAxisType}\n        yAxisType={_yAxisType}\n        getDomainNRangeValues={_getDomainNRangeValues}\n        stringDatasetForYAxisDomain={_yAxisLabels}\n        calloutProps={calloutProps}\n        tickParams={tickParams}\n        legendBars={legendBars}\n        createYAxis={createYAxisForHorizontalBarChartWithAxis}\n        createStringYAxis={createStringYAxisForHorizontalBarChartWithAxis}\n        getMinMaxOfYAxis={findHBCWANumericMinMaxOfY}\n        barwidth={_barHeight}\n        getmargins={_getMargins}\n        getYDomainMargins={_getDomainMarginsForHorizontalBarChart}\n        getGraphData={_getGraphData}\n        getAxisData={_getAxisData}\n        onChartMouseLeave={_handleChartMouseLeave}\n        componentRef={cartesianChartRef}\n        /* eslint-disable react/jsx-no-bind */\n        // eslint-disable-next-line @typescript-eslint/no-shadow\n        children={(props: ChildProps) => {\n          return (\n            <>\n              <g>{_bars}</g>\n            </>\n          );\n        }}\n      />\n    );\n  } else {\n    return (\n      <div id={_emptyChartId} role={'alert'} style={{ opacity: '0' }} aria-label={'Graph has no data to display'} />\n    );\n  }\n});\nHorizontalBarChartWithAxis.displayName = 'HorizontalBarChartWithAxis';\n"],"names":["React","max","d3Max","min","d3Min","scaleLinear","d3ScaleLinear","scaleBand","d3ScaleBand","Legends","useId","CartesianChart","ChartPopover","ChartTypes","getAccessibleDataObject","YAxisType","XAxisTypes","getTypeOfAxis","getNextColor","findHBCWANumericMinMaxOfY","createYAxisForHorizontalBarChartWithAxis","domainRangeOfNumericForHorizontalBarChartWithAxis","createStringYAxisForHorizontalBarChartWithAxis","areArraysEqual","useRtl","DataVizPalette","getColorFromToken","computeLongestBars","groupChartDataByYValue","MIN_DOMAIN_MARGIN","sortAxisCategories","getClosestPairDiffAndRange","toImage","HorizontalBarChartWithAxis","forwardRef","props","yAxisCategoryOrder","forwardedRef","_refArray","_calloutId","_isRtl","_xAxisType","data","length","x","NumericAxis","_yAxisType","y","StringAxis","_emptyChartId","_points","_barHeight","_colors","_margins","_bars","_yAxisLabels","_xMax","_calloutAnchorPoint","_longestBarPositiveTotalValue","_longestBarNegativeTotalValue","_domainMargin","_yAxisPadding","yAxisPadding","cartesianChartRef","useRef","X_ORIGIN","_legendsRef","color","setColor","useState","dataForHoverCard","setDataForHoverCard","isLegendSelected","setIsLegendSelected","legendProps","selectedLegends","selectedLegend","undefined","isLegendHovered","setIsLegendHovered","selectedLegendTitle","setSelectedLegendTitle","xCalloutValue","setXCalloutValue","yCalloutValue","setYCalloutValue","setSelectedLegends","dataPointCalloutProps","setDataPointCalloutProps","callOutAccessibilityData","setCallOutAccessibilityData","isPopoverOpen","setPopoverOpen","clickPosition","setClickPosition","prevPropsRef","useEffect","current","prevProps","useImperativeHandle","componentRef","chartContainer","opts","toSVG","_adjustProps","barHeight","defaultPalette","color6","color1","color5","color7","colors","_getMargins","margins","_renderContentForOnlyBars","point","useSingleColor","selectedPointIndex","forEach","yDataPoint","index","_createColors","XValue","xAxisCalloutData","toString","legend","YValue","yAxisCalloutData","culture","_renderCallout","_getCustomizedCallout","onRenderCalloutPerDataPoint","_getGraphData","xScale","yScale","containerHeight","containerWidth","xElement","yElement","stackedChartData","longestBars","longestPositiveBar","longestNegativeBar","xBarScale","yBarScale","_getScales","xRange","range","allBars","map","singleBarData","_createNumericBars","_createStringBars","flat","increment","_p","color16","domainValues","i","push","colorScale","domain","_refCallback","element","legendTitle","refElement","_onBarHover","mouseEvent","persist","_isLegendHighlighted","_updatePosition","clientX","clientY","enableGradient","_onBarLeave","_handleChartMouseLeave","_onBarFocus","event","refArrayIndexNumber","cx","cy","targetRect","target","getBoundingClientRect","left","width","top","height","obj","isNumericScale","xMax","xMin","xDomain","Math","yMax","yMin","yDomainMax","yMaxValue","yMinProp","yMinValue","yDomainMin","nice","right","bottom","padding","sortedBars","sort","a","b","aValue","parseFloat","bValue","prevWidthPositive","prevWidthNegative","prevPoint","totalPositiveBars","filter","totalNegativeBars","currPositiveCounter","currNegativeCounter","bars","shouldHighlight","barStartX","Fragment","key","startColor","prevBarWidth","abs","currentWidth","gapWidthLTR","gapWidthRTL","xStart","rect","data-is-focusable","ref","e","rx","roundCorners","onClick","onMouseOver","aria-label","_getAriaLabel","role","aria-labelledby","onMouseLeave","onFocus","onBlur","fill","opacity","tabIndex","_getUniqueYValues","mapY","uniqueY","Object","values","_calculateAppropriateBarHeight","totalWidth","innerPadding","result","closestPairDiff","barWidth","floor","_getDomainMarginsForHorizontalBarChart","barGapRate","numBars","totalHeight","reqHeight","transform","bandwidth","_onLegendHover","customMessage","_isLegendSelected","_onLegendLeave","isLegendFocused","_getLegendData","actions","mapLegendToColor","_index","entries","title","hoverAction","onMouseOutAction","legends","enabledWrapLines","enabledLegendsWrapLines","overflowText","legendsOverflowText","onChange","_onLegendSelectionChange","legendRef","_getHighlightedLegend","includes","currentLegend","canSelectMultipleLegends","slice","_getAxisData","yAxisData","yAxisDomainValues","domainValue","xMaxValue","xValue","yValue","ariaLabel","_getChartTitle","chartTitle","_getOrderedYAxisLabels","shouldOrderYAxisLabelsByCategoryOrder","reversedBars","reverse","_mapCategoryToValues","categoryToValues","_isChartEmpty","newX","newY","threshold","distance","sqrt","pow","_getDomainNRangeValues","points","chartType","isRTL","xAxisType","tickValues","shiftX","domainNRangeValue","dStartValue","dEndValue","rStartValue","rEndValue","calloutProps","customCallout","customizedCallout","customCalloutProps","calloutPropsPerDataPoint","isCartesian","tickParams","tickFormat","legendBars","yAxisType","getDomainNRangeValues","stringDatasetForYAxisDomain","createYAxis","createStringYAxis","getMinMaxOfYAxis","barwidth","getmargins","getYDomainMargins","getGraphData","getAxisData","onChartMouseLeave","children","g","div","id","style","displayName"],"mappings":"AAAA;AAEA,YAAYA,WAAW,QAAQ;AAC/B,SAASC,OAAOC,KAAK,EAAEC,OAAOC,KAAK,QAAQ,WAAW;AACtD,SAASC,eAAeC,aAAa,EAAgCC,aAAaC,WAAW,QAAQ,WAAW;AAEhH,SAASC,OAAO,QAAQ,mCAAmC;AAC3D,SAASC,KAAK,QAAQ,4BAA4B;AAYlD,SAASC,cAAc,QAAQ,qCAAqC;AAEpE,SAASC,YAAY,QAAQ,mCAAmC;AAChE,SACEC,UAAU,EAEVC,uBAAuB,EACvBC,SAAS,EACTC,UAAU,EAGVC,aAAa,EACbC,YAAY,EACZC,yBAAyB,EACzBC,wCAAwC,EAExCC,iDAAiD,EACjDC,8CAA8C,EAC9CC,cAAc,EACdC,MAAM,EACNC,cAAc,EACdC,iBAAiB,EACjBC,kBAAkB,EAClBC,sBAAsB,EACtBC,iBAAiB,EACjBC,kBAAkB,QACb,wBAAwB;AAC/B,SAASC,0BAA0B,QAAQ,4BAA4B;AACvE,SAASC,OAAO,QAAQ,qCAAqC;AAG7D,OAAO,MAAMC,2CAAuFjC,MAAMkC,UAAU,CAGlH,CAACC,QAAQ;IAAEC,oBAAoB;AAAU,CAAC,EAAEC;QAiCzCF,oBACCA,qBAGyEA,qBAGNA;IAvCvE,MAAMG,YAA4B,EAAE;IACpC,MAAMC,aAAqB7B,MAAM;IACjC,MAAM8B,SAAkBhB;IACxB,MAAMiB,aACJN,MAAMO,IAAI,IAAKP,MAAMO,IAAI,CAAEC,MAAM,GAAG,IAC/B1B,cAAckB,MAAMO,IAAI,AAAC,CAAC,EAAE,CAACE,CAAC,EAAE,QACjC5B,WAAW6B,WAAW;IAC5B,MAAMC,aACJX,MAAMO,IAAI,IAAKP,MAAMO,IAAI,CAAEC,MAAM,GAAG,IAC/B1B,cAAckB,MAAMO,IAAI,AAAC,CAAC,EAAE,CAACK,CAAC,EAAE,SACjChC,UAAUiC,UAAU;IAC1B,MAAMC,gBAAwBvC,MAAM;IACpC,IAAIwC,UAAiD,EAAE;IACvD,IAAIC,aAAqB;IACzB,IAAIC,UAAoB,EAAE;IAC1B,IAAIC;IACJ,IAAIC;IACJ,IAAIC;IACJ,IAAIC;IACJ,IAAIC;IACJ,8DAA8D;IAC9D,IAAIC;IACJ,IAAIC;IACJ,IAAIC,gBAAwB/B;QACAM;IAA5B,IAAI0B,gBAAwB1B,CAAAA,sBAAAA,MAAM2B,YAAY,cAAlB3B,iCAAAA,sBAAsB;IAClD,MAAM4B,oBAAoB/D,MAAMgE,MAAM,CAAQ;IAC9C,MAAMC,WAAmB;IACzB,MAAMC,cAAclE,MAAMgE,MAAM,CAAkB;IAElD,MAAM,CAACG,OAAOC,SAAS,GAAGpE,MAAMqE,QAAQ,CAAS;IACjD,MAAM,CAACC,kBAAkBC,oBAAoB,GAAGvE,MAAMqE,QAAQ,CAAS;IACvE,MAAM,CAACG,kBAAkBC,oBAAoB,GAAGzE,MAAMqE,QAAQ,CAC5D,EAAClC,qBAAAA,MAAMuC,WAAW,cAAjBvC,yCAAAA,mBAAmBwC,eAAe,KAAIxC,MAAMuC,WAAW,CAACC,eAAe,CAAChC,MAAM,GAAG,KAChFR,EAAAA,sBAAAA,MAAMuC,WAAW,cAAjBvC,0CAAAA,oBAAmByC,cAAc,MAAKC;IAE1C,MAAM,CAACC,iBAAiBC,mBAAmB,GAAG/E,MAAMqE,QAAQ,CAAU;QACOlC;IAA7E,MAAM,CAAC6C,qBAAqBC,uBAAuB,GAAGjF,MAAMqE,QAAQ,CAASlC,CAAAA,qCAAAA,sBAAAA,MAAMuC,WAAW,cAAjBvC,0CAAAA,oBAAmByC,cAAc,cAAjCzC,+CAAAA,oCAAqC;IAClH,MAAM,CAAC+C,eAAeC,iBAAiB,GAAGnF,MAAMqE,QAAQ,CAAS;IACjE,MAAM,CAACe,eAAeC,iBAAiB,GAAGrF,MAAMqE,QAAQ,CAAS;IACjE,MAAM,CAACM,iBAAiBW,mBAAmB,GAAGtF,MAAMqE,QAAQ,CAAWlC,EAAAA,sBAAAA,MAAMuC,WAAW,cAAjBvC,0CAAAA,oBAAmBwC,eAAe,KAAI,EAAE;IAC/G,MAAM,CAACY,uBAAuBC,yBAAyB,GAAGxF,MAAMqE,QAAQ;IACxE,MAAM,CAACoB,0BAA0BC,4BAA4B,GAAG1F,MAAMqE,QAAQ;IAC9E,MAAM,CAACsB,eAAeC,eAAe,GAAG5F,MAAMqE,QAAQ,CAAU;IAChE,MAAM,CAACwB,eAAeC,iBAAiB,GAAG9F,MAAMqE,QAAQ,CAAC;QAAEzB,GAAG;QAAGG,GAAG;IAAE;IACtE,MAAMgD,eAAe/F,MAAMgE,MAAM,CAAyC;IAE1EhE,MAAMgG,SAAS,CAAC;QACd,IAAID,aAAaE,OAAO,EAAE;gBAEJC,wBAAwC/D;YAD5D,MAAM+D,YAAYH,aAAaE,OAAO;YACtC,IAAI,CAAC1E,gBAAe2E,yBAAAA,UAAUxB,WAAW,cAArBwB,6CAAAA,uBAAuBvB,eAAe,GAAExC,qBAAAA,MAAMuC,WAAW,cAAjBvC,yCAAAA,mBAAmBwC,eAAe,GAAG;oBAC5ExC;gBAAnBmD,mBAAmBnD,EAAAA,sBAAAA,MAAMuC,WAAW,cAAjBvC,0CAAAA,oBAAmBwC,eAAe,KAAI,EAAE;YAC7D;QACF;QACAoB,aAAaE,OAAO,GAAG9D;IACzB,GAAG;QAACA;KAAM;IAEVnC,MAAMmG,mBAAmB,CACvBhE,MAAMiE,YAAY,EAClB;YACkBrC;YAAAA;eADX;YACLsC,gBAAgBtC,CAAAA,6CAAAA,6BAAAA,kBAAkBkC,OAAO,cAAzBlC,iDAAAA,2BAA2BsC,cAAc,cAAzCtC,uDAAAA,4CAA6C;YAC7D/B,SAAS,CAACsE;oBACOvC,4BAA2CG;gBAA1D,OAAOlC,SAAQ+B,6BAAAA,kBAAkBkC,OAAO,cAAzBlC,iDAAAA,2BAA2BsC,cAAc,GAAEnC,sBAAAA,YAAY+B,OAAO,cAAnB/B,0CAAAA,oBAAqBqC,KAAK,EAAE/D,QAAQ8D;YAChG;QACF;OACA,EAAE;IAGJ,SAASE;QACPtD,UAAUf,MAAMO,IAAI,IAAI,EAAE;QAC1BS,aAAahB,MAAMsE,SAAS,IAAI;QAChC,MAAMC,iBAA2B;YAC/BhF,kBAAkBD,eAAekF,MAAM;YACvCjF,kBAAkBD,eAAemF,MAAM;YACvClF,kBAAkBD,eAAeoF,MAAM;YACvCnF,kBAAkBD,eAAeqF,MAAM;SACxC;QACD1D,UAAUjB,MAAM4E,MAAM,IAAKL;IAC7B;IAEA,SAASM,YAAYC,OAAgB;QACnC5D,WAAW4D;IACb;IAEA,SAASC,0BAA0BC,KAA0C;QAC3E,MAAM,EAAEC,iBAAiB,KAAK,EAAE,GAAGjF;QACnC,IAAIkF,qBAAqB;QACzBlF,MAAMO,IAAI,CAAE4E,OAAO,CAAC,CAACC,YAAiDC;YACpE,IAAID,WAAWxE,CAAC,KAAKoE,MAAMpE,CAAC,EAAE;gBAC5BsE,qBAAqBG;YACvB;QACF;QACA,wDAAwD;QACxD,IAAIrD;QACJ,IAAIiD,gBAAgB;YAClB,oEAAoE;YACpE,gEAAgE;YAChEjD,QAAQhC,MAAM4E,MAAM,GAAGU,gBAAgB,KAAKvG,aAAa,GAAG;QAC9D,OAAO;YACLiD,QAAQgD,MAAMhD,KAAK,GAAGgD,MAAMhD,KAAK,GAAGhC,MAAM4E,MAAM,GAAGU,gBAAgBN,MAAMvE,CAAC,IAAI1B,aAAamG,oBAAoB;QACjH;QACA,qBACE,wDACE,oBAACzG;YACC8G,QAAQP,MAAMQ,gBAAgB,IAAIR,MAAMvE,CAAC,CAACgF,QAAQ;YAClDC,QAAQV,MAAMU,MAAM;YACpBC,QAAQX,MAAMY,gBAAgB,IAAIZ,MAAMpE,CAAC;YACzCoB,OAAOA;YACP6D,SAAS7F,MAAM6F,OAAO;YACtBnC,eAAeA;YACfF,eAAeA;;IAIvB;IAEA,wDAAwD;IACxD,SAASsC,eAAe9F,KAA2C;QACjE,OAAOA,QAAQ+E,0BAA0B/E,SAAS;IACpD;IAEA,SAAS+F;QACP,OAAO/F,MAAMgG,2BAA2B,GACpChG,MAAMgG,2BAA2B,CAAC5C,uBAAuB0C,kBACzD;IACN;IAEA,SAASG,cACPC,MAAmB,EACnBC,MAAgC,EAChCC,eAAuB,EACvBC,cAAsB,EACtBC,QAA4B,EAC5BC,QAA4B;QAE5B,MAAMC,mBAAmB/G,uBAAuBsB;QAChD,MAAM0F,cAAcjH,mBAAmBgH,kBAAkB1E;QACzDP,gCAAgCkF,YAAYC,kBAAkB;QAC9DlF,gCAAgCiF,YAAYE,kBAAkB;QAE9D,MAAM,EAAEC,SAAS,EAAEC,SAAS,EAAE,GAC5BlG,eAAe/B,UAAU8B,WAAW,GAChCoG,WAAWV,iBAAiBC,gBAAgB,QAC5CS,WAAWV,iBAAiBC,gBAAgB;QAClD,MAAMU,SAASH,UAAUI,KAAK;QAC9B,IAAIC,UAAwB,EAAE;QAC9B,mGAAmG;QACnG,IAAIF,MAAM,CAAC,EAAE,GAAGA,MAAM,CAAC,EAAE,EAAE;YACzBE,UAAUT,iBACPU,GAAG,CAACC,CAAAA,gBACHxG,eAAe/B,UAAU8B,WAAW,GAChC0G,mBACEhB,iBACAC,gBACAC,UACAC,UACAY,eACAP,WACAC,aAEFQ,kBACEjB,iBACAC,gBACAC,UACAC,UACAY,eACAP,WACAC,YAGPS,IAAI;QACT;QAEA,OAAQnG,QAAQ8F;IAClB;IAEA,SAAS3B;QACP,MAAMiC,YAAYtG,QAAQT,MAAM,IAAI,IAAI,IAAI,IAAKS,CAAAA,QAAQT,MAAM,GAAG,CAAA;QAClE,MAAM,EAAEyE,iBAAiB,KAAK,EAAE,GAAGjF;QACnC,IAAIiF,gBAAgB;YAClB,OAAO,CAACuC;gBACN,MAAM,EAAE5C,MAAM,EAAE,GAAG5E;gBACnB,OAAO4E,UAAUA,OAAOpE,MAAM,GAAG,IAAIoE,MAAM,CAAC,EAAE,GAAGrF,kBAAkBD,eAAemI,OAAO;YAC3F;QACF;QACA,MAAMC,eAAe,EAAE;QACvB,IAAK,IAAIC,IAAI,GAAGA,IAAI1G,QAAQT,MAAM,EAAEmH,IAAK;YACvCD,aAAaE,IAAI,CAACL,YAAYI,IAAItG;QACpC;QACA,MAAMwG,aAAa1J,gBAAwB2J,MAAM,CAACJ,cAAcV,KAAK,CAAC/F;QACtE,OAAO4G;IACT;IAEA,SAASE,aAAaC,OAAuB,EAAEC,WAAmB;QAChE9H,UAAUyH,IAAI,CAAC;YAAEvC,OAAO4C;YAAaC,YAAYF;QAAQ;IAC3D;IAEA,SAASG,YACPnD,KAA0C,EAC1C,wDAAwD;IACxDhD,KAAa,EACboG,UAAoD;QAEpDA,WAAWC,OAAO;QAClB,wDAAwD;QACxD,IAAI,AAAChG,CAAAA,qBAAqB,SAASiG,qBAAqBtD,MAAMU,MAAM,CAAA,KAAMpE,wBAAwB0D,OAAO;YACvG1D,sBAAsB0D;YACtBvB,eAAe;YACf8E,gBAAgBH,WAAWI,OAAO,EAAEJ,WAAWK,OAAO;YACtDrG,oBAAoB4C,MAAMvE,CAAC;YAC3BqC,uBAAuBkC,MAAMU,MAAM;YACnCzD,SAASjC,MAAMiF,cAAc,IAAIjF,MAAM0I,cAAc,GAAG1G,QAAQgD,MAAMhD,KAAK;YAC3E,+FAA+F;YAC/FgB,iBAAiBgC,MAAMY,gBAAgB,IAAKZ,MAAMpE,CAAC,CAAC6E,QAAQ;YAC5DvC,iBAAiB8B,MAAMQ,gBAAgB,IAAIR,MAAMvE,CAAC,CAACgF,QAAQ;YAC3DpC,yBAAyB2B;YACzBzB,4BAA4ByB,MAAM1B,wBAAwB;QAC5D;IACF;IAEA,SAASqF;QACPlF,eAAe;IACjB;IAEA,SAASmF;QACPtH,sBAAsB;QACtBmC,eAAe;IACjB;IAEA,wDAAwD;IACxD,SAASoF,YACPC,KAAgD,EAChD9D,KAA0C,EAC1C+D,mBAA2B,EAC3B/G,KAAa;QAEb,IAAIgH,KAAK;QACT,IAAIC,KAAK;QAET,MAAMC,aAAa,AAACJ,MAAMK,MAAM,CAAoBC,qBAAqB;QACzEJ,KAAKE,WAAWG,IAAI,GAAGH,WAAWI,KAAK,GAAG;QAC1CL,KAAKC,WAAWK,GAAG,GAAGL,WAAWM,MAAM,GAAG;QAC1CjB,gBAAgBS,IAAIC;QACpB,IAAI,AAAC5G,CAAAA,qBAAqB,SAASiG,qBAAqBtD,MAAMU,MAAM,CAAA,KAAMpE,wBAAwB0D,OAAO;YACvG,wDAAwD;YACxD7E,UAAUgF,OAAO,CAAC,CAACsE,KAAmBpE;gBACpC,IAAI0D,wBAAwB1D,OAAO;oBACjC5B,eAAe;oBACfX,uBAAuBkC,MAAMU,MAAM;oBACnCtD,oBAAoB4C,MAAMvE,CAAC;oBAC3BwB,SAASjC,MAAMiF,cAAc,GAAGjD,QAAQgD,MAAMhD,KAAK;oBACnDgB,iBAAiBgC,MAAMY,gBAAgB,IAAIZ,MAAMpE,CAAC,CAAC6E,QAAQ;oBAC3DvC,iBAAiB8B,MAAMQ,gBAAgB,IAAKR,MAAMvE,CAAC,CAACgF,QAAQ;oBAC5DpC,yBAAyB2B;oBACzBzB,4BAA4ByB,MAAM1B,wBAAwB;gBAC5D;YACF;QACF;IACF;IAEA,SAASwD,WACPV,eAAuB,EACvBC,cAAsB,EACtBqD,cAAuB;QAGvB,MAAMC,OAAOpI;QACb,MAAMqI,OAAOpI;QACb,MAAMqI,UAAU;YAACC,KAAK9L,GAAG,CAAC8D,UAAU8H;YAAOE,KAAKhM,GAAG,CAACgE,UAAU6H;SAAM;QACpE,IAAID,gBAAgB;YAClB,MAAMK,OAAOhM,MAAMgD,SAAS,CAACiE,QAA+CA,MAAMpE,CAAC;YACnF,MAAMoJ,OAAO/L,MAAM8C,SAAS,CAACiE,QAA+CA,MAAMpE,CAAC;YACnF,MAAMqJ,aAAaH,KAAKhM,GAAG,CAACiM,MAAM/J,MAAMkK,SAAS,IAAI;YACrD,6CAA6C;YAC7C,MAAMC,WAAWnK,MAAMoK,SAAS,IAAI;YACpC,MAAMC,aAAaP,KAAK9L,GAAG,CAACgM,MAAMG;YAClC,MAAMvD,YAAYzI,gBACf2J,MAAM,CAAC+B,SACPS,IAAI,GACJtD,KAAK,CAAC;gBAAC9F,SAASmI,IAAI;gBAAGhD,iBAAiBnF,SAASqJ,KAAK;aAAE;YAC3D,MAAM1D,YAAY1I,gBACf2J,MAAM,CAAC;gBAACuC;gBAAYJ;aAAW,EAC/BjD,KAAK,CAAC;gBAACZ,kBAAmBlF,CAAAA,SAASsJ,MAAM,GAAI/I,aAAY;gBAAIP,SAASqI,GAAG,GAAI9H;aAAc;YAC9F,OAAO;gBAAEmF;gBAAWC;YAAU;QAChC,OAAO;YACL,sEAAsE;YACtE,2DAA2D;YAC3D,kDAAkD;YAClD,MAAMA,YAAYxI,cACfyJ,MAAM,CAAC1G,cACP4F,KAAK,CAAC;gBAACZ,kBAAmBlF,CAAAA,SAASsJ,MAAM,GAAI/I,aAAY;gBAAIP,SAASqI,GAAG,GAAI9H;aAAc,EAC3FgJ,OAAO,CAAC/I;YAEX,MAAMkF,YAAYzI,gBACf2J,MAAM,CAAC+B,SACPS,IAAI,GACJtD,KAAK,CAAC;gBAAC9F,SAASmI,IAAI;gBAAGhD,iBAAiBnF,SAASqJ,KAAK;aAAE;YAC3D,OAAO;gBAAE3D;gBAAWC;YAAU;QAChC;IACF;IAEA,SAASO,mBACPhB,eAAuB,EACvBC,cAAsB,EACtBC,QAAoB,EACpBC,QAAoB,EACpBY,aAAoD,EACpD,8DAA8D;IAC9DP,SAAc,EACd,8DAA8D;IAC9DC,SAAc;QAEd,MAAM,EAAE5B,iBAAiB,KAAK,EAAE,GAAGjF;QACnC,MAAM0K,aAAoD;eAAIvD;SAAc;QAC5EuD,WAAWC,IAAI,CAAC,CAACC,GAAGC;YAClB,MAAMC,SAAS,OAAOF,EAAEhK,CAAC,KAAK,WAAWgK,EAAEhK,CAAC,GAAGmK,WAAWH,EAAEhK,CAAC;YAC7D,MAAMoK,SAAS,OAAOH,EAAEjK,CAAC,KAAK,WAAWiK,EAAEjK,CAAC,GAAGmK,WAAWF,EAAEjK,CAAC;YAC7D,OAAOoK,SAASF;QAClB;QAEA,IAAIG,oBAAoB;QACxB,IAAIC,oBAAoB;QACxB,IAAIC,YAAY;QAEhB,MAAMC,oBAAoBjE,cAAckE,MAAM,CAC5C,CAACrG,QAA+CA,MAAMvE,CAAC,IAAIqB,UAC3DtB,MAAM;QACR,MAAM8K,oBAAoBnE,cAAc3G,MAAM,GAAG4K;QACjD,IAAIG,sBAAsB;QAC1B,IAAIC,sBAAsB;QAE1B,MAAMC,OAAOf,WAAWxD,GAAG,CAAC,CAAClC,OAA4CK;YACvE,IAAIqG,kBAAkB;YACtB,IAAI/I,mBAAmBN,kBAAkB;gBACvCqJ,kBAAkBpD,qBAAqBtD,MAAMU,MAAM;YACrD;YACA,IAAIV,MAAMvE,CAAC,IAAIqB,UAAU;gBACvB,EAAEyJ;YACJ;YACA,IAAIvG,MAAMvE,CAAC,GAAGqB,UAAU;gBACtB,EAAE0J;YACJ;YACA,MAAMG,YAAYtL,SACdgG,iBACCnF,CAAAA,SAASqJ,KAAK,GAAIT,KAAKhM,GAAG,CAAC8I,UAAU5B,MAAMvE,CAAC,GAAGqB,WAAW8E,UAAU9E,aAAaZ,SAASmI,IAAI,IAC/FS,KAAK9L,GAAG,CAAC4I,UAAU5B,MAAMvE,CAAC,GAAGqB,WAAW8E,UAAU9E;YACtD,MAAMwC,YAAoBwF,KAAKhM,GAAG,CAAC+I,UAAU7B,MAAMpE,CAAC,GAAG;YACvD,IAAI0D,YAAY,GAAG;gBACjB,qBAAO,oBAACzG,MAAM+N,QAAQ;oBAACC,KAAK7G,MAAMvE,CAAC;mBAAE;YACvC;YACA,IAAIqL;YACJ,IAAI7G,gBAAgB;gBAClB,oEAAoE;gBACpE,gEAAgE;gBAChE6G,aAAa9L,MAAM4E,MAAM,GAAGU,gBAAgB,KAAKvG,aAAa,GAAG;YACnE,OAAO;gBACL+M,aAAa9L,MAAM4E,MAAM,GAAGU,gBAAgBN,MAAMvE,CAAC,IAAI1B,aAAasG,OAAO;YAC7E;YAEAyG,aAAa9G,MAAMhD,KAAK,IAAI,CAACiD,iBAAiBD,MAAMhD,KAAK,GAAG8J;YAE5D,MAAMC,eAAejC,KAAKkC,GAAG,CAACpF,UAAUuE,YAAYrJ,YAAY8E,UAAU9E;YAC1EqJ,YAAYrJ,WAAYmJ,qBAAqBc,eAAiBb,qBAAqBa;YACnF,MAAME,eAAenC,KAAKkC,GAAG,CAACpF,UAAU5B,MAAMvE,CAAC,GAAGqB,YAAY8E,UAAU9E;YACxE,MAAMoK,cACJD,eAAe,KACd,CAAA,AAACjH,MAAMvE,CAAC,GAAGqB,YAAYyJ,wBAAwBH,qBAC7CpG,MAAMvE,CAAC,GAAGqB,YAAasJ,CAAAA,sBAAsB,KAAKI,sBAAsB,CAAA,CAAE,IACzE,IACA;YACN,MAAMW,cACJF,eAAe,KACd,CAAA,AAACjH,MAAMvE,CAAC,GAAGqB,YAAawJ,CAAAA,sBAAsB,KAAKC,sBAAsB,CAAA,KACvEvG,MAAMvE,CAAC,GAAGqB,YAAY0J,wBAAwBF,iBAAiB,IAC9D,IACA;YACN,IAAIc,SAAStK;YACb,IAAIzB,QAAQ;gBACV+L,SAASpH,MAAMvE,CAAC,GAAGqB,WAAW6J,YAAYV,oBAAoBU,YAAYT;YAC5E,OAAO;gBACLkB,SAASpH,MAAMvE,CAAC,GAAGqB,WAAW6J,YAAYV,oBAAoBU,YAAYT;YAC5E;YACAC,YAAYnG,MAAMvE,CAAC;YAEnB,qBACE,oBAAC5C,MAAM+N,QAAQ;gBAACC,KAAK,GAAGxG,MAAM,CAAC,EAAEL,MAAMvE,CAAC,EAAE;6BACxC,oBAAC4L;gBACCR,KAAK7G,MAAMpE,CAAC;gBACZH,GAAG2L;gBACHxL,GAAGiG,UAAU7B,MAAMpE,CAAC,IAAII,aAAa;gBACrCsL,qBAAmBZ;gBACnBpC,OAAO2C,eAAgB5L,CAAAA,SAAS8L,cAAcD,WAAU;gBACxD1C,QAAQxI;gBACRuL,KAAK,CAACC;oBACJzE,aAAayE,GAAGxH,MAAMU,MAAM;gBAC9B;gBACA+G,IAAIzM,MAAM0M,YAAY,GAAG,IAAI;gBAC7BC,SAAS3H,MAAM2H,OAAO;gBACtBC,aAAa,CAAC9D,QAAoDX,YAAYnD,OAAO8G,YAAYhD;gBACjG+D,cAAYC,cAAc9H;gBAC1B+H,MAAK;gBACLC,mBAAiB,CAAC,OAAO,EAAE5M,YAAY;gBACvC6M,cAActE;gBACduE,SAASpE,CAAAA,QAASD,YAAYC,OAAO9D,OAAOK,OAAOyG;gBACnDqB,QAAQxE;gBACRyE,MAAMtB;gBACNuB,SAAS3B,kBAAkB,IAAI;gBAC/B4B,UAAUtI,MAAMU,MAAM,KAAK,KAAK,IAAIhD;;QAI5C;QACA,OAAO+I;IACT;IAEA,SAAS8B;YAEPvN;QADA,MAAMwN,OAAwC,CAAC;SAC/CxN,cAAAA,MAAMO,IAAI,cAAVP,kCAAAA,YAAYmF,OAAO,CAAC,CAACH;YACnBwI,IAAI,CAACxI,MAAMpE,CAAC,CAAC,GAAGoE,MAAMpE,CAAC;QACzB;QACA,MAAM6M,UAAUC,OAAOC,MAAM,CAACH;QAC9B,OAAOC;IACT;IAEA,SAASG,+BAA+BrN,IAAuB,EAAEsN,UAAkB,EAAEC,YAAoB;QACvG,MAAMC,SAASnO,2BAA2BW;QAC1C,IAAI,CAACwN,UAAUA,MAAM,CAAC,EAAE,KAAK,GAAG;YAC9B,OAAO;QACT;QACA,MAAMC,kBAAkBD,MAAM,CAAC,EAAE;QACjC,IAAI/G,QAAQ+G,MAAM,CAAC,EAAE;QACrB,MAAMhE,OAAOhM,MAAMgD,SAAS,CAACiE,QAA+CA,MAAMpE,CAAC;QACnF,kGAAkG;QAClG,yCAAyC;QACzCoG,QAAQ8C,KAAKhM,GAAG,CAACkJ,OAAO+C;QACxB,mHAAmH;QACnH,+CAA+C;QAC/C,MAAMkE,WAAWnE,KAAKoE,KAAK,CACzB,AAACL,aAAaG,kBAAmB,CAAA,IAAIF,YAAW,IAAO9G,CAAAA,QAAQgH,kBAAmB,CAAA,IAAIF,YAAW,CAAC;QAEpG,OAAOG;IACT;IAEA,SAASE,uCAAuC/H,eAAuB;QACrE3E,gBAAgB/B;QAChB,MAAM+N,UAAUF;QAChB,wEAAwE,GACxE7L,gBAAgBA,kBAAkB,IAAI,OAAOA;QAC7C,MAAM0M,aAAa1M,gBAAiB,CAAA,IAAIA,aAAY;QACpD,MAAM2M,UAAUZ,QAAQjN,MAAM,GAAG,AAACiN,CAAAA,QAAQjN,MAAM,GAAG,CAAA,IAAK4N;QACxD,4CAA4C;QAC5C,MAAME,cAAclI,kBAAmBlF,CAAAA,SAASqI,GAAG,GAAI7J,iBAAgB,IAAMwB,CAAAA,SAASsJ,MAAM,GAAI9K,iBAAgB;QAChH,IAAIiB,eAAe/B,UAAUiC,UAAU,EAAE;YACvC,mCAAmC;YACnCG,aACEhB,MAAMsE,SAAS,IAAIsJ,+BAA+BH,SAA8Ba,aAAa5M;YAC/FV,aAAa8I,KAAKhM,GAAG,CAACkD,YAAY;YAClCS,iBAAiBT,aAAa;QAChC,OAAO;YACL,uCAAuC;YACvCA,aAAahB,MAAMsE,SAAS,IAAIgK,cAAcD;YAC9C,kFAAkF,GAClF,MAAME,YAAYF,UAAUrN;YAC5B,IAAIsN,eAAeC,WAAW;gBAC5B,4EAA4E;gBAC5E9M,gBAAgB/B,oBAAoB,AAAC4O,CAAAA,cAAcC,SAAQ,IAAK;YAClE;QACF;QAEA,OAAO;YACL,GAAGrN,QAAQ;YACXqI,KAAKrI,SAASqI,GAAG,GAAI9H;YACrB+I,QAAQtJ,SAASsJ,MAAM,GAAI/I;QAC7B;IACF;IAEA,SAAS4F,kBACPjB,eAAuB,EACvBC,cAAsB,EACtBC,QAAoB,EACpBC,QAAoB,EACpBY,aAAoD,EACpD,8DAA8D;IAC9DP,SAAc,EACd,8DAA8D;IAC9DC,SAAc;QAEd,MAAM,EAAE5B,iBAAiB,KAAK,EAAE,GAAGjF;QACnC,IAAIiL,oBAAoB;QACxB,IAAIC,oBAAoB;QACxB,IAAIC,YAAY;QAChB,MAAMC,oBAAoBjE,cAAckE,MAAM,CAC5C,CAACrG,QAA+CA,MAAMvE,CAAC,IAAIqB,UAC3DtB,MAAM;QACR,MAAM8K,oBAAoBnE,cAAc3G,MAAM,GAAG4K;QACjD,IAAIG,sBAAsB;QAC1B,IAAIC,sBAAsB;QAC1B,MAAMC,OAAOtE,cAAcD,GAAG,CAAC,CAAClC,OAA4CK;YAC1E,IAAIqG,kBAAkB;YACtB,IAAI/I,mBAAmBN,kBAAkB;gBACvCqJ,kBAAkBpD,qBAAqBtD,MAAMU,MAAM;YACrD;YACA,IAAIV,MAAMvE,CAAC,IAAIqB,UAAU;gBACvB,EAAEyJ;YACJ;YACA,IAAIvG,MAAMvE,CAAC,GAAGqB,UAAU;gBACtB,EAAE0J;YACJ;YACA,MAAMG,YAAYtL,SACdgG,iBACCnF,CAAAA,SAASqJ,KAAK,GAAIT,KAAKhM,GAAG,CAAC8I,UAAU5B,MAAMvE,CAAC,GAAGqB,WAAW8E,UAAU9E,aAAaZ,SAASmI,IAAI,IAC/FS,KAAK9L,GAAG,CAAC4I,UAAU5B,MAAMvE,CAAC,GAAGqB,WAAW8E,UAAU9E;YACtD,MAAMwC,YAAoBwF,KAAKhM,GAAG,CAAC+I,UAAU7B,MAAMpE,CAAC,GAAG;YACvD,IAAI0D,YAAY,GAAG;gBACjB,qBAAO,oBAACzG,MAAM+N,QAAQ;oBAACC,KAAK7G,MAAMvE,CAAC;mBAAE;YACvC;YACA,IAAIqL;YACJ,IAAI7G,gBAAgB;gBAClB,oEAAoE;gBACpE,gEAAgE;gBAChE6G,aAAa9L,MAAM4E,MAAM,GAAGU,gBAAgB,KAAKvG,aAAa,GAAG;YACnE,OAAO;gBACL+M,aAAa9L,MAAM4E,MAAM,GAAGU,gBAAgBN,MAAMvE,CAAC,IAAI1B,aAAasG,OAAO;YAC7E;YAEAyG,aAAa9G,MAAMhD,KAAK,IAAI,CAACiD,iBAAiBD,MAAMhD,KAAK,GAAG8J;YAC5D,MAAMC,eAAejC,KAAKkC,GAAG,CAACpF,UAAUuE,YAAYrJ,YAAY8E,UAAU9E;YAC1EqJ,YAAY,IAAKF,qBAAqBc,eAAiBb,qBAAqBa;YAC5E,MAAME,eAAenC,KAAKkC,GAAG,CAACpF,UAAU5B,MAAMvE,CAAC,GAAGqB,YAAY8E,UAAU9E;YACxE,MAAMoK,cACJD,eAAe,KACd,CAAA,AAACjH,MAAMvE,CAAC,GAAGqB,YAAYyJ,wBAAwBH,qBAC7CpG,MAAMvE,CAAC,GAAGqB,YAAasJ,CAAAA,sBAAsB,KAAKI,sBAAsB,CAAA,CAAE,IACzE,IACA;YACN,MAAMW,cACJF,eAAe,KACd,CAAA,AAACjH,MAAMvE,CAAC,GAAGqB,YAAawJ,CAAAA,sBAAsB,KAAKC,sBAAsB,CAAA,KACvEvG,MAAMvE,CAAC,GAAGqB,YAAY0J,wBAAwBF,iBAAiB,IAC9D,IACA;YACNH,YAAYnG,MAAMvE,CAAC;YACnB,IAAI2L,SAAStK;YACb,IAAIzB,QAAQ;gBACV+L,SAASpH,MAAMvE,CAAC,GAAGqB,WAAW6J,YAAYV,oBAAoBU,YAAYT;YAC5E,OAAO;gBACLkB,SAASpH,MAAMvE,CAAC,GAAGqB,WAAW6J,YAAYV,oBAAoBU,YAAYT;YAC5E;YACA,qBACE,oBAACrN,MAAM+N,QAAQ;gBAACC,KAAK,GAAGxG,MAAM,CAAC,EAAEL,MAAMvE,CAAC,EAAE;6BACxC,oBAAC4L;gBACCmC,WAAW,CAAC,YAAY,EAAE,MAAO3H,CAAAA,UAAU4H,SAAS,KAAKzN,UAAS,EAAG,CAAC,CAAC;gBACvE6K,KAAK7G,MAAMvE,CAAC;gBACZA,GAAG2L;gBACHxL,GAAGiG,UAAU7B,MAAMpE,CAAC;gBACpB6L,IAAIzM,MAAM0M,YAAY,GAAG,IAAI;gBAC7BpD,OAAO2C,eAAgB5L,CAAAA,SAAS8L,cAAcD,WAAU;gBACxD1C,QAAQxI;gBACRgM,mBAAiB,CAAC,OAAO,EAAE5M,YAAY;gBACvCyM,cAAYC,cAAc9H;gBAC1B+H,MAAK;gBACLR,KAAK,CAACC;oBACJzE,aAAayE,GAAGxH,MAAMU,MAAM;gBAC9B;gBACAiH,SAAS3H,MAAM2H,OAAO;gBACtBC,aAAa,CAAC9D,QAAoDX,YAAYnD,OAAO8G,YAAYhD;gBACjGmE,cAActE;gBACdwE,QAAQxE;gBACR2D,qBAAmBZ;gBACnB2B,SAAS3B,kBAAkB,IAAI;gBAC/BwB,SAASpE,CAAAA,QAASD,YAAYC,OAAO9D,OAAOK,OAAOyG;gBACnDsB,MAAMtB;gBACNwB,UAAUtI,MAAMU,MAAM,KAAK,KAAK,IAAIhD;;QAI5C;QACA,OAAO+I;IACT;IAEA,SAASiD,eAAeC,aAAqB;QAC3C,IAAI,CAACC,qBAAqB;YACxBhM,mBAAmB;YACnBE,uBAAuB6L;QACzB;IACF;IAEA,SAASE,eAAeC,eAAyB;QAC/C,IAAI,CAAC,CAACA,mBAAmB,CAACF,qBAAqB;YAC7ChM,mBAAmB;YACnBE,uBAAuB;YACvBR,oBAAoBwM,kBAAkB,QAAQF;QAChD;IACF;IAEA,SAASG,eAAexO,IAA2C;QACjE,MAAM,EAAE0E,cAAc,EAAE,GAAGjF;QAC3B,MAAMgP,UAAoB,EAAE;QAC5B,MAAMC,mBAA2C,CAAC;QAElD1O,KAAK4E,OAAO,CAAC,CAACH,OAA4CkK;YACxD,wDAAwD;YACxD,MAAMlN,QAAgBiD,iBAAkBjF,MAAM4E,MAAM,GAAGU,gBAAgB,KAAKvG,aAAa,GAAG,KAAMiG,MAAMhD,KAAK;YAE7GiN,gBAAgB,CAACjK,MAAMU,MAAM,CAAE,GAAG1D;QACpC;QACA0L,OAAOyB,OAAO,CAACF,kBAAkB9J,OAAO,CAAC,CAAC,CAAC8C,aAAajG,MAAM;YAC5D,qDAAqD;YACrD,MAAM0D,SAAiB;gBACrB0J,OAAOnH;gBACPjG;gBACAqN,aAAa;oBACXzG;oBACA8F,eAAezG;gBACjB;gBACA,wDAAwD;gBACxDqH,kBAAkB,CAACjN;oBACjBwM,eAAexM;gBACjB;YACF;YACA2M,QAAQpH,IAAI,CAAClC;QACf;QACA,MAAM6J,wBACJ,oBAACjR;YACCiR,SAASP;YACTQ,kBAAkBxP,MAAMyP,uBAAuB;YAC/CC,cAAc1P,MAAM2P,mBAAmB;YACtC,GAAG3P,MAAMuC,WAAW;YACrBqN,UAAUC;YACVC,WAAW/N;;QAGf,OAAOwN;IACT;IAEA,SAASX;QACP,OAAOvM;IACT;IAEA;;;;;GAKC,GACD,SAASiG,qBAAqB5C,MAAe;QAC3C,OAAOqK,wBAAwBC,QAAQ,CAACtK;IAC1C;IAEA,SAASqK;QACP,OAAOvN,gBAAgBhC,MAAM,GAAG,IAAIgC,kBAAkBK,sBAAsB;YAACA;SAAoB,GAAG,EAAE;IACxG;IAEA,SAASgN,yBACP,wDAAwD;IACxDrN,eAAyB,EACzBsG,KAA0C,EAC1CmH,aAAsB;YAElBjQ,oBAQAA;QARJ,KAAIA,qBAAAA,MAAMuC,WAAW,cAAjBvC,yCAAAA,mBAAmBkQ,wBAAwB,EAAE;YAC/C/M,mBAAmBX;YACnBM,uBAAuBmN,0BAAAA,oCAAAA,cAAeb,KAAK;QAC7C,OAAO;YACLjM,mBAAmBX,gBAAgB2N,KAAK,CAAC,CAAC;YAC1CrN,uBAAuBmN,0BAAAA,oCAAAA,cAAeb,KAAK;QAC7C;QACA9M,oBAAoBE,gBAAgBhC,MAAM,GAAG;QAC7C,KAAIR,sBAAAA,MAAMuC,WAAW,cAAjBvC,0CAAAA,oBAAmB4P,QAAQ,EAAE;YAC/B5P,MAAMuC,WAAW,CAACqN,QAAQ,CAACpN,iBAAiBsG,OAAOmH;QACrD;IACF;IAEA,SAASG,aAAaC,SAAoB;QACxC,IAAIA,aAAaA,UAAUC,iBAAiB,CAAC9P,MAAM,EAAE;YACnD,uCAAuC;YACvC,MAAM,EAAE8P,mBAAmBC,WAAW,EAAE,GAAGF;YAC3ChP,QAAQyI,KAAKhM,GAAG,CAACyS,WAAW,CAACA,YAAY/P,MAAM,GAAG,EAAE,EAAER,MAAMwQ,SAAS,IAAI;QAC3E;IACF;IACA,SAAS1D,cAAc9H,KAA0C;YAGxDA;QAFP,MAAMyL,SAASzL,MAAMQ,gBAAgB,IAAIR,MAAMvE,CAAC;QAChD,MAAMiQ,SAAS1L,MAAMY,gBAAgB,IAAIZ,MAAMpE,CAAC;QAChD,OAAOoE,EAAAA,kCAAAA,MAAM1B,wBAAwB,cAA9B0B,sDAAAA,gCAAgC2L,SAAS,KAAI,GAAGF,OAAO,EAAE,CAAC,GAAG,GAAGC,OAAO,CAAC,CAAC;IAClF;IAEA,SAASE;QACP,MAAM,EAAEC,UAAU,EAAEtQ,IAAI,EAAE,GAAGP;QAC7B,OAAO,AAAC6Q,CAAAA,aAAa,GAAGA,WAAW,EAAE,CAAC,GAAG,EAAC,IAAK,CAAC,0BAA0B,EAAEtQ,CAAAA,iBAAAA,2BAAAA,KAAMC,MAAM,KAAI,EAAE,OAAO,CAAC;IACxG;IAEA,SAASsQ;QACP,MAAMC,wCACJpQ,eAAe/B,UAAUiC,UAAU,IAAIb,MAAMC,kBAAkB,KAAK;QACtE,IAAI,CAAC8Q,uCAAuC;YAC1C,4FAA4F;YAC5F,MAAMC,eAAe;mBAAIjQ;aAAQ,CAACkQ,OAAO;YACzC,OAAOD,aAAa9J,GAAG,CAAC,CAAClC,QAA+CA,MAAMpE,CAAC;QACjF;QAEA,OAAOjB,mBAAmBuR,wBAAwBlR,MAAMC,kBAAkB;IAC5E;IAEA,SAASiR;QACP,MAAMC,mBAA6C,CAAC;QACpDpQ,QAAQoE,OAAO,CAACH,CAAAA;YACd,IAAI,CAACmM,gBAAgB,CAACnM,MAAMpE,CAAC,CAAC,EAAE;gBAC9BuQ,gBAAgB,CAACnM,MAAMpE,CAAC,CAAC,GAAG,EAAE;YAChC;YACAuQ,gBAAgB,CAACnM,MAAMpE,CAAC,CAAC,CAACgH,IAAI,CAAC5C,MAAMvE,CAAC;QACxC;QACA,OAAO0Q;IACT;IAEA,SAASC;QACP,OAAO,CAAEpR,CAAAA,MAAMO,IAAI,IAAIP,MAAMO,IAAI,CAACC,MAAM,GAAG,CAAA;IAC7C;IAEA,SAAS+H,gBAAgB8I,IAAY,EAAEC,IAAY;QACjD,MAAMC,YAAY,GAAG,+BAA+B;QACpD,MAAM,EAAE9Q,CAAC,EAAEG,CAAC,EAAE,GAAG8C;QAEjB,+BAA+B;QAC/B,MAAM8N,WAAW1H,KAAK2H,IAAI,CAAC3H,KAAK4H,GAAG,CAACL,OAAO5Q,GAAG,KAAKqJ,KAAK4H,GAAG,CAACJ,OAAO1Q,GAAG;QACtE,+EAA+E;QAC/E,IAAI4Q,WAAWD,WAAW;YACxB5N,iBAAiB;gBAAElD,GAAG4Q;gBAAMzQ,GAAG0Q;YAAK;YACpC7N,eAAe;QACjB;IACF;IAEA,SAASkO,uBACPC,MAA6C,EAC7C9M,OAAgB,EAChBwE,KAAa,EACbuI,SAAqB,EACrBC,KAAc,EACdC,SAAqB,EACrB9D,QAAgB,EAChB+D,UAAyC,EACzCC,MAAc;QAEd,IAAIC;QACJ,IAAIH,cAAclT,WAAW6B,WAAW,EAAE;YACxCwR,oBAAoBhT,kDAClB0S,QACA9M,SACAwE,OACAwI,OACAG,QACAnQ;QAEJ,OAAO;YACLoQ,oBAAoB;gBAAEC,aAAa;gBAAGC,WAAW;gBAAGC,aAAa;gBAAGC,WAAW;YAAE;QACnF;QACA,OAAOJ;IACT;IAEA,IAAI,CAACd,iBAAiB;QACpB/M;QACA,MAAMkO,eAAkC;YACtCvQ,OAAOA;YACP0D,QAAQ7C;YACR0C,QAAQxC;YACR4C,QAAQ1C,gBAAgBA,gBAAgBd;YACxC,GAAGnC,MAAMuS,YAAY;YACrB,GAAG5T,wBAAwB2E,yBAAyB;YACpDkP,eAAe;gBACbC,mBAAmB1M,4BAA4B,OAAOA,0BAA2BrD;gBACjFgQ,oBAAoB1S,MAAM2S,wBAAwB,GAC9C3S,MAAM2S,wBAAwB,CAACvP,yBAC/BV;YACN;YACAkQ,aAAa;YACbpP;YACAE;QACF;QACA,MAAMmP,aAAa;YACjBb,YAAYhS,MAAMgS,UAAU;YAC5Bc,YAAY9S,MAAM8S,UAAU;QAC9B;QAEA1R,eAAe0P;QACfzP,QAAQyI,KAAKhM,GAAG,CAACC,MAAMgD,SAAS,CAACiE,QAA+CA,MAAMvE,CAAC,GAAIT,MAAMwQ,SAAS,IAAI;QAC9G,MAAMuC,aAAyBhE,eAAehO;QAC9C,qBACE,oBAACvC;YACCmD,cAAcD;YACb,GAAG1B,KAAK;YACT6Q,YAAYD;YACZgB,QAAQ7Q;YACR8Q,WAAWnT,WAAWoB,0BAA0B;YAChDiS,WAAWzR;YACX0S,WAAWrS;YACXsS,uBAAuBtB;YACvBuB,6BAA6B9R;YAC7BmR,cAAcA;YACdM,YAAYA;YACZE,YAAYA;YACZI,aAAalU;YACbmU,mBAAmBjU;YACnBkU,kBAAkBrU;YAClBsU,UAAUtS;YACVuS,YAAY1O;YACZ2O,mBAAmBrF;YACnBsF,cAAcxN;YACdyN,aAAatD;YACbuD,mBAAmB/K;YACnB3E,cAAcrC;YACd,oCAAoC,GACpC,wDAAwD;YACxDgS,UAAU,CAAC5T;gBACT,qBACE,wDACE,oBAAC6T,WAAG1S;YAGV;;IAGN,OAAO;QACL,qBACE,oBAAC2S;YAAIC,IAAIjT;YAAeiM,MAAM;YAASiH,OAAO;gBAAE3G,SAAS;YAAI;YAAGR,cAAY;;IAEhF;AACF,GAAG;AACH/M,2BAA2BmU,WAAW,GAAG"}