{"version":3,"sources":["../src/components/GaugeChart/GaugeChart.tsx"],"sourcesContent":["'use client';\n\nimport * as React from 'react';\nimport { useGaugeChartStyles } from './useGaugeChartStyles.styles';\nimport { select as d3Select } from 'd3-selection';\nimport { arc as d3Arc } from 'd3-shape';\nimport { YValueHover } from '../../index';\nimport {\n  Points,\n  areArraysEqual,\n  formatScientificLimitWidth,\n  getAccessibleDataObject,\n  getColorFromToken,\n  getNextColor,\n  pointTypes,\n  useRtl,\n} from '../../utilities/index';\nimport { formatToLocaleString } from '@fluentui/chart-utilities';\nimport { SVGTooltipText } from '../../utilities/SVGTooltipText';\nimport { Legend, LegendShape, Legends, Shape, LegendContainer } from '../Legends/index';\nimport { GaugeChartVariant, GaugeValueFormat, GaugeChartProps, GaugeChartSegment } from './GaugeChart.types';\nimport { useFocusableGroup } from '@fluentui/react-tabster';\nimport { ChartPopover } from '../CommonComponents/ChartPopover';\nimport { ImageExportOptions } from '../../types/index';\nimport { toImage } from '../../utilities/image-export-utils';\n\nconst GAUGE_MARGIN = 16;\nconst LABEL_WIDTH = 36;\nconst LABEL_HEIGHT = 16;\nconst LABEL_OFFSET = 4;\nconst TITLE_OFFSET = 11;\nconst EXTRA_NEEDLE_LENGTH = 4;\nexport const ARC_PADDING = 2;\nexport const BREAKPOINTS = [\n  { minRadius: 52, arcWidth: 12, fontSize: 20 },\n  { minRadius: 70, arcWidth: 16, fontSize: 24 },\n  { minRadius: 88, arcWidth: 20, fontSize: 32 },\n  { minRadius: 106, arcWidth: 24, fontSize: 32 },\n  { minRadius: 124, arcWidth: 28, fontSize: 40 },\n  { minRadius: 142, arcWidth: 32, fontSize: 40 },\n];\n\nexport const calcNeedleRotation = (chartValue: number, minValue: number, maxValue: number): number => {\n  let needleRotation = ((chartValue - minValue) / (maxValue - minValue)) * 180;\n  if (needleRotation < 0) {\n    needleRotation = 0;\n  } else if (needleRotation > 180) {\n    needleRotation = 180;\n  }\n\n  return needleRotation;\n};\n\nexport const getSegmentLabel = (\n  segment: ExtendedSegment,\n  minValue: number,\n  maxValue: number,\n  variant?: GaugeChartVariant,\n  isAriaLabel: boolean = false,\n): string => {\n  if (isAriaLabel) {\n    return minValue === 0 && variant === 'single-segment'\n      ? `${segment.legend}, ${segment.size} out of ${maxValue} or ${((segment.size / maxValue) * 100).toFixed()}%`\n      : `${segment.legend}, ${segment.start} to ${segment.end}`;\n  }\n\n  return minValue === 0 && variant === 'single-segment'\n    ? `${segment.size} (${((segment.size / maxValue) * 100).toFixed()}%)`\n    : `${segment.start} - ${segment.end}`;\n};\n\nexport const getChartValueLabel = (\n  chartValue: number,\n  minValue: number,\n  maxValue: number,\n  chartValueFormat?: GaugeValueFormat | ((sweepFraction: [number, number]) => string),\n  forCallout: boolean = false,\n): string => {\n  if (forCallout) {\n    // When displaying the chart value as a percentage, use fractions in the callout, and vice versa.\n    // This helps clarify the actual value and avoid repetition.\n    return minValue !== 0\n      ? chartValue.toString()\n      : chartValueFormat === 'fraction'\n      ? `${((chartValue / maxValue) * 100).toFixed()}%`\n      : `${chartValue}/${maxValue}`;\n  }\n\n  return typeof chartValueFormat === 'function'\n    ? chartValueFormat([chartValue - minValue, maxValue - minValue])\n    : minValue !== 0\n    ? chartValue.toString()\n    : chartValueFormat === 'fraction'\n    ? `${chartValue}/${maxValue}`\n    : `${((chartValue / maxValue) * 100).toFixed()}%`;\n};\n\ninterface YValue extends Omit<YValueHover, 'y'> {\n  y?: string | number;\n}\nexport interface ExtendedSegment extends GaugeChartSegment {\n  start: number;\n  end: number;\n}\n\nexport const GaugeChart: React.FunctionComponent<GaugeChartProps> = React.forwardRef<HTMLDivElement, GaugeChartProps>(\n  (props, forwardedRef) => {\n    const _legendsRef = React.useRef<LegendContainer>(null);\n    const _getMargins = () => {\n      const { hideMinMax, chartTitle, sublabel } = props;\n      return {\n        left: (!hideMinMax ? LABEL_OFFSET + LABEL_WIDTH : 0) + GAUGE_MARGIN,\n        right: (!hideMinMax ? LABEL_OFFSET + LABEL_WIDTH : 0) + GAUGE_MARGIN,\n        top: (chartTitle ? TITLE_OFFSET + LABEL_HEIGHT : EXTRA_NEEDLE_LENGTH / 2) + GAUGE_MARGIN,\n        bottom: (sublabel ? LABEL_OFFSET + LABEL_HEIGHT : 0) + GAUGE_MARGIN,\n      };\n    };\n    const _margins: { left: number; right: number; top: number; bottom: number } = _getMargins();\n    const _legendsHeight: number = !props.hideLegend ? 32 : 0;\n    const _rootElem = React.useRef<HTMLDivElement | null>(null);\n    const _isRTL: boolean = useRtl();\n    const [width, setWidth] = React.useState<number>(140 + _getMargins().left + _getMargins().right);\n    const [height, setHeight] = React.useState<number>(70 + _getMargins().top + _getMargins().bottom + _legendsHeight);\n    const [hoveredLegend, setHoveredLegend] = React.useState<string>('');\n    const [selectedLegends, setSelectedLegends] = React.useState<string[]>(props.legendProps?.selectedLegends || []);\n    const [focusedElement, setFocusedElement] = React.useState<string | undefined>('');\n    const [isPopoverOpen, setPopoverOpen] = React.useState(false);\n    const [hoverXValue, setHoverXValue] = React.useState<string | number>('');\n    const [hoverYValues, setHoverYValues] = React.useState<YValue[]>([]);\n    const [refSelected, setRefSelected] = React.useState<HTMLElement | null>(null);\n    const prevPropsRef = React.useRef<GaugeChartProps | null>(null);\n    const _width = props.width || width;\n    const _height = props.height || height;\n    const _outerRadius: number = Math.min(\n      (_width - (_margins.left + _margins.right)) / 2,\n      _height - (_margins.top + _margins.bottom + _legendsHeight),\n    );\n    const { arcWidth, chartValueSize } = _getStylesBasedOnBreakpoint();\n    const _innerRadius: number = _outerRadius - arcWidth;\n    let _minValue!: number;\n    let _maxValue!: number;\n    let _segments!: ExtendedSegment[];\n    let _calloutAnchor: string = '';\n\n    React.useEffect(() => {\n      if (_rootElem.current) {\n        setWidth(_rootElem.current.clientWidth);\n        setHeight(_rootElem.current.clientHeight);\n      }\n    }, []);\n\n    React.useEffect(() => {\n      if (prevPropsRef.current) {\n        const prevProps = prevPropsRef.current;\n        if (!areArraysEqual(prevProps.legendProps?.selectedLegends, props.legendProps?.selectedLegends)) {\n          setSelectedLegends(props.legendProps?.selectedLegends || []);\n        }\n      }\n      prevPropsRef.current = props;\n    }, [props]);\n\n    React.useImperativeHandle(\n      props.componentRef,\n      () => ({\n        chartContainer: _rootElem.current,\n        toImage: (opts?: ImageExportOptions): Promise<string> => {\n          return toImage(_rootElem.current, _legendsRef.current?.toSVG, _isRTL, opts);\n        },\n      }),\n      [],\n    );\n\n    const classes = useGaugeChartStyles(props);\n    function _getStylesBasedOnBreakpoint() {\n      for (let index = BREAKPOINTS.length - 1; index >= 0; index -= 1) {\n        if (_outerRadius >= BREAKPOINTS[index].minRadius) {\n          return {\n            arcWidth: BREAKPOINTS[index].arcWidth,\n            chartValueSize: BREAKPOINTS[index].fontSize,\n          };\n        }\n      }\n      return {\n        arcWidth: BREAKPOINTS[0].arcWidth,\n        chartValueSize: BREAKPOINTS[0].fontSize,\n      };\n    }\n\n    function _processProps() {\n      const { minValue = 0, maxValue, segments, roundCorners } = props;\n\n      let total = minValue;\n      const processedSegments: ExtendedSegment[] = segments.map(\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        (segment: { size: number; legend: any; color: string; accessibilityData: any }, index: number) => {\n          const size = Math.max(segment.size, 0);\n          total += size;\n          return {\n            legend: segment.legend,\n            size,\n            color:\n              typeof segment.color !== 'undefined'\n                ? getColorFromToken(segment.color, false)\n                : getNextColor(index, 0, false),\n            accessibilityData: segment.accessibilityData,\n            start: total - size,\n            end: total,\n          };\n        },\n      );\n      if (typeof maxValue !== 'undefined' && total < maxValue) {\n        processedSegments.push({\n          legend: 'Unknown',\n          size: maxValue - total,\n          color: 'neutralLight',\n          start: total,\n          end: maxValue,\n        });\n        total = maxValue;\n      }\n\n      const arcGenerator = d3Arc()\n        .cornerRadius(roundCorners ? 3 : 0)\n        .padAngle(ARC_PADDING / _outerRadius)\n        .padRadius(_outerRadius);\n      const rtlSafeSegments = _isRTL ? Array.from(processedSegments).reverse() : processedSegments;\n      let prevAngle = -Math.PI / 2;\n      // eslint-disable-next-line @typescript-eslint/no-shadow\n      const arcs = rtlSafeSegments.map((segment, index) => {\n        const endAngle = prevAngle + (segment.size / (total - minValue)) * Math.PI;\n        const d = arcGenerator({\n          innerRadius: _innerRadius,\n          outerRadius: _outerRadius,\n          startAngle: prevAngle,\n          endAngle,\n        })!;\n        prevAngle = endAngle;\n        return {\n          d,\n          segmentIndex: _isRTL ? processedSegments.length - 1 - index : index,\n          startAngle: prevAngle - (segment.size / (total - minValue)) * Math.PI,\n          endAngle,\n        };\n      });\n\n      _minValue = minValue;\n      _maxValue = total;\n      _segments = processedSegments;\n\n      return {\n        arcs,\n      };\n    }\n\n    function _renderNeedle() {\n      const needleRotation = calcNeedleRotation(props.chartValue, _minValue, _maxValue);\n      const rtlSafeNeedleRotation = _isRTL ? 180 - needleRotation : needleRotation;\n      const strokeWidth = 2;\n      const halfStrokeWidth = strokeWidth / 2;\n      const needleLength = _outerRadius - _innerRadius + EXTRA_NEEDLE_LENGTH;\n      const needleId = `gauge-chart-needle`;\n      return (\n        <g transform={`rotate(${rtlSafeNeedleRotation}, 0, 0)`}>\n          <path\n            d={`\n            M 0,${-halfStrokeWidth - 3}\n            L ${-needleLength},${-halfStrokeWidth - 1}\n            A ${halfStrokeWidth + 1},${halfStrokeWidth + 1},0,0,0,${-needleLength},${halfStrokeWidth + 1}\n            L 0,${halfStrokeWidth + 3}\n            A ${halfStrokeWidth + 3},${halfStrokeWidth + 3},0,0,0,0,${-halfStrokeWidth - 3}\n          `}\n            id={needleId}\n            strokeWidth={strokeWidth}\n            className={classes.needle}\n            transform={`translate(${-_innerRadius + EXTRA_NEEDLE_LENGTH / 2})`}\n            data-is-focusable={true}\n            onFocus={e => _handleFocus(e, 'Needle', needleId)}\n            onBlur={_handleBlur}\n            onMouseEnter={e => _handleMouseOver(e, 'Needle', needleId)}\n            onMouseMove={e => _handleMouseOver(e, 'Needle', needleId)}\n            role=\"img\"\n            aria-label={\n              'Current value: ' + getChartValueLabel(props.chartValue, _minValue, _maxValue, props.chartValueFormat)\n            }\n          />\n        </g>\n      );\n    }\n\n    function _renderLegends() {\n      if (props.hideLegend) {\n        return null;\n      }\n\n      const legends: Legend[] = _segments.map((segment, index) => {\n        const color: string = segment.color || getNextColor(index, 0, false);\n\n        return {\n          title: segment.legend,\n          color,\n          hoverAction: () => {\n            setHoveredLegend(segment.legend);\n          },\n          onMouseOutAction: () => {\n            setHoveredLegend('');\n          },\n        };\n      });\n\n      return (\n        <div className={classes.legendsContainer}>\n          <Legends\n            legends={legends}\n            centerLegends\n            {...props.legendProps}\n            // eslint-disable-next-line react/jsx-no-bind\n            onChange={_onLegendSelectionChange}\n            legendRef={_legendsRef}\n          />\n        </div>\n      );\n    }\n\n    function _onLegendSelectionChange(\n      // eslint-disable-next-line @typescript-eslint/no-shadow\n      selectedLegends: string[],\n      event: React.MouseEvent<HTMLButtonElement>,\n      currentLegend?: Legend,\n    ): void {\n      if (props.legendProps?.canSelectMultipleLegends) {\n        setSelectedLegends(selectedLegends);\n      } else {\n        setSelectedLegends(selectedLegends.slice(-1));\n      }\n      if (props.legendProps?.onChange) {\n        props.legendProps.onChange(selectedLegends, event, currentLegend);\n      }\n    }\n\n    /**\n     * This function checks if the given legend is highlighted or not.\n     * A legend can be highlighted in 2 ways:\n     * 1. selection: if the user clicks on it\n     * 2. hovering: if there is no selected legend and the user hovers over it\n     */\n    function _legendHighlighted(legend: string) {\n      return _getHighlightedLegend().includes(legend!);\n    }\n\n    /**\n     * This function checks if none of the legends is selected or hovered.\n     */\n    function _noLegendHighlighted() {\n      return _getHighlightedLegend().length === 0;\n    }\n\n    function _getHighlightedLegend() {\n      return selectedLegends.length > 0 ? selectedLegends : hoveredLegend ? [hoveredLegend] : [];\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-shadow\n    function _handleFocus(focusEvent: React.FocusEvent<SVGElement>, focusedElement: string, elementId?: string) {\n      _showCallout(focusEvent, focusedElement, true, elementId);\n    }\n\n    function _handleBlur() {\n      _hideCallout(true);\n    }\n\n    function _handleMouseOver(mouseEvent: React.MouseEvent<SVGElement>, hoveredElement: string, elementId?: string) {\n      _showCallout(mouseEvent, hoveredElement, false, elementId);\n    }\n\n    function _handleMouseOut() {\n      _hideCallout(false);\n    }\n\n    function _handleCalloutDismiss() {\n      _hideCallout(false);\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    function _showCallout(\n      event: React.MouseEvent<SVGElement, MouseEvent> | React.FocusEvent<SVGElement, Element>,\n      legend: string,\n      isFocusEvent: boolean,\n      elementId?: string,\n    ) {\n      if (_calloutAnchor === legend) {\n        return;\n      }\n      const targetElement = document.getElementById(elementId!);\n      _calloutAnchor = legend;\n      // eslint-disable-next-line @typescript-eslint/no-shadow\n      const hoverXValue: string =\n        'Current value is ' + getChartValueLabel(props.chartValue, _minValue, _maxValue, props.chartValueFormat, true);\n      // eslint-disable-next-line @typescript-eslint/no-shadow\n      const hoverYValues: YValue[] = _segments.map(segment => {\n        const yValue: YValue = {\n          legend: segment.legend,\n          y: getSegmentLabel(segment, _minValue, _maxValue, props.variant),\n          color: segment.color,\n        };\n        return yValue;\n      });\n      setPopoverOpen(\n        ['Needle', 'Chart value'].includes(legend) || _noLegendHighlighted() || _legendHighlighted(legend),\n      );\n      setRefSelected(targetElement);\n      setHoverXValue(hoverXValue);\n      setHoverYValues(hoverYValues);\n      if (isFocusEvent) {\n        setFocusedElement(legend);\n      }\n    }\n\n    function _hideCallout(isBlurEvent?: boolean) {\n      _calloutAnchor = '';\n      setPopoverOpen(false);\n      setHoverXValue('');\n      setHoverYValues([]);\n      if (isBlurEvent) {\n        setFocusedElement('');\n      }\n    }\n\n    function _wrapContent(content: string, id: string, maxWidth: number) {\n      const textElement = d3Select<SVGTextElement, {}>(`#${id}`);\n      textElement.text(content);\n      if (!textElement.node()) {\n        return false;\n      }\n\n      let isOverflowing = false;\n      let textLength = textElement.node()!.getComputedTextLength();\n      while (textLength > maxWidth && content.length > 0) {\n        content = content.slice(0, -1);\n        textElement.text(content + '...');\n        isOverflowing = true;\n        textLength = textElement.node()!.getComputedTextLength();\n      }\n      return isOverflowing;\n    }\n\n    // TO DO: Write a common functional component for Multi value callout and divide sub count method\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    function _multiValueCallout(calloutProps: any) {\n      const yValueHoverSubCountsExists: boolean = _yValueHoverSubCountsExists(calloutProps.YValueHover);\n      return (\n        <div className={classes.calloutContentRoot}>\n          <div\n            className={classes.calloutDateTimeContainer}\n            style={yValueHoverSubCountsExists ? { marginBottom: '11px' } : {}}\n          >\n            <div\n              className={classes.calloutContentX}\n              {...getAccessibleDataObject(calloutProps!.xAxisCalloutAccessibilityData, 'text', false)}\n            >\n              {formatToLocaleString(calloutProps!.hoverXValue, props.culture) as React.ReactNode}\n            </div>\n          </div>\n          <div className={classes.calloutInfoContainer} style={yValueHoverSubCountsExists ? { display: 'flex' } : {}}>\n            {calloutProps!.YValueHover &&\n              calloutProps!.YValueHover.map((yValue: YValueHover, index: number, yValues: YValueHover[]) => {\n                const isLast: boolean = index + 1 === yValues.length;\n                const { shouldDrawBorderBottom = false } = yValue;\n                return (\n                  <div\n                    {...getAccessibleDataObject(yValue.callOutAccessibilityData, 'text', false)}\n                    key={`callout-content-${index}`}\n                    style={\n                      yValueHoverSubCountsExists\n                        ? {\n                            display: 'inline-block',\n                            ...(shouldDrawBorderBottom && {\n                              paddingBottom: '10px',\n                            }),\n                          }\n                        : {\n                            ...(shouldDrawBorderBottom && {\n                              paddingBottom: '10px',\n                            }),\n                          }\n                    }\n                  >\n                    {_getCalloutContent(yValue, index, yValueHoverSubCountsExists, isLast)}\n                  </div>\n                );\n              })}\n            {!!calloutProps.descriptionMessage && (\n              <div className={classes.descriptionMessage}>{calloutProps.descriptionMessage}</div>\n            )}\n          </div>\n        </div>\n      );\n    }\n\n    function _yValueHoverSubCountsExists(yValueHover?: YValueHover[]) {\n      if (yValueHover) {\n        return yValueHover.some(\n          (yValue: {\n            legend?: string;\n            y?: number;\n            color?: string;\n            yAxisCalloutData?: string | { [id: string]: number };\n          }) => yValue.yAxisCalloutData && typeof yValue.yAxisCalloutData !== 'string',\n        );\n      }\n      return false;\n    }\n\n    function _getCalloutContent(\n      xValue: YValueHover,\n      index: number,\n      yValueHoverSubCountsExists: boolean,\n      isLast: boolean,\n    ): React.ReactNode {\n      const marginStyle: React.CSSProperties = isLast ? {} : { marginRight: '16px' };\n      const toDrawShape = xValue.index !== undefined && xValue.index !== -1;\n      const { culture } = props;\n      const yValue = formatToLocaleString(xValue.y, culture) as React.ReactNode;\n      if (!xValue.yAxisCalloutData || typeof xValue.yAxisCalloutData === 'string') {\n        return (\n          <div style={yValueHoverSubCountsExists ? marginStyle : {}}>\n            {yValueHoverSubCountsExists && (\n              <div className=\"ms-fontWeight-semibold\" style={{ fontSize: '12pt' }}>\n                {xValue.legend!} ({yValue})\n              </div>\n            )}\n            <div\n              id={`${index}_${xValue.y}`}\n              className={classes.calloutBlockContainer}\n              style={{ borderInlineStart: `4px solid ${xValue.color}` }}\n            >\n              {toDrawShape && (\n                <Shape\n                  svgProps={{\n                    className: classes.shapeStyles,\n                  }}\n                  pathProps={{ fill: xValue.color }}\n                  shape={Points[xValue.index! % Object.keys(pointTypes).length] as LegendShape}\n                  style={{ display: 'flex' }}\n                />\n              )}\n              <div>\n                <div className={classes.calloutlegendText}> {xValue.legend}</div>\n                <div className={classes.calloutContentY}>\n                  {\n                    formatToLocaleString(\n                      xValue.yAxisCalloutData ? xValue.yAxisCalloutData : xValue.y || xValue.data,\n                      culture,\n                    ) as React.ReactNode\n                  }\n                </div>\n              </div>\n            </div>\n          </div>\n        );\n      } else {\n        const subcounts: { [id: string]: number } = xValue.yAxisCalloutData as { [id: string]: number };\n        return (\n          <div style={marginStyle}>\n            <div className=\"ms-fontWeight-semibold\" style={{ fontSize: '12pt' }}>\n              {xValue.legend!} ({yValue})\n            </div>\n            {Object.keys(subcounts).map((subcountName: string) => {\n              return (\n                <div key={subcountName} className={classes.calloutBlockContainer}>\n                  <div className={classes.calloutlegendText}>\n                    {' '}\n                    {formatToLocaleString(subcountName, culture) as React.ReactNode}\n                  </div>\n                  <div className={classes.calloutContentY}>\n                    {formatToLocaleString(subcounts[subcountName], culture) as React.ReactNode}\n                  </div>\n                </div>\n              );\n            })}\n          </div>\n        );\n      }\n    }\n\n    function _getChartTitle(): string {\n      const { chartTitle } = props;\n      return (chartTitle ? `${chartTitle}. ` : '') + `Gauge chart with ${_segments.length} segments. `;\n    }\n    const { arcs } = _processProps();\n    const focusAttributes = useFocusableGroup();\n    return (\n      <div className={classes.root} ref={el => (_rootElem.current = el)}>\n        <div className={classes.chartWrapper} {...focusAttributes}>\n          <svg\n            className={classes.chart}\n            width={_width}\n            height={_height - _legendsHeight}\n            role=\"region\"\n            aria-label={_getChartTitle()}\n            onMouseLeave={_handleMouseOut}\n          >\n            <g transform={`translate(${_width / 2}, ${_height - (_margins.bottom + _legendsHeight)})`}>\n              {props.chartTitle && (\n                <text\n                  x={0}\n                  y={-(_outerRadius + TITLE_OFFSET)}\n                  textAnchor=\"middle\"\n                  className={classes.chartTitle}\n                  aria-hidden={true}\n                >\n                  {props.chartTitle}\n                </text>\n              )}\n              {!props.hideMinMax && (\n                <>\n                  <text\n                    x={(_isRTL ? 1 : -1) * (_outerRadius + LABEL_OFFSET)}\n                    y={0}\n                    textAnchor=\"end\"\n                    className={classes.limits}\n                    role=\"img\"\n                    aria-label={`Min value: ${_minValue}`}\n                  >\n                    {formatScientificLimitWidth(_minValue)}\n                  </text>\n                  <text\n                    x={(_isRTL ? -1 : 1) * (_outerRadius + LABEL_OFFSET)}\n                    y={0}\n                    textAnchor=\"start\"\n                    className={classes.limits}\n                    role=\"img\"\n                    aria-label={`Max value: ${_maxValue}`}\n                  >\n                    {formatScientificLimitWidth(_maxValue)}\n                  </text>\n                </>\n              )}\n              {arcs.map((arc, index) => {\n                const segment = _segments[arc.segmentIndex];\n                const arcId = `gauge-chart-arc-${index}`;\n                return (\n                  <React.Fragment key={index}>\n                    <path\n                      d={arc.d}\n                      id={arcId}\n                      strokeWidth={focusedElement === segment.legend ? ARC_PADDING : 0}\n                      className={classes.segment}\n                      fill={segment.color}\n                      opacity={_legendHighlighted(segment.legend) || _noLegendHighlighted() ? 1 : 0.1}\n                      {...getAccessibleDataObject(\n                        {\n                          ariaLabel: getSegmentLabel(segment, _minValue, _maxValue, props.variant, true),\n                          ...segment.accessibilityData,\n                        },\n                        'img',\n                        true,\n                      )}\n                      onFocus={e => _handleFocus(e, segment.legend, arcId)}\n                      onBlur={_handleBlur}\n                      onMouseEnter={e => _handleMouseOver(e, segment.legend, arcId)}\n                      onMouseLeave={e => _handleCalloutDismiss()}\n                      onMouseMove={e => _handleMouseOver(e, segment.legend, arcId)}\n                      tabIndex={_legendHighlighted(segment.legend) || _noLegendHighlighted() ? 0 : undefined}\n                    />\n                  </React.Fragment>\n                );\n              })}\n              {_renderNeedle()}\n              <g\n                onMouseEnter={e => _handleMouseOver(e, 'Chart value')}\n                onMouseMove={e => _handleMouseOver(e, 'Chart value')}\n              >\n                <SVGTooltipText\n                  content={getChartValueLabel(props.chartValue, _minValue, _maxValue, props.chartValueFormat)}\n                  textProps={{\n                    x: 0,\n                    y: 0,\n                    textAnchor: 'middle',\n                    className: classes.chartValue,\n                    fontSize: chartValueSize,\n                    'aria-hidden': 'true',\n                  }}\n                  maxWidth={_innerRadius * 2 - 24}\n                  wrapContent={_wrapContent}\n                />\n              </g>\n              {props.sublabel && (\n                <SVGTooltipText\n                  content={props.sublabel}\n                  textProps={{\n                    x: 0,\n                    y: 4,\n                    textAnchor: 'middle',\n                    dominantBaseline: 'hanging',\n                    className: classes.sublabel,\n                  }}\n                  maxWidth={_innerRadius * 2}\n                  wrapContent={_wrapContent}\n                />\n              )}\n            </g>\n          </svg>\n        </div>\n        {_renderLegends()}\n        {!props.hideTooltip && isPopoverOpen && (\n          <ChartPopover\n            {...props.calloutProps}\n            positioning={{\n              target: refSelected,\n            }}\n            isPopoverOpen={isPopoverOpen}\n            customCallout={{\n              customizedCallout: _multiValueCallout({ hoverXValue: hoverXValue, YValueHover: hoverYValues }),\n            }}\n          />\n        )}\n      </div>\n    );\n  },\n);\nGaugeChart.displayName = 'GaugeChart';\n"],"names":["React","useGaugeChartStyles","select","d3Select","arc","d3Arc","Points","areArraysEqual","formatScientificLimitWidth","getAccessibleDataObject","getColorFromToken","getNextColor","pointTypes","useRtl","formatToLocaleString","SVGTooltipText","Legends","Shape","useFocusableGroup","ChartPopover","toImage","GAUGE_MARGIN","LABEL_WIDTH","LABEL_HEIGHT","LABEL_OFFSET","TITLE_OFFSET","EXTRA_NEEDLE_LENGTH","ARC_PADDING","BREAKPOINTS","minRadius","arcWidth","fontSize","calcNeedleRotation","chartValue","minValue","maxValue","needleRotation","getSegmentLabel","segment","variant","isAriaLabel","legend","size","toFixed","start","end","getChartValueLabel","chartValueFormat","forCallout","toString","GaugeChart","forwardRef","props","forwardedRef","_legendsRef","useRef","_getMargins","hideMinMax","chartTitle","sublabel","left","right","top","bottom","_margins","_legendsHeight","hideLegend","_rootElem","_isRTL","width","setWidth","useState","height","setHeight","hoveredLegend","setHoveredLegend","selectedLegends","setSelectedLegends","legendProps","focusedElement","setFocusedElement","isPopoverOpen","setPopoverOpen","hoverXValue","setHoverXValue","hoverYValues","setHoverYValues","refSelected","setRefSelected","prevPropsRef","_width","_height","_outerRadius","Math","min","chartValueSize","_getStylesBasedOnBreakpoint","_innerRadius","_minValue","_maxValue","_segments","_calloutAnchor","useEffect","current","clientWidth","clientHeight","prevProps","useImperativeHandle","componentRef","chartContainer","opts","toSVG","classes","index","length","_processProps","segments","roundCorners","total","processedSegments","map","max","color","accessibilityData","push","arcGenerator","cornerRadius","padAngle","padRadius","rtlSafeSegments","Array","from","reverse","prevAngle","PI","arcs","endAngle","d","innerRadius","outerRadius","startAngle","segmentIndex","_renderNeedle","rtlSafeNeedleRotation","strokeWidth","halfStrokeWidth","needleLength","needleId","g","transform","path","id","className","needle","data-is-focusable","onFocus","e","_handleFocus","onBlur","_handleBlur","onMouseEnter","_handleMouseOver","onMouseMove","role","aria-label","_renderLegends","legends","title","hoverAction","onMouseOutAction","div","legendsContainer","centerLegends","onChange","_onLegendSelectionChange","legendRef","event","currentLegend","canSelectMultipleLegends","slice","_legendHighlighted","_getHighlightedLegend","includes","_noLegendHighlighted","focusEvent","elementId","_showCallout","_hideCallout","mouseEvent","hoveredElement","_handleMouseOut","_handleCalloutDismiss","isFocusEvent","targetElement","document","getElementById","yValue","y","isBlurEvent","_wrapContent","content","maxWidth","textElement","text","node","isOverflowing","textLength","getComputedTextLength","_multiValueCallout","calloutProps","yValueHoverSubCountsExists","_yValueHoverSubCountsExists","YValueHover","calloutContentRoot","calloutDateTimeContainer","style","marginBottom","calloutContentX","xAxisCalloutAccessibilityData","culture","calloutInfoContainer","display","yValues","isLast","shouldDrawBorderBottom","callOutAccessibilityData","key","paddingBottom","_getCalloutContent","descriptionMessage","yValueHover","some","yAxisCalloutData","xValue","marginStyle","marginRight","toDrawShape","undefined","calloutBlockContainer","borderInlineStart","svgProps","shapeStyles","pathProps","fill","shape","Object","keys","calloutlegendText","calloutContentY","data","subcounts","subcountName","_getChartTitle","focusAttributes","root","ref","el","chartWrapper","svg","chart","onMouseLeave","x","textAnchor","aria-hidden","limits","arcId","Fragment","opacity","ariaLabel","tabIndex","textProps","wrapContent","dominantBaseline","hideTooltip","positioning","target","customCallout","customizedCallout","displayName"],"mappings":"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"}