{"version":3,"sources":["../src/components/DeclarativeChart/PlotlySchemaAdapter.ts"],"sourcesContent":["'use client';\n\n/* eslint-disable one-var */\n/* eslint-disable vars-on-top */\n/* eslint-disable no-var */\nimport * as React from 'react';\nimport {\n  bin as d3Bin,\n  extent as d3Extent,\n  sum as d3Sum,\n  min as d3Min,\n  max as d3Max,\n  range as d3Range,\n  Bin,\n} from 'd3-array';\nimport { scaleLinear as d3ScaleLinear } from 'd3-scale';\nimport { format as d3Format } from 'd3-format';\nimport { DonutChartProps } from '../DonutChart/index';\nimport {\n  ChartDataPoint,\n  ChartProps,\n  HorizontalBarChartWithAxisDataPoint,\n  LineChartPoints,\n  VerticalStackedChartProps,\n  HeatMapChartData,\n  HeatMapChartDataPoint,\n  VerticalBarChartDataPoint,\n  SankeyChartData,\n  LineChartLineOptions,\n  GanttChartDataPoint,\n} from '../../types/DataPoint';\nimport { SankeyChartProps } from '../SankeyChart/index';\nimport { VerticalStackedBarChartProps } from '../VerticalStackedBarChart/index';\nimport { HorizontalBarChartWithAxisProps } from '../HorizontalBarChartWithAxis/index';\nimport { LineChartProps } from '../LineChart/index';\nimport { AreaChartProps } from '../AreaChart/index';\nimport { HeatMapChartProps } from '../HeatMapChart/index';\nimport { DataVizPalette, getColorFromToken } from '../../utilities/colors';\nimport { GaugeChartProps, GaugeChartSegment } from '../GaugeChart/index';\nimport { GroupedVerticalBarChartProps } from '../GroupedVerticalBarChart/index';\nimport { VerticalBarChartProps } from '../VerticalBarChart/index';\nimport { ChartTableProps } from '../ChartTable/index';\nimport { GanttChartProps } from '../GanttChart/index';\nimport {\n  DEFAULT_DATE_STRING,\n  findNumericMinMaxOfY,\n  formatScientificLimitWidth,\n  MIN_DONUT_RADIUS,\n  calculatePrecision,\n  precisionRound,\n} from '../../utilities/utilities';\nimport type {\n  Datum,\n  Layout,\n  PlotlySchema,\n  PieData,\n  PlotData,\n  SankeyData,\n  ScatterLine,\n  TypedArray,\n  Data,\n  TableData,\n  Color,\n  LayoutAxis,\n  XAxisName,\n  TraceInfo,\n  DTickValue,\n  AxisType,\n  Shape,\n} from '@fluentui/chart-utilities';\nimport {\n  isArrayOrTypedArray,\n  isDate,\n  isDateArray,\n  isNumberArray,\n  isStringArray,\n  isYearArray,\n  isInvalidValue,\n  formatToLocaleString,\n  isNumber,\n  isObjectArray,\n  getAxisIds,\n  getAxisKey,\n  isScatterAreaChart,\n} from '@fluentui/chart-utilities';\nimport { curveCardinal as d3CurveCardinal } from 'd3-shape';\nimport type { ColorwayType } from './PlotlyColorAdapter';\nimport { getOpacity, extractColor, resolveColor, createColorScale } from './PlotlyColorAdapter';\nimport { rgb } from 'd3-color';\nimport { Legend, LegendsProps } from '../Legends/index';\nimport { ScatterChartProps } from '../ScatterChart/ScatterChart.types';\nimport { CartesianChartProps } from '../CommonComponents/index';\nimport { FunnelChartDataPoint, FunnelChartProps } from '../FunnelChart/FunnelChart.types';\n\nexport const NON_PLOT_KEY_PREFIX = 'nonplot_';\nexport const SINGLE_REPEAT = 'repeat(1, 1fr)';\n\ntype DomainInterval = {\n  start: number;\n  end: number;\n};\n\nexport type AxisProperties = {\n  xAnnotation?: string;\n  yAnnotation?: string;\n  row: number;\n  column: number;\n  xDomain: DomainInterval;\n  yDomain: DomainInterval;\n};\nexport type GridAxisProperties = Record<string, AxisProperties>;\n\nexport type GridProperties = {\n  templateRows: string;\n  templateColumns: string;\n  layout: GridAxisProperties;\n};\n\ntype ScatterChartTypes = 'area' | 'line' | 'scatter';\ninterface SecondaryYAxisValues {\n  secondaryYAxistitle?: string;\n  secondaryYScaleOptions?: { yMinValue?: number; yMaxValue?: number };\n}\n\nconst dashOptions = {\n  dot: {\n    strokeDasharray: '1, 5',\n    strokeLinecap: 'round',\n    strokeWidth: '2',\n    lineBorderWidth: '4',\n  },\n  dash: {\n    strokeDasharray: '5, 5',\n    strokeLinecap: 'butt',\n    strokeWidth: '2',\n    lineBorderWidth: '4',\n  },\n  longdash: {\n    strokeDasharray: '10, 5',\n    strokeLinecap: 'butt',\n    strokeWidth: '2',\n    lineBorderWidth: '4',\n  },\n  dashdot: {\n    strokeDasharray: '5, 5, 1, 5',\n    strokeLinecap: 'butt',\n    strokeWidth: '2',\n    lineBorderWidth: '4',\n  },\n  longdashdot: {\n    strokeDasharray: '10, 5, 1, 5',\n    strokeLinecap: 'butt',\n    strokeWidth: '2',\n    lineBorderWidth: '4',\n  },\n  solid: {\n    strokeDasharray: '0',\n    strokeLinecap: 'butt',\n    strokeWidth: '2',\n    lineBorderWidth: '4',\n  },\n} as const;\n\nfunction getTitles(layout: Partial<Layout> | undefined) {\n  const titles = {\n    chartTitle: typeof layout?.title === 'string' ? layout.title : layout?.title?.text ?? '',\n    xAxisTitle: typeof layout?.xaxis?.title === 'string' ? layout?.xaxis?.title : layout?.xaxis?.title?.text ?? '',\n    yAxisTitle: typeof layout?.yaxis?.title === 'string' ? layout?.yaxis?.title : layout?.yaxis?.title?.text ?? '',\n  };\n  return titles;\n}\n\nconst getXAxisTickFormat = (series: Data, layout: Partial<Layout> | undefined) => {\n  const xAxis = getXAxisProperties(series, layout);\n  if (xAxis?.tickformat) {\n    return {\n      tickFormat: xAxis?.tickformat,\n    };\n  }\n\n  return {};\n};\n\nconst getYAxisTickFormat = (series: Data, layout: Partial<Layout> | undefined) => {\n  const yAxis = getYAxisProperties(series, layout);\n  if (yAxis?.tickformat) {\n    return {\n      yAxisTickFormat: d3Format(yAxis?.tickformat),\n    };\n  }\n\n  return {};\n};\n\nconst getYMinMaxValues = (series: Data, layout: Partial<Layout> | undefined) => {\n  const range = getYAxisProperties(series, layout)?.range;\n  if (range && range.length === 2) {\n    return {\n      yMinValue: range[0],\n      yMaxValue: range[1],\n    };\n  }\n  return {};\n};\n\nconst getYAxisProperties = (series: Data, layout: Partial<Layout> | undefined): Partial<LayoutAxis> | undefined => {\n  return layout?.yaxis;\n};\n\nconst getXAxisProperties = (series: Data, layout: Partial<Layout> | undefined): Partial<LayoutAxis> | undefined => {\n  return layout?.xaxis;\n};\n\nconst getFormattedCalloutYData = (\n  yVal: string | number,\n  yAxisFormat: ReturnType<typeof getYAxisTickFormat>,\n): string => {\n  if (typeof yAxisFormat?.yAxisTickFormat === 'function' && typeof yVal === 'number') {\n    return yAxisFormat.yAxisTickFormat(yVal);\n  }\n  return formatToLocaleString(yVal) as string;\n};\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const correctYearMonth = (xValues: Datum[] | Datum[][] | TypedArray): any[] => {\n  const presentYear = new Date().getFullYear();\n  if (xValues.length > 0 && Array.isArray(xValues[0])) {\n    throw new Error('updateXValues:: 2D array not supported');\n  }\n  const dates = (xValues as Datum[]).map(possiblyMonthValue => {\n    const parsedDate = `${possiblyMonthValue} 01, ${presentYear}`;\n    return isDate(parsedDate) ? new Date(parsedDate) : null;\n  });\n  const filteredDateIndexPairs = dates.map((date, index) => [date, index]).filter(([date]) => date !== null) as [\n    Date,\n    number,\n  ][];\n  for (let i = filteredDateIndexPairs.length - 1; i > 0; i--) {\n    const currentDate = filteredDateIndexPairs[i][0];\n    const previousDate = filteredDateIndexPairs[i - 1][0];\n    const currentMonth = currentDate.getMonth();\n    const previousMonth = previousDate.getMonth();\n    const currentYear = currentDate.getFullYear();\n    const previousYear = previousDate.getFullYear();\n    if (previousMonth >= currentMonth) {\n      filteredDateIndexPairs[i - 1][0].setFullYear(currentYear - 1);\n    } else if (previousYear > currentYear) {\n      filteredDateIndexPairs[i - 1][0].setFullYear(currentYear);\n    }\n    dates[filteredDateIndexPairs[i - 1][1]] = filteredDateIndexPairs[i - 1][0];\n  }\n  xValues = (xValues as Datum[]).map((month, index) => {\n    if (dates[index] === null) {\n      return null;\n    }\n    return `${month} 01, ${dates[index]!.getFullYear()}`;\n  });\n  return xValues;\n};\n\nconst usesSecondaryYScale = (series: Partial<PlotData>, layout: Partial<Layout> | undefined): boolean => {\n  return series.yaxis === 'y2' && (layout?.yaxis2?.anchor === 'x' || layout?.yaxis2?.side === 'right');\n};\n\nconst getSecondaryYAxisValues = (data: Data[], layout: Partial<Layout> | undefined): SecondaryYAxisValues => {\n  let containsSecondaryYAxis = false;\n  let yMinValue: number | undefined;\n  let yMaxValue: number | undefined;\n  let allLineSeries = true;\n\n  data.forEach((series: Partial<PlotData>) => {\n    if (usesSecondaryYScale(series, layout)) {\n      containsSecondaryYAxis = true;\n\n      const yValues = series.y as number[];\n      if (yValues) {\n        yMinValue = Math.min(...yValues);\n        yMaxValue = Math.max(...yValues);\n      }\n\n      if (series.type !== 'scatter' || isScatterAreaChart(series)) {\n        allLineSeries = false;\n      }\n    }\n  });\n\n  if (!containsSecondaryYAxis) {\n    return {};\n  }\n\n  if (!allLineSeries) {\n    if (typeof yMinValue === 'number') {\n      yMinValue = Math.min(yMinValue, 0);\n    }\n    if (typeof yMaxValue === 'number') {\n      yMaxValue = Math.max(yMaxValue, 0);\n    }\n  }\n  if (layout?.yaxis2?.range) {\n    yMinValue = layout.yaxis2.range[0];\n    yMaxValue = layout.yaxis2.range[1];\n  }\n\n  return {\n    secondaryYAxistitle:\n      typeof layout?.yaxis2?.title === 'string'\n        ? layout.yaxis2.title\n        : typeof layout?.yaxis2?.title?.text === 'string'\n        ? layout.yaxis2.title.text\n        : undefined,\n    secondaryYScaleOptions: {\n      yMinValue,\n      yMaxValue,\n    },\n  };\n};\n\nexport const _getGaugeAxisColor = (\n  colorway: string[] | undefined,\n  colorwayType: ColorwayType,\n  color: Color | undefined,\n  colorMap: React.MutableRefObject<Map<string, string>>,\n  isDarkTheme?: boolean,\n): string => {\n  const extractedColors = extractColor(colorway, colorwayType, color, colorMap, isDarkTheme);\n  return resolveColor(extractedColors, 0, '', colorMap, colorway, isDarkTheme);\n};\n\nexport const resolveXAxisPoint = (\n  x: Datum,\n  isXYearCategory: boolean,\n  isXString: boolean,\n  isXDate: boolean,\n  isXNumber: boolean,\n): string | Date | number => {\n  if (x === null || x === undefined) {\n    return '';\n  }\n  if (isXYearCategory) {\n    return x.toString();\n  }\n  if (isXString) {\n    if (isXDate) {\n      const date = new Date(x as string);\n      return date;\n    }\n    if (isXNumber) {\n      return parseFloat(x as string);\n    }\n    return x;\n  }\n  return x;\n};\n\n/**\n * Checks if a key should be ignored during normalization\n * @param key The key to check\n * @returns true if the key should be ignored\n */\nconst shouldIgnoreKey = (key: string): boolean => {\n  const lowerKey = key.toLowerCase();\n  if (lowerKey.includes('style') || lowerKey === 'style') {\n    return true;\n  }\n  // Use regex to match common CSS property patterns\n  // (color, fill, stroke, border, background, font, shadow, outline, etc.)\n  const cssKeyRegex = new RegExp(\n    '^(color|fill|stroke|border|background|font|shadow|outline|margin|padding|gap|align|justify|display|flex|grid|' +\n      'text|line|letter|word|vertical|horizontal|overflow|position|top|right|bottom|left|zindex|z-index|opacity|' +\n      'filter|clip|cursor|resize|transition|animation|transform|box|column|row|direction|visibility|' +\n      'content|width|height|aspect|image|user|pointer|caret|scroll|%)|(-webkit-|-moz-|-ms-|-o-)',\n    'i',\n  );\n  if (cssKeyRegex.test(lowerKey)) {\n    return true;\n  }\n  return false;\n};\n\n/**\n * Flattens a nested object into a single level object with dot notation keys\n * @param obj Object to flatten\n * @param prefix Optional prefix for keys\n * @returns Flattened object\n */\nconst flattenObject = (obj: Record<string, unknown>, prefix: string = ''): Record<string, unknown> => {\n  const flattened: Record<string, unknown> = {};\n\n  for (const key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      const newKey = prefix ? `${prefix}.${key}` : key;\n      const value = obj[key];\n\n      if (typeof value === 'object' && value !== null && !Array.isArray(value) && !(value instanceof Date)) {\n        // Recursively flatten nested objects\n        Object.assign(flattened, flattenObject(value as Record<string, unknown>, newKey));\n      } else {\n        flattened[newKey] = value;\n      }\n    }\n  }\n\n  return flattened;\n};\n\n/**\n * Normalizes an array of objects by flattening nested structures and creating grouped data\n * Uses json_normalize approach with D3 color detection and filtering\n * @param data Array of objects to normalize\n * @returns Object containing traces for grouped vertical bar chart\n */\nexport const normalizeObjectArrayForGVBC = (\n  data: Array<Record<string, unknown>>,\n  xLabels?: string[],\n): { traces: Array<Record<string, unknown>>; x: string[] } => {\n  if (!data || data.length === 0) {\n    return { traces: [], x: [] };\n  }\n\n  // Use provided xLabels if available, otherwise default to Item 1, Item 2, ...\n  const x = xLabels && xLabels.length === data.length ? xLabels : data.map((_, index) => `Item ${index + 1}`);\n\n  // First, flatten all objects and collect all unique keys, excluding style keys\n  const flattenedObjects = data.map((item, index) => {\n    if (typeof item === 'object' && item !== null) {\n      const flattened = flattenObject(item);\n      // Only keep keys where the value is numeric (number or numeric string) and not a style key\n      const filtered: Record<string, unknown> = {};\n      Object.keys(flattened).forEach(key => {\n        const value = flattened[key];\n        if (!shouldIgnoreKey(key) && (typeof value === 'number' || (typeof value === 'string' && isNumber(value)))) {\n          filtered[key] = value;\n        }\n      });\n      return filtered;\n    } else if (typeof item === 'number' || (typeof item === 'string' && isNumber(item))) {\n      // Only keep primitive numeric values\n      return { [x[index] || `item_${index}`]: item };\n    } else {\n      // Non-numeric primitive, ignore by returning empty object\n      return {};\n    }\n  });\n\n  // Collect all unique keys across all objects\n  const allKeys = new Set<string>();\n  flattenedObjects.forEach(obj => {\n    Object.keys(obj).forEach(key => allKeys.add(key));\n  });\n\n  // Create traces for each key (property)\n  const traces: Array<Record<string, unknown>> = [];\n\n  allKeys.forEach(key => {\n    const yValues: number[] = [];\n    let hasValidData = false;\n    let isNumericData = false;\n\n    flattenedObjects.forEach((obj, index) => {\n      const value = obj[key];\n      if (typeof value === 'number') {\n        yValues.push(value);\n        hasValidData = true;\n        isNumericData = true;\n      } else if (typeof value === 'string' && isNumber(value)) {\n        yValues.push(parseFloat(value));\n        hasValidData = true;\n        isNumericData = true;\n      }\n    });\n\n    // Only create trace if we have valid numeric data\n    if (hasValidData && isNumericData) {\n      const trace: Record<string, unknown> = {\n        type: 'bar',\n        name: key,\n        x,\n        y: yValues,\n      };\n\n      traces.push(trace);\n    }\n  });\n\n  return { traces, x };\n};\n\nexport const transformPlotlyJsonToDonutProps = (\n  input: PlotlySchema,\n  isMultiPlot: boolean,\n  colorMap: React.MutableRefObject<Map<string, string>>,\n  colorwayType: ColorwayType,\n  isDarkTheme?: boolean,\n): DonutChartProps => {\n  const firstData = input.data[0] as Partial<PieData>;\n\n  // extract colors for each series only once\n  // use piecolorway if available\n  // otherwise, default to colorway from template\n  const colors: string[] | string | null | undefined = extractColor(\n    input.layout?.piecolorway ?? input.layout?.template?.layout?.colorway,\n    colorwayType,\n    input.layout?.piecolorway ?? firstData?.marker?.colors,\n    colorMap,\n    isDarkTheme,\n    true,\n  );\n  const mapLegendToDataPoint: Record<string, ChartDataPoint> = {};\n  // clear colorMap for donut chart to reassign colors as the colorMap initially gets assigned by\n  // getAllupLegendsProps function without sorting labels by value\n  colorMap.current.clear();\n\n  // Sort labels by value descending before mapping\n  if (firstData.labels && firstData.values) {\n    const markerColors = (firstData.marker?.colors as unknown as string[]) || undefined;\n    const hasMarkerColors = Array.isArray(markerColors) && markerColors.length >= firstData.labels.length;\n    const labelValuePairs = firstData.labels.map((label, index) => ({\n      label,\n      value: getNumberAtIndexOrDefault(firstData.values, index),\n      index,\n      color: hasMarkerColors ? markerColors[index] : undefined,\n    }));\n    // Filter out invalid values\n    const validPairs = labelValuePairs.filter(pair => !isInvalidValue(pair.value));\n    // Sort descending by value; when marker colors are present, keep color attached to the label\n    validPairs.sort((a, b) => (b.value as number) - (a.value as number));\n    validPairs.forEach((pair, sortedIdx) => {\n      const legend = `${pair.label}`;\n      const color: string =\n        pair.color ??\n        resolveColor(\n          colors,\n          sortedIdx,\n          legend,\n          colorMap,\n          input.layout?.piecolorway ?? input.layout?.template?.layout?.colorway,\n          isDarkTheme,\n          true,\n        );\n\n      if (!mapLegendToDataPoint[legend]) {\n        mapLegendToDataPoint[legend] = {\n          legend,\n          data: pair.value,\n          color,\n        };\n      } else {\n        mapLegendToDataPoint[legend].data! += pair.value as number;\n      }\n    });\n  }\n\n  const width: number = input.layout?.width ?? 440;\n  const height: number = input.layout?.height ?? 220;\n  const hideLabels: boolean = firstData.textinfo\n    ? !['value', 'percent', 'label+percent'].includes(firstData.textinfo)\n    : false;\n  const donutMarginHorizontal: number = hideLabels ? 0 : 80;\n  const donutMarginVertical: number = 40 + (hideLabels ? 0 : 40);\n  const innerRadius: number = firstData.hole\n    ? firstData.hole * (Math.min(width - donutMarginHorizontal, height - donutMarginVertical) / 2)\n    : MIN_DONUT_RADIUS;\n  const { chartTitle } = getTitles(input.layout);\n  // Build anticlockwise order by keeping the first item, reversing the rest\n  const legends = Object.keys(mapLegendToDataPoint);\n  const reorderedEntries =\n    legends.length > 1\n      ? ([\n          [legends[0], mapLegendToDataPoint[legends[0]]],\n          ...legends\n            .slice(1)\n            .reverse()\n            .map(key => [key, mapLegendToDataPoint[key]] as const),\n        ] as ReadonlyArray<readonly [string, ChartDataPoint]>)\n      : legends.map(key => [key, mapLegendToDataPoint[key]] as const);\n\n  return {\n    data: {\n      chartTitle,\n      chartData: reorderedEntries.map(([, v]) => v as ChartDataPoint),\n    },\n    hideLegend: isMultiPlot || input.layout?.showlegend === false,\n    width: input.layout?.width,\n    height,\n    innerRadius,\n    hideLabels,\n    showLabelsInPercent: firstData.textinfo ? ['percent', 'label+percent'].includes(firstData.textinfo) : true,\n    roundCorners: true,\n    order: 'sorted',\n  };\n};\n\nexport const transformPlotlyJsonToVSBCProps = (\n  input: PlotlySchema,\n  isMultiPlot: boolean,\n  colorMap: React.MutableRefObject<Map<string, string>>,\n  colorwayType: ColorwayType,\n  isDarkTheme?: boolean,\n  fallbackVSBC?: boolean,\n): VerticalStackedBarChartProps => {\n  const mapXToDataPoints: { [key: string]: VerticalStackedChartProps } = {};\n  let yMaxValue = 0;\n  let yMinValue = 0;\n  const secondaryYAxisValues = getSecondaryYAxisValues(input.data, input.layout);\n  const { legends, hideLegend } = getLegendProps(input.data, input.layout, isMultiPlot);\n  let colorScale: ((value: number) => string) | undefined = undefined;\n  const yAxisTickFormat = getYAxisTickFormat(input.data[0], input.layout);\n  const resolveXAxisValue = getAxisValueResolver(input.data, input.layout, 'x');\n  input.data.forEach((series: Partial<PlotData>, index1: number) => {\n    colorScale = createColorScale(input.layout, series, colorScale);\n    // extract bar colors for each series only once\n    const extractedBarColors = extractColor(\n      input.layout?.template?.layout?.colorway,\n      colorwayType,\n      series.marker?.color,\n      colorMap,\n      isDarkTheme,\n    ) as string[] | string | undefined;\n    // extract line colors for each series only once\n    const extractedLineColors = extractColor(\n      input.layout?.template?.layout?.colorway,\n      colorwayType,\n      series.line?.color,\n      colorMap,\n      isDarkTheme,\n    ) as string[] | string | undefined;\n\n    const validXYRanges = getValidXYRanges(series, resolveXAxisValue);\n    validXYRanges.forEach(([rangeStart, rangeEnd], rangeIdx) => {\n      const rangeXValues = series.x!.slice(rangeStart, rangeEnd);\n      const rangeYValues = series.y!.slice(rangeStart, rangeEnd);\n\n      (rangeXValues as Datum[]).forEach((x: string | number, index2: number) => {\n        if (!mapXToDataPoints[x]) {\n          mapXToDataPoints[x] = {\n            xAxisPoint: resolveXAxisValue(x)!,\n            chartData: [],\n            lineData: [],\n          };\n        }\n        const legend: string = legends[index1];\n        // resolve color for each legend's bars from the colorscale or extracted colors\n        const color = colorScale\n          ? colorScale(\n              isArrayOrTypedArray(series.marker?.color)\n                ? ((series.marker?.color as Color[])?.[index2 % (series.marker?.color as Color[]).length] as number)\n                : 0,\n            )\n          : resolveColor(\n              extractedBarColors,\n              index2,\n              legend,\n              colorMap,\n              input.layout?.template?.layout?.colorway,\n              isDarkTheme,\n            );\n        const opacity = getOpacity(series, index2);\n        const yVal: number | string = rangeYValues[index2] as number | string;\n        const yAxisCalloutData = getFormattedCalloutYData(yVal, yAxisTickFormat);\n        if (series.type === 'bar') {\n          mapXToDataPoints[x].chartData.push({\n            legend,\n            data: yVal,\n            color: rgb(color).copy({ opacity }).formatHex8() ?? color,\n            yAxisCalloutData,\n          });\n          if (typeof yVal === 'number') {\n            yMaxValue = Math.max(yMaxValue, yVal);\n          }\n        } else if (series.type === 'scatter' || !!fallbackVSBC) {\n          const lineColor = resolveColor(\n            extractedLineColors,\n            index1,\n            legend,\n            colorMap,\n            input.layout?.template?.layout?.colorway,\n            isDarkTheme,\n          );\n          const lineOptions = !series.mode?.includes('text') ? getLineOptions(series.line) : undefined;\n          const legendShape = getLegendShape(series);\n          mapXToDataPoints[x].lineData!.push({\n            legend: legend + (validXYRanges.length > 1 ? `.${rangeIdx + 1}` : ''),\n            legendShape,\n            y: yVal,\n            color: rgb(lineColor).copy({ opacity }).formatHex8() ?? color,\n            lineOptions: {\n              ...(lineOptions ?? {}),\n              mode: series.mode,\n            },\n            useSecondaryYScale: usesSecondaryYScale(series, input.layout),\n            yAxisCalloutData,\n          });\n          if (!usesSecondaryYScale(series, input.layout) && typeof yVal === 'number') {\n            yMaxValue = Math.max(yMaxValue, yVal);\n            yMinValue = Math.min(yMinValue, yVal);\n          }\n        }\n        yMaxValue = Math.max(yMaxValue, yVal as number);\n      });\n    });\n  });\n\n  const xCategories = (input.data[0] as Partial<PlotData>)?.x ?? [];\n\n  (input.layout?.shapes ?? [])\n    .filter(shape => shape.type === 'line')\n    .forEach((shape, shapeIdx) => {\n      const lineColor = shape.line?.color;\n      const resolveX = (val: Datum) => {\n        if (typeof val === 'number' && Array.isArray(xCategories) && xCategories[val] !== undefined) {\n          return xCategories[val];\n        }\n        return val;\n      };\n\n      const x0Key = resolveX(shape.x0!);\n      const x1Key = resolveX(shape.x1!);\n      const resolveY = (val: Datum) => {\n        if (shape.yref === 'paper') {\n          if (val === 0) {\n            return yMinValue;\n          }\n          if (val === 1) {\n            return yMaxValue;\n          }\n          if (typeof val === 'number') {\n            return yMinValue + val * (yMaxValue - yMinValue);\n          }\n          return val;\n        }\n        return val;\n      };\n\n      const y0Val = resolveY(shape.y0!);\n      const y1Val = resolveY(shape.y1!);\n      mapXToDataPoints[x0Key as string].lineData!.push({\n        legend: `Reference_${shapeIdx}`,\n        y: y0Val as string,\n        color: rgb(lineColor!).formatHex8() ?? lineColor,\n        lineOptions: getLineOptions(shape.line),\n        useSecondaryYScale: false,\n      });\n      mapXToDataPoints[x1Key as string].lineData!.push({\n        legend: `Reference_${shapeIdx}`,\n        y: y1Val as string,\n        color: rgb(lineColor!).formatHex8() ?? lineColor,\n        lineOptions: getLineOptions(shape.line),\n        useSecondaryYScale: false,\n      });\n    });\n\n  const vsbcData = Object.values(mapXToDataPoints);\n\n  return {\n    data: vsbcData,\n    width: input.layout?.width,\n    height: input.layout?.height ?? 350,\n    barWidth: 'auto',\n    yMaxValue,\n    yMinValue,\n    mode: 'plotly',\n    ...secondaryYAxisValues,\n    wrapXAxisLables: typeof vsbcData[0]?.xAxisPoint === 'string',\n    hideTickOverlap: true,\n    barGapMax: 2,\n    hideLegend,\n    roundCorners: true,\n    showYAxisLables: true,\n    noOfCharsToTruncate: 20,\n    showYAxisLablesTooltip: true,\n    ...getTitles(input.layout),\n    ...getXAxisTickFormat(input.data[0], input.layout),\n    ...yAxisTickFormat,\n    ...getAxisCategoryOrderProps(input.data, input.layout),\n    ...getBarProps(input.data, input.layout),\n    ...getYMinMaxValues(input.data[0], input.layout),\n    ...getAxisTickProps(input.data, input.layout),\n  };\n};\n\nexport const transformPlotlyJsonToGVBCProps = (\n  input: PlotlySchema,\n  isMultiPlot: boolean,\n  colorMap: React.MutableRefObject<Map<string, string>>,\n  colorwayType: ColorwayType,\n  isDarkTheme?: boolean,\n): GroupedVerticalBarChartProps => {\n  // Handle object arrays in y values by normalizing the data first\n  let processedInput = { ...input };\n\n  // Check if any bar traces have object arrays as y values\n  const hasObjectArrayData = input.data.some(\n    (series: Partial<PlotData>) => series.type === 'bar' && isObjectArray(series.y),\n  );\n\n  if (hasObjectArrayData) {\n    // Process each trace that has object array y values\n    const processedData = input.data\n      .map((series: Partial<PlotData>, index: number) => {\n        if (series.type === 'bar' && isObjectArray(series.y)) {\n          // Normalize the object array to create multiple traces for GVBC\n          const { traces } = normalizeObjectArrayForGVBC(\n            series.y as unknown as Array<Record<string, unknown>>,\n            Array.isArray(series.x) ? (series.x as string[]) : undefined,\n          );\n\n          // Return all the new traces, each representing a property from the objects\n          return traces.map((trace: Record<string, unknown>) => ({\n            ...trace,\n            // Copy other properties from the original series if needed\n            marker: series.marker,\n          }));\n        }\n        return [series];\n      })\n      .flat();\n\n    processedInput = {\n      ...input,\n      data: processedData,\n    };\n  }\n  const gvbcDataV2: GroupedVerticalBarChartProps['dataV2'] = [];\n  const secondaryYAxisValues = getSecondaryYAxisValues(processedInput.data, processedInput.layout);\n  const { legends, hideLegend } = getLegendProps(processedInput.data, processedInput.layout, isMultiPlot);\n\n  let colorScale: ((value: number) => string) | undefined = undefined;\n  const yAxisTickFormat = getYAxisTickFormat(processedInput.data[0], processedInput.layout);\n  processedInput.data.forEach((series: Partial<PlotData>, index1: number) => {\n    colorScale = createColorScale(processedInput.layout, series, colorScale);\n    const legend: string = legends[index1];\n    const legendShape = getLegendShape(series);\n\n    if (series.type === 'bar') {\n      // extract bar colors for each series only once\n      const extractedBarColors = extractColor(\n        processedInput.layout?.template?.layout?.colorway,\n        colorwayType,\n        series.marker?.color,\n        colorMap,\n        isDarkTheme,\n      ) as string[] | string | undefined;\n\n      gvbcDataV2.push({\n        type: 'bar',\n        legend,\n        key: legend,\n        data: (series.x as Datum[])\n          .map((x, xIndex) => {\n            if (isInvalidValue(x) || isInvalidValue(series.y?.[xIndex])) {\n              return;\n            }\n\n            // resolve color for each legend's bars from the colorscale or extracted colors\n            const color = colorScale\n              ? colorScale(\n                  isArrayOrTypedArray(series.marker?.color)\n                    ? ((series.marker?.color as Color[])?.[xIndex % (series.marker?.color as Color[]).length] as number)\n                    : 0,\n                )\n              : resolveColor(\n                  extractedBarColors,\n                  xIndex,\n                  legend,\n                  colorMap,\n                  processedInput.layout?.template?.layout?.colorway,\n                  isDarkTheme,\n                );\n            const opacity = getOpacity(series, xIndex);\n            const yVal = series.y![xIndex] as number;\n\n            return {\n              x: x!.toString(),\n              y: yVal,\n              yAxisCalloutData: getFormattedCalloutYData(yVal, yAxisTickFormat),\n              color: rgb(color).copy({ opacity }).formatHex8() ?? color,\n            };\n          })\n          .filter(item => typeof item !== 'undefined'),\n        useSecondaryYScale: usesSecondaryYScale(series, processedInput.layout),\n      });\n    } else if (series.type === 'scatter') {\n      // extract line colors for each series only once\n      const extractedLineColors = extractColor(\n        processedInput.layout?.template?.layout?.colorway,\n        colorwayType,\n        series.line?.color,\n        colorMap,\n        isDarkTheme,\n      ) as string[] | string | undefined;\n      const lineColor = resolveColor(\n        extractedLineColors,\n        index1,\n        legend,\n        colorMap,\n        processedInput.layout?.template?.layout?.colorway,\n        isDarkTheme,\n      );\n      const lineOptions = getLineOptions(series.line);\n      const opacity = getOpacity(series, index1);\n      const validXYRanges = getValidXYRanges(series);\n\n      validXYRanges.forEach(([rangeStart, rangeEnd]) => {\n        const rangeXValues = series.x!.slice(rangeStart, rangeEnd) as Datum[];\n        const rangeYValues = series.y!.slice(rangeStart, rangeEnd) as Datum[];\n\n        gvbcDataV2.push({\n          type: 'line',\n          legend,\n          legendShape,\n          data: rangeXValues.map((x, i: number) => {\n            const yVal = rangeYValues[i] as number;\n            return {\n              x: x!.toString(),\n              y: yVal,\n              yAxisCalloutData: getFormattedCalloutYData(yVal, yAxisTickFormat),\n            };\n          }),\n          color: rgb(lineColor).copy({ opacity }).formatHex8() ?? lineColor,\n          lineOptions: {\n            ...(lineOptions ?? {}),\n            mode: series.mode,\n          },\n          useSecondaryYScale: usesSecondaryYScale(series, processedInput.layout),\n        });\n      });\n    }\n  });\n\n  return {\n    dataV2: gvbcDataV2,\n    width: processedInput.layout?.width,\n    height: processedInput.layout?.height ?? 350,\n    barWidth: 'auto',\n    mode: 'plotly',\n    ...secondaryYAxisValues,\n    hideTickOverlap: true,\n    wrapXAxisLables: true,\n    hideLegend,\n    roundCorners: true,\n    ...getTitles(processedInput.layout),\n    ...getAxisCategoryOrderProps(processedInput.data, processedInput.layout),\n    ...getYMinMaxValues(processedInput.data[0], processedInput.layout),\n    ...getXAxisTickFormat(processedInput.data[0], processedInput.layout),\n    ...yAxisTickFormat,\n    ...getBarProps(processedInput.data, processedInput.layout),\n    ...getAxisTickProps(processedInput.data, processedInput.layout),\n  };\n};\n\nexport const transformPlotlyJsonToVBCProps = (\n  input: PlotlySchema,\n  isMultiPlot: boolean,\n  colorMap: React.MutableRefObject<Map<string, string>>,\n  colorwayType: ColorwayType,\n  isDarkTheme?: boolean,\n): VerticalBarChartProps => {\n  const vbcData: VerticalBarChartDataPoint[] = [];\n  const { legends, hideLegend } = getLegendProps(input.data, input.layout, isMultiPlot);\n  let colorScale: ((value: number) => string) | undefined = undefined;\n\n  input.data.forEach((series: Partial<PlotData>, seriesIdx: number) => {\n    if (!series.x) {\n      return;\n    }\n\n    colorScale = createColorScale(input.layout, series, colorScale);\n\n    // extract colors for each series only once\n    const extractedColors = extractColor(\n      input.layout?.template?.layout?.colorway,\n      colorwayType,\n      series.marker?.color,\n      colorMap,\n      isDarkTheme,\n    ) as string[] | string | undefined;\n    const xValues: (string | number)[] = [];\n    const yValues: number[] = [];\n    series.x.forEach((xVal, index) => {\n      const yVal = getNumberAtIndexOrDefault(series.y, index) ?? 0;\n      if (isInvalidValue(xVal)) {\n        return;\n      }\n\n      xValues.push(xVal as string | number);\n      yValues.push(yVal as number);\n    });\n\n    const isXString = isStringArray(xValues);\n    // TODO: In case of a single bin, add an empty bin of the same size to prevent the\n    // default bar width from being used and ensure the bar spans the full intended range.\n    const xBins = createBins(xValues, series.xbins?.start, series.xbins?.end, series.xbins?.size);\n    const yBins: number[][] = xBins.map(() => []);\n    let total = 0;\n\n    xValues.forEach((xVal, index) => {\n      const binIdx = findBinIndex(xBins, xVal, isXString);\n      if (binIdx !== -1) {\n        yBins[binIdx].push(yValues[index]);\n      }\n    });\n\n    const y = yBins.map(bin => {\n      const yVal = calculateHistFunc(series.histfunc, bin);\n      total += yVal;\n      return yVal;\n    });\n\n    xBins.forEach((bin, index) => {\n      const legend: string = legends[seriesIdx];\n      // resolve color for each legend's bars from the colorscale or extracted colors\n      const color = colorScale\n        ? colorScale(\n            isArrayOrTypedArray(series.marker?.color)\n              ? ((series.marker?.color as Color[])?.[index % (series.marker?.color as Color[]).length] as number)\n              : 0,\n          )\n        : resolveColor(extractedColors, index, legend, colorMap, input.layout?.template?.layout?.colorway, isDarkTheme);\n      const opacity = getOpacity(series, index);\n      const yVal = calculateHistNorm(\n        series.histnorm,\n        y[index],\n        total,\n        isXString ? bin.length : getBinSize(bin as Bin<number, number>),\n      );\n\n      vbcData.push({\n        x: isXString ? bin.join(', ') : getBinCenter(bin as Bin<number, number>),\n        y: yVal,\n        legend,\n        color: rgb(color).copy({ opacity }).formatHex8() ?? color,\n        ...(isXString\n          ? {}\n          : { xAxisCalloutData: `[${(bin as Bin<number, number>).x0} - ${(bin as Bin<number, number>).x1})` }),\n      });\n    });\n  });\n\n  return {\n    data: vbcData,\n    width: input.layout?.width,\n    height: input.layout?.height ?? 350,\n    mode: 'histogram',\n    hideTickOverlap: true,\n    wrapXAxisLables: typeof vbcData[0]?.x === 'string',\n    maxBarWidth: 50,\n    hideLegend,\n    roundCorners: true,\n    ...getTitles(input.layout),\n    ...getYMinMaxValues(input.data[0], input.layout),\n    ...getAxisCategoryOrderProps(input.data, input.layout),\n  };\n};\n\nexport const transformPlotlyJsonToAreaChartProps = (\n  input: PlotlySchema,\n  isMultiPlot: boolean,\n  colorMap: React.MutableRefObject<Map<string, string>>,\n  colorwayType: ColorwayType,\n  isDarkTheme?: boolean,\n): AreaChartProps => {\n  return transformPlotlyJsonToScatterTraceProps(\n    input,\n    isMultiPlot,\n    'area',\n    colorMap,\n    colorwayType,\n    isDarkTheme,\n  ) as AreaChartProps;\n};\n\nexport const transformPlotlyJsonToLineChartProps = (\n  input: PlotlySchema,\n  isMultiPlot: boolean,\n  colorMap: React.MutableRefObject<Map<string, string>>,\n  colorwayType: ColorwayType,\n  isDarkTheme?: boolean,\n): LineChartProps => {\n  return transformPlotlyJsonToScatterTraceProps(\n    input,\n    isMultiPlot,\n    'line',\n    colorMap,\n    colorwayType,\n    isDarkTheme,\n  ) as LineChartProps;\n};\n\nexport const transformPlotlyJsonToScatterChartProps = (\n  input: PlotlySchema,\n  isMultiPlot: boolean,\n  colorMap: React.MutableRefObject<Map<string, string>>,\n  colorwayType: ColorwayType,\n  isDarkTheme?: boolean,\n): LineChartProps => {\n  return transformPlotlyJsonToScatterTraceProps(\n    input,\n    isMultiPlot,\n    'scatter',\n    colorMap,\n    colorwayType,\n    isDarkTheme,\n  ) as ScatterChartProps;\n};\n\nconst mapColorFillBars = (layout: Partial<Layout> | undefined) => {\n  if (!Array.isArray(layout?.shapes)) {\n    return [];\n  }\n\n  return layout.shapes\n    .filter((shape: Partial<Shape>) => shape.type === 'rect')\n    .map((shape: { x0?: Datum; x1?: Datum; fillcolor?: string }) => {\n      //colorFillbars doesn't support string dates or categories\n      if (typeof shape.x0 === 'string' || typeof shape.x1 === 'string') {\n        return null;\n      }\n      return {\n        color: shape.fillcolor!,\n        data: [{ startX: shape.x0, endX: shape.x1 }],\n        applyPattern: false,\n      };\n    });\n};\n\nconst transformPlotlyJsonToScatterTraceProps = (\n  input: PlotlySchema,\n  isMultiPlot: boolean,\n  chartType: ScatterChartTypes,\n  colorMap: React.MutableRefObject<Map<string, string>>,\n  colorwayType: ColorwayType,\n  isDarkTheme?: boolean,\n): LineChartProps | AreaChartProps | ScatterChartProps => {\n  const isScatterMarkers = [\n    'text',\n    'markers',\n    'text+markers',\n    'markers+text',\n    'lines+markers',\n    'markers+line',\n    'text+lines+markers',\n    'lines+markers+text',\n  ].includes((input.data[0] as PlotData)?.mode);\n  const isAreaChart = chartType === 'area';\n  const isScatterChart = chartType === 'scatter';\n  const secondaryYAxisValues = getSecondaryYAxisValues(input.data, input.layout);\n  let mode: string = 'tonexty';\n  const { legends, hideLegend } = getLegendProps(input.data, input.layout, isMultiPlot);\n  const yAxisTickFormat = getYAxisTickFormat(input.data[0], input.layout);\n  const resolveXAxisValue = getAxisValueResolver(input.data, input.layout, 'x');\n  const shouldWrapLabels = getAxisType(input.data, input.layout, 'x') === 'category';\n  const chartData: LineChartPoints[] = input.data\n    .map((series: Partial<PlotData>, index: number) => {\n      const colors = isScatterMarkers\n        ? series?.mode?.includes('line')\n          ? series.line?.color\n          : series.marker?.color\n        : series.line?.color;\n      // extract colors for each series only once\n      const extractedColors = extractColor(\n        input.layout?.template?.layout?.colorway,\n        colorwayType,\n        colors,\n        colorMap,\n        isDarkTheme,\n      ) as string[] | string | undefined;\n      const xValues = series.x as Datum[];\n      const legend: string = legends[index];\n      // resolve color for each legend's lines from the extracted colors\n      const seriesColor = resolveColor(\n        extractedColors,\n        index,\n        legend,\n        colorMap,\n        input.layout?.template?.layout?.colorway,\n        isDarkTheme,\n      );\n      const seriesOpacity = getOpacity(series, index);\n      mode = series.fill === 'tozeroy' ? 'tozeroy' : 'tonexty';\n      // if mode contains 'text', we prioritize showing the text over curving the line\n      const lineOptions =\n        !series.mode?.includes('text') && series.type !== 'scatterpolar' ? getLineOptions(series.line) : undefined;\n      const legendShape = getLegendShape(series);\n\n      const validXYRanges = getValidXYRanges(series, resolveXAxisValue);\n      return validXYRanges.map(([rangeStart, rangeEnd], rangeIdx) => {\n        const rangeXValues = xValues.slice(rangeStart, rangeEnd);\n        const rangeYValues = series.y!.slice(rangeStart, rangeEnd);\n        const markerSizes = isArrayOrTypedArray(series.marker?.size)\n          ? (series.marker!.size as number[]).slice(rangeStart, rangeEnd)\n          : [];\n        const markerColors = isArrayOrTypedArray(series.marker?.color)\n          ? (series.marker!.color as string[]).slice(rangeStart, rangeEnd)\n          : Array.isArray(series.marker?.color)\n          ? (series.marker!.color as string[]).slice(rangeStart, rangeEnd)\n          : undefined;\n        const textValues = Array.isArray(series.text) ? series.text.slice(rangeStart, rangeEnd) : undefined;\n\n        return {\n          legend,\n          legendShape,\n          data: rangeXValues.map((x, i: number) => ({\n            x: resolveXAxisValue(x),\n            y: rangeYValues[i],\n            ...(Array.isArray(series.marker?.size)\n              ? { markerSize: markerSizes[i] }\n              : typeof series.marker?.size === 'number'\n              ? { markerSize: series.marker.size }\n              : {}),\n            ...(markerColors ? { markerColor: markerColors[i] } : {}),\n            ...(textValues ? { text: textValues[i] } : {}),\n            yAxisCalloutData: getFormattedCalloutYData(rangeYValues[i] as number, yAxisTickFormat),\n          })),\n          color: rgb(seriesColor).copy({ opacity: seriesOpacity }).formatHex8() ?? seriesColor,\n          lineOptions: {\n            ...(lineOptions ?? {}),\n            mode: series.type !== 'scatterpolar' ? series.mode : 'scatterpolar',\n            // originXOffset is not typed on Layout, but may be present in input.layout as a part of projection of\n            // scatter polar coordingates to cartesian coordinates\n            ...(series.type === 'scatterpolar'\n              ? {\n                  originXOffset: (input.layout as { __polarOriginX?: number } | undefined)?.__polarOriginX,\n                  direction: input.layout?.polar?.angularaxis?.direction,\n                  rotation: input.layout?.polar?.angularaxis?.rotation,\n                  axisLabel: (series as { __axisLabel: string[] }).__axisLabel\n                    ? (series as { __axisLabel: string[] }).__axisLabel\n                    : {},\n                  fill: series.fill,\n                }\n              : {}),\n          },\n          useSecondaryYScale: usesSecondaryYScale(series, input.layout),\n        } as LineChartPoints;\n      });\n    })\n    .flat();\n\n  const xMinValue = chartData[0]?.data[0]?.x;\n  const xMaxValue = chartData[0]?.data[chartData[0].data.length - 1]?.x;\n  const yMinValue = chartData[0]?.data[0]?.y;\n  const yMaxValue = chartData[0]?.data[chartData[0].data.length - 1]?.y;\n\n  const lineShape: LineChartPoints[] = (input.layout?.shapes ?? [])\n    .filter(shape => shape.type === 'line')\n    .map((shape, shapeIdx) => {\n      const lineColor = shape.line?.color;\n      const resolveX = (val: Datum) => {\n        if (shape.xref === 'paper') {\n          if (val === 0) {\n            return xMinValue;\n          }\n          if (val === 1) {\n            return xMaxValue;\n          }\n          if (typeof val === 'number' && typeof xMinValue === 'number' && typeof xMaxValue === 'number') {\n            return xMinValue + val * (xMaxValue - xMinValue);\n          }\n          return val;\n        }\n        return val;\n      };\n\n      const resolveY = (val: Datum) => {\n        if (shape.yref === 'paper') {\n          if (val === 0) {\n            return yMinValue;\n          }\n          if (val === 1) {\n            return yMaxValue;\n          }\n          if (typeof val === 'number') {\n            return yMinValue + val * (yMaxValue - yMinValue);\n          }\n          return val;\n        }\n        return val;\n      };\n\n      return {\n        legend: `Reference_${shapeIdx}`,\n        data: [\n          { x: resolveX(shape.x0!), y: resolveY(shape.y0!) },\n          { x: resolveX(shape.x1!), y: resolveY(shape.y1!) },\n        ],\n        color: rgb(lineColor!).formatHex8() ?? lineColor,\n        lineOptions: getLineOptions(shape.line),\n        useSecondaryYScale: false,\n      } as LineChartPoints;\n    });\n\n  const yMinMax = getYMinMaxValues(input.data[0], input.layout);\n  if (yMinMax.yMinValue === undefined && yMinMax.yMaxValue === undefined) {\n    const yMinMaxValues = findNumericMinMaxOfY(chartData);\n    yMinMax.yMinValue = yMinMaxValues.startValue;\n    yMinMax.yMaxValue = yMinMaxValues.endValue;\n  }\n  const numDataPoints = chartData.reduce((total, lineChartPoints) => total + lineChartPoints.data.length, 0);\n\n  const chartProps: ChartProps = {\n    lineChartData: [...chartData, ...lineShape],\n  };\n\n  const scatterChartProps: ChartProps = {\n    scatterChartData: chartData,\n  };\n\n  const commonProps = {\n    supportNegativeData: true,\n    ...secondaryYAxisValues,\n    width: input.layout?.width,\n    height: input.layout?.height ?? 350,\n    hideTickOverlap: true,\n    hideLegend,\n    useUTC: false,\n    wrapXAxisLables: shouldWrapLabels,\n    optimizeLargeData: numDataPoints > 1000,\n    ...getTitles(input.layout),\n    ...getXAxisTickFormat(input.data[0], input.layout),\n    ...yAxisTickFormat,\n    ...getAxisScaleTypeProps(input.data, input.layout),\n    ...getAxisTickProps(input.data, input.layout),\n  };\n\n  if (isAreaChart) {\n    return {\n      data: chartProps,\n      mode,\n      ...commonProps,\n    } as AreaChartProps;\n  } else {\n    return {\n      data: isScatterChart ? scatterChartProps : chartProps,\n      roundedTicks: true,\n      ...commonProps,\n      ...yMinMax,\n      ...(isScatterChart\n        ? {\n            showYAxisLablesTooltip: true,\n            ...getAxisCategoryOrderProps(input.data, input.layout),\n          }\n        : {}),\n      ...(!isScatterChart &&\n        (() => {\n          const bars = mapColorFillBars(input.layout);\n          return bars && !bars.includes(null) ? { colorFillBars: bars } : {};\n        })()),\n    } as LineChartProps;\n  }\n};\n\nexport const transformPlotlyJsonToHorizontalBarWithAxisProps = (\n  input: PlotlySchema,\n  isMultiPlot: boolean,\n  colorMap: React.MutableRefObject<Map<string, string>>,\n  colorwayType: ColorwayType,\n  isDarkTheme?: boolean,\n): HorizontalBarChartWithAxisProps => {\n  const { legends, hideLegend } = getLegendProps(input.data, input.layout, isMultiPlot);\n  let colorScale: ((value: number) => string) | undefined = undefined;\n  const chartData: HorizontalBarChartWithAxisDataPoint[] = input.data\n    .map((series: Partial<PlotData>, index: number) => {\n      colorScale = createColorScale(input.layout, series, colorScale);\n      // extract colors for each series only once\n      const extractedColors = extractColor(\n        input.layout?.template?.layout?.colorway,\n        colorwayType,\n        series.marker?.color,\n        colorMap,\n        isDarkTheme,\n      ) as string[] | string | undefined;\n      const legend = legends[index];\n      return (series.y as Datum[])\n        .map((yValue, i: number) => {\n          if (isInvalidValue(yValue)) {\n            return null;\n          }\n\n          // resolve color for each legend's bars from the colorscale or extracted colors\n          const color = colorScale\n            ? colorScale(\n                isArrayOrTypedArray(series.marker?.color)\n                  ? ((series.marker?.color as Color[])?.[i % (series.marker?.color as Color[]).length] as number)\n                  : 0,\n              )\n            : resolveColor(extractedColors, i, legend, colorMap, input.layout?.template?.layout?.colorway, isDarkTheme);\n          const opacity = getOpacity(series, i);\n\n          return {\n            x: isInvalidValue(series.x?.[i]) ? 0 : series.x![i],\n            y: yValue,\n            legend,\n            color: rgb(color).copy({ opacity }).formatHex8() ?? color,\n          } as HorizontalBarChartWithAxisDataPoint;\n        })\n        .filter(point => point !== null) as HorizontalBarChartWithAxisDataPoint[];\n    })\n    .flat();\n\n  const chartHeight: number = input.layout?.height ?? 450;\n  const margin: number = input.layout?.margin?.l ?? 0;\n  const padding: number = input.layout?.margin?.pad ?? 0;\n  const availableHeight: number = chartHeight - margin - padding;\n  const numberOfRows = new Set(chartData.map(d => d.y)).size || 1;\n  const scalingFactor = 0.01;\n  const gapFactor = 1 / (1 + scalingFactor * numberOfRows);\n  const barHeight = availableHeight / (numberOfRows * (1 + gapFactor));\n\n  return {\n    data: chartData,\n    secondaryYAxistitle:\n      typeof input.layout?.yaxis2?.title === 'string'\n        ? input.layout?.yaxis2?.title\n        : input.layout?.yaxis2?.title?.text || '',\n    barHeight,\n    showYAxisLables: true,\n    height: chartHeight,\n    width: input.layout?.width,\n    hideTickOverlap: true,\n    noOfCharsToTruncate: 20,\n    showYAxisLablesTooltip: true,\n    hideLegend,\n    roundCorners: true,\n    ...getTitles(input.layout),\n    ...getAxisCategoryOrderProps(input.data, input.layout),\n    ...getBarProps(input.data, input.layout, true),\n    ...getAxisTickProps(input.data, input.layout),\n  };\n};\n\nexport const transformPlotlyJsonToGanttChartProps = (\n  input: PlotlySchema,\n  isMultiPlot: boolean,\n  colorMap: React.MutableRefObject<Map<string, string>>,\n  colorwayType: ColorwayType,\n  isDarkTheme?: boolean,\n): GanttChartProps => {\n  const { legends, hideLegend } = getLegendProps(input.data, input.layout, isMultiPlot);\n  let colorScale: ((value: number) => string) | undefined = undefined;\n  const isXDate = getAxisType(input.data, input.layout, 'x') === 'date';\n  const chartData: GanttChartDataPoint[] = input.data\n    .map((series: Partial<PlotData>, index: number) => {\n      colorScale = createColorScale(input.layout, series, colorScale);\n\n      // extract colors for each series only once\n      const extractedColors = extractColor(\n        input.layout?.template?.layout?.colorway,\n        colorwayType,\n        series.marker?.color,\n        colorMap,\n        isDarkTheme,\n      ) as string[] | string | undefined;\n      const legend = legends[index];\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      const convertXValueToNumber = (value: any) => {\n        return isInvalidValue(value) ? 0 : isXDate ? +parseLocalDate(value) : +value;\n      };\n\n      return (series.y as Datum[])\n        .map((yVal, i: number) => {\n          if (isInvalidValue(yVal)) {\n            return null;\n          }\n          // resolve color for each legend's bars from the colorscale or extracted colors\n          const color = colorScale\n            ? colorScale(\n                isArrayOrTypedArray(series.marker?.color)\n                  ? ((series.marker?.color as Color[])?.[i % (series.marker?.color as Color[]).length] as number)\n                  : 0,\n              )\n            : resolveColor(extractedColors, i, legend, colorMap, input.layout?.template?.layout?.colorway, isDarkTheme);\n          const opacity = getOpacity(series, i);\n          const base = convertXValueToNumber(series.base?.[i]);\n          const xVal = convertXValueToNumber(series.x?.[i]);\n\n          return {\n            x: {\n              start: isXDate ? new Date(base) : base,\n              end: isXDate ? new Date(base + xVal) : base + xVal,\n            },\n            y: yVal,\n            legend,\n            color: rgb(color).copy({ opacity }).formatHex8() ?? color,\n          } as GanttChartDataPoint;\n        })\n        .filter(point => point !== null) as GanttChartDataPoint[];\n    })\n    .flat();\n\n  return {\n    data: chartData,\n    showYAxisLables: true,\n    height: input.layout?.height ?? 350,\n    width: input.layout?.width,\n    hideTickOverlap: true,\n    hideLegend,\n    noOfCharsToTruncate: 20,\n    showYAxisLablesTooltip: true,\n    roundCorners: true,\n    useUTC: false,\n    ...getTitles(input.layout),\n    ...getAxisCategoryOrderProps(input.data, input.layout),\n    ...getBarProps(input.data, input.layout, true),\n    ...getAxisTickProps(input.data, input.layout),\n  };\n};\n\nexport const transformPlotlyJsonToHeatmapProps = (\n  input: PlotlySchema,\n  isMultiPlot: boolean,\n  colorMap: React.MutableRefObject<Map<string, string>>,\n  colorwayType: ColorwayType,\n  isDarkTheme?: boolean,\n): HeatMapChartProps => {\n  const firstData = input.data[0] as Partial<PlotData>;\n  const heatmapDataPoints: HeatMapChartDataPoint[] = [];\n  let zMin = Number.POSITIVE_INFINITY;\n  let zMax = Number.NEGATIVE_INFINITY;\n\n  if (firstData.type === 'histogram2d') {\n    const xValues: (string | number)[] = [];\n    const yValues: (string | number)[] = [];\n    const zValues: number[] = [];\n    firstData.x?.forEach((xVal, index) => {\n      const zVal = getNumberAtIndexOrDefault(firstData.z, index) ?? 0;\n      if (isInvalidValue(xVal) || isInvalidValue(firstData.y?.[index])) {\n        return;\n      }\n\n      xValues.push(xVal as string | number);\n      yValues.push(firstData.y![index] as string | number);\n      zValues.push(zVal as number);\n    });\n\n    const isXString = isStringArray(xValues);\n    const isYString = isStringArray(yValues);\n    const xBins = createBins(xValues, firstData.xbins?.start, firstData.xbins?.end, firstData.xbins?.size);\n    const yBins = createBins(yValues, firstData.ybins?.start, firstData.ybins?.end, firstData.ybins?.size);\n    const zBins: number[][][] = yBins.map(() => xBins.map(() => []));\n    let total = 0;\n\n    xValues.forEach((xVal, index) => {\n      const xBinIdx = findBinIndex(xBins, xVal, isXString);\n      const yBinIdx = findBinIndex(yBins, yValues[index], isYString);\n\n      if (xBinIdx !== -1 && yBinIdx !== -1) {\n        zBins[yBinIdx][xBinIdx].push(zValues[index]);\n      }\n    });\n\n    const z = zBins.map(row => {\n      return row.map(bin => {\n        const zVal = calculateHistFunc(firstData.histfunc, bin);\n        total += zVal;\n        return zVal;\n      });\n    });\n\n    xBins.forEach((xBin, xIdx) => {\n      yBins.forEach((yBin, yIdx) => {\n        const zVal = calculateHistNorm(\n          firstData.histnorm,\n          z[yIdx][xIdx],\n          total,\n          isXString ? xBin.length : getBinSize(xBin as Bin<number, number>),\n          isYString ? yBin.length : getBinSize(yBin as Bin<number, number>),\n        );\n\n        heatmapDataPoints.push({\n          x: isXString ? xBin.join(', ') : getBinCenter(xBin as Bin<number, number>),\n          y: isYString ? yBin.join(', ') : getBinCenter(yBin as Bin<number, number>),\n          value: zVal,\n          rectText: zVal,\n        });\n\n        if (typeof zVal === 'number') {\n          zMin = Math.min(zMin, zVal);\n          zMax = Math.max(zMax, zVal);\n        }\n      });\n    });\n  } else {\n    (firstData.x as Datum[])?.forEach((xVal, xIdx: number) => {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      firstData.y?.forEach((yVal: any, yIdx: number) => {\n        const zVal = (firstData.z as number[][])?.[yIdx]?.[xIdx];\n\n        heatmapDataPoints.push({\n          x: input.layout?.xaxis?.type === 'date' ? (xVal as Date) : xVal ?? 0,\n          y: input.layout?.yaxis?.type === 'date' ? (yVal as Date) : yVal,\n          value: zVal,\n          rectText: zVal,\n        });\n\n        if (typeof zVal === 'number') {\n          zMin = Math.min(zMin, zVal);\n          zMax = Math.max(zMax, zVal);\n        }\n      });\n    });\n  }\n\n  const heatmapData: HeatMapChartData = {\n    legend: firstData.name ?? '',\n    data: heatmapDataPoints,\n    value: 0,\n  };\n\n  // Initialize domain and range to default values\n  const defaultDomain = [zMin, (zMax + zMin) / 2, zMax];\n  const defaultRange = [\n    getColorFromToken(DataVizPalette.color1),\n    getColorFromToken(DataVizPalette.color2),\n    getColorFromToken(DataVizPalette.color3),\n  ];\n\n  let colorscale =\n    firstData?.colorscale ??\n    input.layout?.colorscale ??\n    input.layout?.coloraxis?.colorscale ??\n    input.layout?.template?.layout?.colorscale ??\n    (firstData.type === 'histogram2d' && input.layout?.template?.data?.histogram2d?.[0]?.colorscale) ??\n    input.layout?.template?.data?.heatmap?.[0]?.colorscale;\n\n  // determine if the types diverging, sequential or sequentialminus are present in colorscale\n  if (\n    colorscale &&\n    typeof colorscale === 'object' &&\n    ('diverging' in colorscale || 'sequential' in colorscale || 'sequentialminus' in colorscale)\n  ) {\n    const isDivergent = zMin < 0 && zMax > 0; // Data spans both positive and negative values\n    const isSequential = zMin >= 0; // Data is entirely positive\n    const isSequentialMinus = zMax <= 0; // Data is entirely negative\n\n    if (isDivergent) {\n      colorscale = colorscale?.diverging;\n    } else if (isSequential) {\n      colorscale = colorscale?.sequential;\n    } else if (isSequentialMinus) {\n      colorscale = colorscale?.sequentialminus;\n    }\n  }\n\n  const domainValuesForColorScale: number[] = Array.isArray(colorscale)\n    ? (colorscale as Array<[number, string]>).map(arr => arr[0] * (zMax - zMin) + zMin)\n    : defaultDomain;\n\n  const rangeValuesForColorScale: string[] = Array.isArray(colorscale)\n    ? (colorscale as Array<[number, string]>).map(arr => arr[1])\n    : defaultRange;\n\n  return {\n    data: [heatmapData],\n    domainValuesForColorScale,\n    rangeValuesForColorScale,\n    hideLegend: true,\n    showYAxisLables: true,\n    sortOrder: 'none',\n    width: input.layout?.width,\n    height: input.layout?.height ?? 350,\n    hideTickOverlap: true,\n    noOfCharsToTruncate: 20,\n    showYAxisLablesTooltip: true,\n    wrapXAxisLables: true,\n    ...getTitles(input.layout),\n    ...getAxisCategoryOrderProps([firstData], input.layout),\n    ...getAxisTickProps(input.data, input.layout),\n  };\n};\n\nexport const transformPlotlyJsonToSankeyProps = (\n  input: PlotlySchema,\n  isMultiPlot: boolean,\n  colorMap: React.MutableRefObject<Map<string, string>>,\n  colorwayType: ColorwayType,\n  isDarkTheme?: boolean,\n): SankeyChartProps => {\n  const { link, node } = input.data[0] as SankeyData;\n  const validLinks = (link?.value ?? [])\n    .map((val: number, index: number) => {\n      if (isInvalidValue(val) || isInvalidValue(link?.source?.[index]) || isInvalidValue(link?.target?.[index])) {\n        return null;\n      }\n\n      return {\n        value: val,\n        source: link?.source![index],\n        target: link?.target![index],\n      };\n    })\n    // Filter out negative nodes, unequal nodes and self-references (circular links)\n    .filter(x => x !== null && x.source >= 0 && x.target >= 0 && x.source !== x.target);\n\n  const extractedNodeColors = extractColor(\n    input.layout?.template?.layout?.colorway,\n    colorwayType,\n    node?.color,\n    colorMap,\n    isDarkTheme,\n  );\n  const sankeyChartData = {\n    nodes: node.label?.map((label: string, index: number) => {\n      const color = resolveColor(\n        extractedNodeColors,\n        index,\n        label,\n        colorMap,\n        input.layout?.template?.layout?.colorway,\n        isDarkTheme,\n      );\n\n      return {\n        nodeId: index,\n        name: label,\n        color,\n      };\n    }),\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    links: validLinks.map((validLink: any, index: number) => {\n      return {\n        ...validLink,\n      };\n    }),\n  } as SankeyChartData;\n\n  // const styles: SankeyChartProps['styles'] = {\n  //   root: {\n  //     ...(input.layout?.font?.size ? { fontSize: input.layout.font?.size } : {}),\n  //   },\n  // };\n\n  const { chartTitle } = getTitles(input.layout);\n\n  return {\n    data: {\n      chartTitle,\n      SankeyChartData: sankeyChartData,\n    },\n    width: input.layout?.width,\n    height: input.layout?.height ?? 468,\n    // TODO\n    // styles,\n  };\n};\n\nexport const transformPlotlyJsonToGaugeProps = (\n  input: PlotlySchema,\n  isMultiPlot: boolean,\n  colorMap: React.MutableRefObject<Map<string, string>>,\n  colorwayType: ColorwayType,\n  isDarkTheme?: boolean,\n): GaugeChartProps => {\n  const firstData = input.data[0] as PlotData;\n  const stepsColors = firstData.gauge?.steps ? firstData.gauge.steps.map(step => step.color) : undefined;\n  const extractedColors = extractColor(\n    input.layout?.template?.layout?.colorway,\n    colorwayType,\n    stepsColors,\n    colorMap,\n    isDarkTheme,\n  );\n\n  const segments = firstData.gauge?.steps?.length\n    ? // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      firstData.gauge.steps.map((step: any, index: number): GaugeChartSegment => {\n        const legend = step.name || `Segment ${index + 1}`;\n        const color = resolveColor(\n          extractedColors,\n          index,\n          legend,\n          colorMap,\n          input.layout?.template?.layout?.colorway,\n          isDarkTheme,\n        );\n        return {\n          legend,\n          size: step.range?.[1] - step.range?.[0],\n          color,\n        };\n      })\n    : [\n        {\n          legend: 'Current',\n          size: firstData.value ?? 0 - (firstData.gauge?.axis?.range?.[0] ?? 0),\n          color: _getGaugeAxisColor(\n            input.layout?.template?.layout?.colorway,\n            colorwayType,\n            firstData.gauge?.axis?.color,\n            colorMap,\n            isDarkTheme,\n          ),\n        },\n        {\n          legend: 'Target',\n          size: (firstData.gauge?.axis?.range?.[1] ?? 100) - (firstData.value ?? 0),\n          color: DataVizPalette.disabled,\n        },\n      ];\n\n  let sublabel: string | undefined;\n  let sublabelColor: string | undefined;\n  if (firstData.delta?.reference) {\n    const diff = firstData.value - firstData.delta.reference;\n    if (diff >= 0) {\n      sublabel = `\\u25B2 ${diff}`;\n      const extractedIncreasingDeltaColors = extractColor(\n        input.layout?.template?.layout?.colorway,\n        colorwayType,\n        firstData.delta?.increasing?.color,\n        colorMap,\n        isDarkTheme,\n      );\n      const color = resolveColor(\n        extractedIncreasingDeltaColors,\n        0,\n        '',\n        colorMap,\n        input.layout?.template?.layout?.colorway,\n        isDarkTheme,\n      );\n      sublabelColor = color;\n    } else {\n      sublabel = `\\u25BC ${Math.abs(diff)}`;\n      const extractedDecreasingDeltaColors = extractColor(\n        input.layout?.template?.layout?.colorway,\n        colorwayType,\n        firstData.delta?.decreasing?.color,\n        colorMap,\n        isDarkTheme,\n      );\n      const color = resolveColor(\n        extractedDecreasingDeltaColors,\n        0,\n        '',\n        colorMap,\n        input.layout?.template?.layout?.colorway,\n        isDarkTheme,\n      );\n      sublabelColor = color;\n    }\n  }\n\n  const styles = {\n    sublabel: sublabelColor,\n  };\n\n  const { chartTitle } = getTitles(input.layout);\n\n  return {\n    segments,\n    chartValue: firstData.value ?? 0,\n    chartTitle,\n    sublabel,\n    // range values can be null\n    minValue: typeof firstData.gauge?.axis?.range?.[0] === 'number' ? firstData.gauge?.axis?.range?.[0] : undefined,\n    maxValue: typeof firstData.gauge?.axis?.range?.[1] === 'number' ? firstData.gauge?.axis?.range?.[1] : undefined,\n    chartValueFormat: () => firstData.value?.toString() ?? '',\n    width: input.layout?.width,\n    height: input.layout?.height ?? 220,\n    // TODO\n    // styles,\n    variant: firstData.gauge?.steps?.length ? 'multiple-segments' : 'single-segment',\n    styles,\n    roundCorners: true,\n  };\n};\n\nconst cleanText = (text: string): string => {\n  return text\n    .replace(/&lt;[^&]*?&gt;/g, '')\n    .replace(/<[^>]*>/g, '')\n    .replace(/&lt;br&gt;|\\\\u003cbr\\\\u003e|<br>/gi, '')\n    .replace(/\\$[^$]*\\$/g, '$')\n    .trim();\n};\n\nconst formatValue = (\n  value: string | number | boolean | null,\n  colIndex: number,\n  cells: TableData['cells'],\n): string | number | boolean | null => {\n  if (value === null || typeof value === 'boolean') {\n    return value;\n  }\n\n  const formatStr = Array.isArray(cells!.format) ? cells!.format[colIndex] : cells!.format;\n  const prefix = Array.isArray(cells!.prefix) ? cells!.prefix[colIndex] : cells!.prefix;\n  const suffix = Array.isArray(cells!.suffix) ? cells!.suffix[colIndex] : cells!.suffix;\n  let formatted = value;\n  if (typeof value === 'number') {\n    if (typeof formatStr === 'string') {\n      try {\n        formatted = d3Format(formatStr)(value);\n      } catch {\n        formatted = formatScientificLimitWidth(value);\n      }\n    } else {\n      formatted = formatScientificLimitWidth(value);\n    }\n  }\n  return `${prefix ?? ''}${formatted}${suffix ?? ''}`;\n};\n\nfunction resolveCellStyle<T>(raw: T | T[] | T[][] | undefined, rowIndex: number, colIndex: number): T | undefined {\n  if (Array.isArray(raw)) {\n    const rowEntry = raw[colIndex] ?? raw[0];\n    if (Array.isArray(rowEntry)) {\n      return rowEntry[rowIndex] ?? rowEntry[0];\n    }\n    return rowEntry;\n  }\n  return raw;\n}\n\nfunction mergeCells(tableCells?: TableData['cells'], templateCells?: TableData['cells']): TableData['cells'] {\n  return {\n    values: tableCells?.values ?? templateCells?.values ?? [],\n    align: tableCells?.align ?? templateCells?.align,\n\n    fill: {\n      ...(templateCells?.fill ?? {}),\n      ...(tableCells?.fill ?? {}),\n    },\n\n    font: {\n      ...(templateCells?.font ?? {}),\n      ...(tableCells?.font ?? {}),\n    },\n\n    format: tableCells?.format ?? templateCells?.format,\n    prefix: tableCells?.prefix ?? templateCells?.prefix,\n    suffix: tableCells?.suffix ?? templateCells?.suffix,\n  };\n}\n\nexport const transformPlotlyJsonToChartTableProps = (\n  input: PlotlySchema,\n  isMultiPlot: boolean,\n  colorMap: React.MutableRefObject<Map<string, string>>,\n  colorwayType: ColorwayType,\n  isDarkTheme?: boolean,\n): ChartTableProps => {\n  const tableData = input.data[0] as TableData;\n\n  const normalizeHeaders = (\n    values: (string | number | boolean | null)[] | (string | number | boolean | null)[][],\n    header: TableData['header'],\n  ): { value: string | number | boolean | null; style?: React.CSSProperties }[] => {\n    const cleanedValues: (string | number | boolean | null)[] = Array.isArray(values[0])\n      ? (values as string[][]).map(row =>\n          row\n            .map(cell => cleanText(cell))\n            .filter(Boolean)\n            .join(' '),\n        )\n      : (values as string[]).map(cell => cleanText(cell));\n\n    return cleanedValues.map((value, colIndex) => {\n      //headers are at first row only\n      const rowIndex = 0;\n      const fontColor = resolveCellStyle(header?.font?.color, rowIndex, colIndex) as string | undefined;\n      const fontSize = resolveCellStyle(header?.font?.size, rowIndex, colIndex) as number | undefined;\n      const backgroundColor = resolveCellStyle(header?.fill?.color, rowIndex, colIndex) as string | undefined;\n      const textAlign = resolveCellStyle(header?.align, rowIndex, colIndex) as\n        | React.CSSProperties['textAlign']\n        | undefined;\n\n      const style: React.CSSProperties = {\n        ...(typeof fontColor === 'string' ? { color: fontColor } : {}),\n        ...(typeof fontSize === 'number' ? { fontSize } : {}),\n        ...(typeof backgroundColor === 'string' ? { backgroundColor } : {}),\n        ...(textAlign ? { textAlign } : {}),\n      };\n\n      return { value, style };\n    });\n  };\n  const columns = tableData.cells?.values ?? [];\n  const cells = mergeCells(tableData.cells, input.layout?.template?.data?.table?.[0]?.cells);\n  const rows = columns[0].map((_, rowIndex: number) =>\n    columns.map((col, colIndex) => {\n      const cellValue = col[rowIndex];\n      const cleanValue = typeof cellValue === 'string' ? cleanText(cellValue) : cellValue;\n\n      const formattedValue =\n        typeof cleanValue === 'string' || typeof cleanValue === 'number'\n          ? formatValue(cleanValue, colIndex, cells)\n          : cleanValue;\n\n      const fontColor = resolveCellStyle(cells?.font?.color, rowIndex, colIndex) as string | undefined;\n      const fontSize = resolveCellStyle(cells?.font?.size, rowIndex, colIndex) as number | undefined;\n      const backgroundColor = resolveCellStyle(cells?.fill?.color, rowIndex, colIndex) as string | undefined;\n      const textAlign = resolveCellStyle(cells?.align, rowIndex, colIndex) as\n        | React.CSSProperties['textAlign']\n        | undefined;\n\n      const style: React.CSSProperties = {\n        ...(fontColor ? { color: fontColor } : {}),\n        ...(typeof fontSize === 'number' ? { fontSize } : {}),\n        ...(backgroundColor ? { backgroundColor } : {}),\n        ...(textAlign ? { textAlign } : {}),\n      };\n\n      return {\n        value: formattedValue,\n        style,\n      };\n    }),\n  );\n\n  const styles: ChartTableProps['styles'] = {\n    root: {\n      ...(input.layout?.font?.size ? { fontSize: input.layout.font.size } : {}),\n    },\n  };\n\n  const templateHeader = input.layout?.template?.data?.table?.[0]?.header;\n  const tableHeader = tableData.header;\n\n  const header = {\n    align: tableHeader?.align ?? templateHeader?.align,\n    fill: {\n      ...(templateHeader?.fill ?? {}),\n      ...(tableHeader?.fill ?? {}),\n    },\n    font: {\n      ...(templateHeader?.font ?? {}),\n      ...(tableHeader?.font ?? {}),\n    },\n    values: tableHeader?.values ?? templateHeader?.values ?? [],\n  };\n\n  return {\n    headers: normalizeHeaders(tableData.header?.values ?? [], header),\n    rows,\n    width: input.layout?.width,\n    height: input.layout?.height,\n    styles,\n  };\n};\n\nfunction getCategoriesAndValues(series: Partial<PlotData>): {\n  categories: (string | number)[];\n  values: (string | number)[];\n} {\n  const orientation = series.orientation || 'h';\n  const y = series.labels ?? series.y ?? series.stage;\n  const x = series.values ?? series.x ?? series.value;\n  const xIsString = isStringArray(x as Datum[] | Datum[][] | TypedArray | undefined);\n  const yIsString = isStringArray(y as Datum[] | Datum[][] | TypedArray | undefined);\n  const xIsNumber = isNumberArray(x as Datum[] | Datum[][] | TypedArray | undefined);\n  const yIsNumber = isNumberArray(y as Datum[] | Datum[][] | TypedArray | undefined);\n\n  // Helper to ensure array of (string | number)\n  const toArray = (arr: unknown): (string | number)[] => {\n    if (Array.isArray(arr)) {\n      return arr as (string | number)[];\n    }\n    if (typeof arr === 'string' || typeof arr === 'number') {\n      return [arr];\n    }\n    return [];\n  };\n\n  if (orientation === 'h') {\n    if (yIsString && xIsNumber) {\n      return { categories: toArray(y), values: toArray(x) };\n    } else if (xIsString && yIsNumber) {\n      return { categories: toArray(x), values: toArray(y) };\n    } else {\n      return { categories: yIsString ? toArray(y) : toArray(x), values: yIsString ? toArray(x) : toArray(y) };\n    }\n  } else {\n    if (xIsString && yIsNumber) {\n      return { categories: toArray(x), values: toArray(y) };\n    } else if (yIsString && xIsNumber) {\n      return { categories: toArray(y), values: toArray(x) };\n    } else {\n      return { categories: xIsString ? toArray(x) : toArray(y), values: xIsString ? toArray(y) : toArray(x) };\n    }\n  }\n}\n\nexport const transformPlotlyJsonToFunnelChartProps = (\n  input: PlotlySchema,\n  isMultiPlot: boolean,\n  colorMap: React.MutableRefObject<Map<string, string>>,\n  colorwayType: ColorwayType,\n  isDarkTheme?: boolean,\n): FunnelChartProps => {\n  const funnelData: FunnelChartDataPoint[] = [];\n\n  // Determine if data is stacked based on multiple series with multiple values per series\n  const isStacked =\n    input.data.length > 1 &&\n    input.data.every((series: Partial<PlotData>) => {\n      const values = series.values ?? series.x ?? series.value;\n      const labels = series.labels ?? series.y ?? series.stage;\n      return Array.isArray(labels) && Array.isArray(values) && values.length > 1 && labels.length > 1;\n    });\n\n  if (isStacked) {\n    // Assign a color per series/category and use it for all subValues of that category\n    const seriesColors: Record<string, string> = {};\n    input.data.forEach((series: Partial<PlotData>, seriesIdx: number) => {\n      const category = series.name || `Category ${seriesIdx + 1}`;\n      // Use the same color for this category across all stages\n      const extractedColors = extractColor(\n        input.layout?.template?.layout?.colorway,\n        colorwayType,\n        series.marker?.colors ?? series.marker?.color,\n        colorMap,\n        isDarkTheme,\n      );\n      // Always use the first color for the series/category\n      const color = resolveColor(\n        extractedColors,\n        0,\n        category,\n        colorMap,\n        input.layout?.template?.layout?.colorway,\n        isDarkTheme,\n      );\n      seriesColors[category] = color;\n\n      const labels = series.labels ?? series.y ?? series.stage;\n      const values = series.values ?? series.x ?? series.value;\n\n      if (!isArrayOrTypedArray(labels) || !isArrayOrTypedArray(values)) {\n        return;\n      }\n      if (labels && isArrayOrTypedArray(labels) && labels.length > 0) {\n        (labels as (string | number)[]).forEach((label: string, i: number) => {\n          const stageIndex = funnelData.findIndex(stage => stage.stage === label);\n          const valueNum = Number((values as (string | number)[])[i]);\n          if (isNaN(valueNum)) {\n            return;\n          }\n          if (stageIndex === -1) {\n            funnelData.push({\n              stage: label,\n              subValues: [{ category, value: valueNum, color }],\n            });\n          } else {\n            funnelData[stageIndex].subValues!.push({ category, value: valueNum, color });\n          }\n        });\n      }\n    });\n  } else {\n    // Non-stacked data handling (multiple series with single-value arrays)\n    input.data.forEach((series: Partial<PlotData>, seriesIdx: number) => {\n      const { categories, values } = getCategoriesAndValues(series);\n\n      if (!isArrayOrTypedArray(categories) || !isArrayOrTypedArray(values)) {\n        return;\n      }\n\n      const extractedColors = extractColor(\n        input.layout?.template?.layout?.colorway,\n        colorwayType,\n        series.marker?.colors ?? series.marker?.color,\n        colorMap,\n        isDarkTheme,\n      );\n\n      categories.forEach((label: string, i: number) => {\n        const color = resolveColor(\n          extractedColors,\n          i,\n          label,\n          colorMap,\n          input.layout?.template?.layout?.colorway,\n          isDarkTheme,\n        );\n        const valueNum = Number(values[i]);\n        if (isNaN(valueNum)) {\n          return;\n        }\n        funnelData.push({\n          stage: label,\n          value: valueNum,\n          color,\n        });\n      });\n    });\n  }\n\n  return {\n    data: funnelData,\n    width: input.layout?.width,\n    height: input.layout?.height,\n    orientation: (input.data[0] as Partial<PlotData>)?.orientation === 'v' ? 'horizontal' : 'vertical',\n    hideLegend: isMultiPlot || input.layout?.showlegend === false,\n  };\n};\n\nexport const projectPolarToCartesian = (input: PlotlySchema): PlotlySchema => {\n  const projection: PlotlySchema = { ...input };\n\n  // Find the global min and max radius across all series\n  let minRadius = 0;\n  let maxRadius = 0;\n  for (let sindex = 0; sindex < input.data.length; sindex++) {\n    const rVals = (input.data[sindex] as Partial<PlotData>).r;\n    if (rVals && isArrayOrTypedArray(rVals)) {\n      for (let ptindex = 0; ptindex < rVals.length; ptindex++) {\n        if (!isInvalidValue(rVals[ptindex])) {\n          minRadius = Math.min(minRadius, rVals[ptindex] as number);\n          maxRadius = Math.max(maxRadius, rVals[ptindex] as number);\n        }\n      }\n    }\n  }\n\n  // If there are negative radii, compute the shift\n  const radiusShift = minRadius < 0 ? -minRadius : 0;\n\n  // Collect all unique theta values from all scatterpolar series for equal spacing\n  const allThetaValues: Set<string> = new Set();\n  for (let sindex = 0; sindex < input.data.length; sindex++) {\n    const series = input.data[sindex] as Partial<PlotData>;\n    if (series.theta && isArrayOrTypedArray(series.theta)) {\n      series.theta.forEach(theta => allThetaValues.add(String(theta)));\n    }\n  }\n\n  // Project all points and create a perfect square domain\n  const allX: number[] = [];\n  const allY: number[] = [];\n  let originX: number | null = null;\n  for (let sindex = 0; sindex < input.data.length; sindex++) {\n    const series = input.data[sindex] as Partial<PlotData>;\n    // If scatterpolar, set __axisLabel to all unique theta values for equal spacing\n    if (isArrayOrTypedArray(series.theta)) {\n      (series as { __axisLabel: string[] }).__axisLabel = Array.from(allThetaValues);\n    }\n    series.x = [] as Datum[];\n    series.y = [] as Datum[];\n    const thetas = series.theta!;\n    const rVals = series.r!;\n\n    // Skip if rVals or thetas are not arrays\n    if (!isArrayOrTypedArray(rVals) || !isArrayOrTypedArray(thetas)) {\n      projection.data[sindex] = series;\n      continue;\n    }\n\n    // retrieve polar axis settings\n    const dirMultiplier = input.layout?.polar?.angularaxis?.direction === 'clockwise' ? -1 : 1;\n    const startAngleInRad = ((input.layout?.polar?.angularaxis?.rotation ?? 0) * Math.PI) / 180;\n\n    // Compute tick positions if categorical\n    let uniqueTheta: Datum[] = [];\n    let categorical = false;\n    if (!isNumberArray(thetas)) {\n      uniqueTheta = Array.from(new Set(thetas));\n      categorical = true;\n    }\n\n    for (let ptindex = 0; ptindex < rVals.length; ptindex++) {\n      if (isInvalidValue(thetas?.[ptindex]) || isInvalidValue(rVals?.[ptindex])) {\n        continue;\n      }\n\n      // Map theta to angle in radians\n      let thetaRad: number;\n      if (categorical) {\n        const idx = uniqueTheta.indexOf(thetas[ptindex]);\n        const step = (2 * Math.PI) / uniqueTheta.length;\n        thetaRad = startAngleInRad + dirMultiplier * idx * step;\n      } else {\n        thetaRad = startAngleInRad + dirMultiplier * (((thetas[ptindex] as number) * Math.PI) / 180);\n      }\n      // Shift only the polar origin (not the cartesian)\n      const rawRadius = rVals[ptindex] as number;\n      const polarRadius = rawRadius + radiusShift; // Only for projection\n      // Calculate cartesian coordinates (with shifted polar origin)\n      const x = polarRadius * Math.cos(thetaRad);\n      const y = polarRadius * Math.sin(thetaRad);\n\n      // Calculate the cartesian coordinates of the original polar origin (0,0)\n      // This is the point that should be mapped to (0,0) in cartesian coordinates\n      if (sindex === 0 && ptindex === 0) {\n        // For polar origin (r=0, θ=0), cartesian coordinates are (0,0)\n        // But since we shifted the radius by radiusShift, the cartesian origin is at (radiusShift, 0)\n        originX = radiusShift;\n      }\n\n      series.x.push(x);\n      series.y.push(y);\n      allX.push(x);\n      allY.push(y);\n    }\n\n    // Map text to each data point for downstream chart rendering\n    if (series.x && series.y) {\n      (series as { data?: unknown[] }).data = series.x.map((xVal, idx) => ({\n        x: xVal,\n        y: (series.y as number[])[idx],\n        ...(series.text ? { text: (series.text as string[])[idx] } : {}),\n      }));\n    }\n\n    projection.data[sindex] = series;\n  }\n\n  // 7. Recenter all cartesian coordinates\n  if (originX !== null) {\n    for (let sindex = 0; sindex < projection.data.length; sindex++) {\n      const series = projection.data[sindex] as Partial<PlotData>;\n      if (series.x && series.y) {\n        series.x = (series.x as number[]).map((v: number) => v - originX!);\n      }\n    }\n    // Also recenter allX for normalization\n    for (let i = 0; i < allX.length; i++) {\n      allX[i] = allX[i] - originX!;\n    }\n  }\n\n  // 8. Find the maximum absolute value among all x and y\n  let maxAbs = Math.max(...allX.map(Math.abs), ...allY.map(Math.abs));\n  maxAbs = maxAbs === 0 ? 1 : maxAbs;\n\n  // 9. Rescale all points so that the largest |x| or |y| is 0.5\n  for (let sindex = 0; sindex < projection.data.length; sindex++) {\n    const series = projection.data[sindex] as Partial<PlotData>;\n    if (series.x && series.y) {\n      series.x = (series.x as number[]).map((v: number) => v / (2 * maxAbs));\n      series.y = (series.y as number[]).map((v: number) => v / (2 * maxAbs));\n    }\n  }\n\n  // 10. Customize layout for perfect square with absolute positioning\n  const size = input.layout?.width || input.layout?.height || 500;\n  projection.layout = {\n    ...projection.layout,\n    width: size,\n    height: size,\n  };\n  // Attach originX as custom properties\n  (projection.layout as { __polarOriginX?: number }).__polarOriginX = originX ?? undefined;\n\n  return projection;\n};\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction isPlainObject(obj: any) {\n  return (\n    Object.prototype.toString.call(obj) === '[object Object]' &&\n    Object.getPrototypeOf(obj).hasOwnProperty('hasOwnProperty')\n  );\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nvar arrayAttributes: any[] = [];\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nvar stack: any[] = [];\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nvar isArrayStack: any[] = [];\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nvar baseContainer: any, baseAttrName: any;\n/**\n * Interate iteratively through the trace object and find all the array attributes.\n * 1 trace record = 1 series of data\n * @param trace\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function findArrayAttributes(trace: any): void {\n  // Init basecontainer and baseAttrName\n  crawlIntoTrace(baseContainer, 0, '');\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction crawlIntoTrace(container: any, i: number, astrPartial: any) {\n  var item = container[stack[i]];\n  var newAstrPartial = astrPartial + stack[i];\n  if (i === stack.length - 1) {\n    if (isArrayOrTypedArray(item)) {\n      arrayAttributes.push(baseAttrName + newAstrPartial);\n    }\n  } else {\n    if (isArrayStack[i]) {\n      if (Array.isArray(item)) {\n        for (var j = 0; j < item.length; j++) {\n          if (isPlainObject(item[j])) {\n            crawlIntoTrace(item[j], i + 1, newAstrPartial + '[' + j + '].');\n          }\n        }\n      }\n    } else if (isPlainObject(item)) {\n      crawlIntoTrace(item, i + 1, newAstrPartial + '.');\n    }\n  }\n}\n\nfunction getLineOptions(line: Partial<ScatterLine> | undefined): LineChartLineOptions | undefined {\n  if (!line) {\n    return;\n  }\n\n  let lineOptions: LineChartLineOptions = {};\n  if (line.dash) {\n    lineOptions = { ...lineOptions, ...dashOptions[line.dash] };\n  }\n\n  switch (line.shape) {\n    case 'spline':\n      const smoothing = typeof line.smoothing === 'number' ? line.smoothing : 1;\n      lineOptions.curve = d3CurveCardinal.tension(1 - smoothing / 1.3);\n      break;\n    case 'hv':\n      lineOptions.curve = 'stepAfter';\n      break;\n    case 'vh':\n      lineOptions.curve = 'stepBefore';\n      break;\n    case 'hvh':\n      lineOptions.curve = 'step';\n      break;\n    default:\n      lineOptions.curve = 'linear';\n  }\n\n  return Object.keys(lineOptions).length > 0 ? lineOptions : undefined;\n}\n\n// TODO: Use binary search to find the appropriate bin for numeric value.\nconst findBinIndex = (\n  bins: string[][] | Bin<number, number>[],\n  value: string | number | null | undefined,\n  isString: boolean,\n) => {\n  if (typeof value === 'undefined' || value === null) {\n    return -1;\n  }\n\n  return isString\n    ? (bins as string[][]).findIndex(bin => bin.includes(value as string))\n    : (bins as Bin<number, number>[]).findIndex(\n        (bin, index) =>\n          (value as number) >= bin.x0! &&\n          (index === bins.length - 1 ? (value as number) <= bin.x1! : (value as number) < bin.x1!),\n      );\n};\n\nconst getBinSize = (bin: Bin<number, number>) => {\n  return bin.x1! - bin.x0!;\n};\n\nconst getBinCenter = (bin: Bin<number, number>) => {\n  return (bin.x1! + bin.x0!) / 2;\n};\n\n// TODO: Add support for date axes\nconst createBins = (\n  data: TypedArray | Datum[] | Datum[][] | undefined,\n  binStart?: number | string,\n  binEnd?: number | string,\n  binSize?: number | string,\n) => {\n  if (!data || data.length === 0) {\n    return [];\n  }\n\n  if (isStringArray(data)) {\n    const categories = Array.from(new Set(data as string[]));\n    const start = typeof binStart === 'number' ? Math.ceil(binStart) : 0;\n    const stop = typeof binEnd === 'number' ? Math.floor(binEnd) + 1 : categories.length;\n    const step = typeof binSize === 'number' ? binSize : 1;\n\n    return d3Range(start, stop, step).map(i => categories.slice(i, i + step));\n  }\n\n  const scale = d3ScaleLinear()\n    .domain(d3Extent<number>(data as number[]) as [number, number])\n    .nice();\n  let [minVal, maxVal] = scale.domain();\n\n  minVal = typeof binStart === 'number' ? binStart : minVal;\n  maxVal = typeof binEnd === 'number' ? binEnd : maxVal;\n\n  const binGenerator = d3Bin().domain([minVal, maxVal]);\n\n  if (typeof binSize === 'number' && binSize > 0) {\n    const thresholds: number[] = [];\n    const precision = Math.max(calculatePrecision(minVal), calculatePrecision(binSize));\n    let th = precisionRound(minVal, precision);\n\n    while (th < precisionRound(maxVal + binSize, precision)) {\n      thresholds.push(th);\n      th = precisionRound(th + binSize, precision);\n    }\n\n    minVal = thresholds[0];\n    maxVal = thresholds[thresholds.length - 1];\n    binGenerator.domain([minVal, maxVal]).thresholds(thresholds);\n\n    // When the domain ends at the last threshold (maxVal), d3Bin creates an extra final bin where\n    // both x0 and x1 are equal to maxVal and inclusive. The previous bin also has x1 equal to maxVal,\n    // but it is exclusive. To maintain consistent bin widths, remove the final bin,\n    // making the previous bin the last one, with both x0 and x1 inclusive.\n    return binGenerator(data as number[]).slice(0, -1);\n  }\n  return binGenerator(data as number[]);\n};\n\nconst calculateHistFunc = (histfunc: PlotData['histfunc'] | undefined, bin: number[]) => {\n  switch (histfunc) {\n    case 'sum':\n      return d3Sum(bin);\n    case 'avg':\n      return bin.length === 0 ? 0 : d3Sum(bin) / bin.length;\n    case 'min':\n      return d3Min(bin) ?? 0;\n    case 'max':\n      return d3Max(bin) ?? 0;\n    default:\n      return bin.length;\n  }\n};\n\nconst calculateHistNorm = (\n  histnorm: PlotData['histnorm'] | undefined,\n  value: number,\n  total: number,\n  dx: number,\n  dy: number = 1,\n) => {\n  switch (histnorm) {\n    case 'percent':\n      return total === 0 ? 0 : (value / total) * 100;\n    case 'probability':\n      return total === 0 ? 0 : value / total;\n    case 'density':\n      return dx * dy === 0 ? 0 : value / (dx * dy);\n    case 'probability density':\n      return total * dx * dy === 0 ? 0 : value / (total * dx * dy);\n    default:\n      return value;\n  }\n};\n\nconst getLegendShape = (series: Partial<PlotData>): Legend['shape'] => {\n  const dashType = series.line?.dash || 'solid';\n  if (dashType === 'dot' || dashType === 'dash' || dashType === 'dashdot') {\n    return 'dottedLine';\n  } else if (series.mode?.includes('markers')) {\n    return 'circle';\n  }\n  return 'default';\n};\n\nexport const getAllupLegendsProps = (\n  input: PlotlySchema,\n  colorMap: React.MutableRefObject<Map<string, string>>,\n  colorwayType: ColorwayType,\n  traceInfo: TraceInfo[],\n  isDarkTheme?: boolean,\n): LegendsProps => {\n  const allupLegends: Legend[] = [];\n  // reduce on showlegend boolean propperty. reduce should return true if at least one series has showlegend true\n  const toShowLegend = input.data.reduce((acc, series) => {\n    return (\n      acc || (series as Partial<PlotData>).showlegend === true || (series as Partial<PlotData>).showlegend === undefined\n    );\n  }, false);\n\n  if (toShowLegend) {\n    input.data.forEach((series: Data, index) => {\n      if (traceInfo[index].type === 'donut') {\n        const pieSeries = series as Partial<PieData>;\n        const colors: string[] | string | null | undefined = extractColor(\n          input.layout?.piecolorway ?? input.layout?.template?.layout?.colorway,\n          colorwayType,\n          input.layout?.piecolorway ?? pieSeries?.marker?.colors,\n          colorMap,\n          isDarkTheme,\n          true,\n        );\n\n        pieSeries.labels?.forEach((label, labelIndex: number) => {\n          const legend = `${label}`;\n          // resolve color for each legend from the extracted colors\n          const color: string = resolveColor(\n            colors,\n            labelIndex,\n            legend,\n            colorMap,\n            input.layout?.piecolorway ?? input.layout?.template?.layout?.colorway,\n            isDarkTheme,\n            true,\n          );\n          if (legend !== '' && allupLegends.some(group => group.title === legend) === false) {\n            allupLegends.push({\n              title: legend,\n              color,\n            });\n          }\n        });\n      } else if (isNonPlotType(traceInfo[index].type) === false) {\n        const plotSeries = series as Partial<PlotData>;\n        const name = plotSeries.legendgroup;\n        const color = plotSeries.line?.color || plotSeries.marker?.color;\n        const legendShape = getLegendShape(plotSeries);\n        const resolvedColor = extractColor(\n          input.layout?.template?.layout?.colorway,\n          colorwayType,\n          color,\n          colorMap,\n          isDarkTheme,\n        );\n        if (name !== undefined && name !== '' && allupLegends.some(group => group.title === name) === false) {\n          allupLegends.push({\n            title: name,\n            color: resolvedColor as string,\n            shape: legendShape,\n          });\n        }\n      }\n    });\n  }\n\n  return {\n    legends: allupLegends,\n    centerLegends: true,\n    enabledWrapLines: true,\n    canSelectMultipleLegends: true,\n  };\n};\n\nconst getLegendProps = (data: Data[], layout: Partial<Layout> | undefined, isMultiPlot: boolean) => {\n  const legends: string[] = [];\n  if (data.length === 1) {\n    legends.push(data[0].name || '');\n  } else {\n    data.forEach((series, index) => {\n      legends.push(series.name || `Series ${index + 1}`);\n    });\n  }\n\n  const hideLegendsData = data.every((series: Partial<PlotData>) => series.showlegend === false);\n  const hideLegendsInferred = layout?.showlegend === false || (layout?.showlegend !== true && legends.length < 2);\n\n  return {\n    legends,\n    hideLegend: isMultiPlot || hideLegendsInferred || hideLegendsData,\n  };\n};\n\nexport const getNumberAtIndexOrDefault = (data: PlotData['z'] | undefined, index: number): number | undefined => {\n  if (isArrayOrTypedArray(data)) {\n    if (typeof data![index] !== 'number' || !isFinite(data![index] as number)) {\n      return;\n    }\n\n    return data![index] as number;\n  }\n\n  return 1;\n};\n\nexport const getValidXYRanges = (\n  series: Partial<PlotData>,\n  resolveX?: (v: Datum) => Datum,\n  resolveY?: (v: Datum) => Datum,\n): [number, number][] => {\n  if (!isArrayOrTypedArray(series.x) || !isArrayOrTypedArray(series.y)) {\n    return [];\n  }\n\n  const ranges: [number, number][] = [];\n  let start = 0;\n  let end = 0;\n  for (; end < series.x!.length; end++) {\n    if (\n      isInvalidValue(series.x![end]) ||\n      (typeof resolveX === 'function' && isInvalidValue(resolveX(series.x![end] as Datum))) ||\n      isInvalidValue(series.y![end]) ||\n      (typeof resolveY === 'function' && isInvalidValue(resolveY(series.y![end] as Datum)))\n    ) {\n      if (end - start > 0) {\n        ranges.push([start, end]);\n      }\n      start = end + 1;\n    }\n  }\n  if (end - start > 0) {\n    ranges.push([start, end]);\n  }\n\n  return ranges;\n};\n\nconst getIndexFromKey = (key: string, pattern: string): number => {\n  const normalizedKey = key.replace(pattern, '') === '' ? '1' : key.replace(pattern, '');\n  return parseInt(normalizedKey, 10) - 1;\n};\n\nexport const isNonPlotType = (chartType: string): boolean => {\n  return ['donut', 'sankey', 'pie'].includes(chartType);\n};\n\nexport const getGridProperties = (\n  schema: PlotlySchema | undefined,\n  isMultiPlot: boolean,\n  validTracesInfo: TraceInfo[],\n): GridProperties => {\n  const domainX: DomainInterval[] = [];\n  const domainY: DomainInterval[] = [];\n  let cartesianDomains = 0;\n  type AnnotationProps = {\n    xAnnotation?: string;\n    yAnnotation?: string;\n  };\n  const annotations: Record<number, AnnotationProps> = {};\n  let templateRows = '1fr';\n  let templateColumns = '1fr';\n  const gridLayout: GridAxisProperties = {};\n  if (!isMultiPlot) {\n    return { templateRows, templateColumns, layout: gridLayout };\n  }\n\n  const layout = schema?.layout as Partial<Layout> | undefined;\n\n  if (layout !== undefined && layout !== null && Object.keys(layout).length > 0) {\n    Object.keys(layout ?? {}).forEach(key => {\n      if (key.startsWith('xaxis')) {\n        const index = getIndexFromKey(key, 'xaxis');\n        const anchor = (layout[key as keyof typeof layout] as Partial<LayoutAxis>)?.anchor ?? 'y';\n        const anchorIndex = getIndexFromKey(anchor, 'y');\n        if (index !== anchorIndex) {\n          throw new Error(`Invalid layout: xaxis ${index + 1} anchor should be y${anchorIndex + 1}`);\n        }\n        const xAxisLayout = layout[key as keyof typeof layout] as Partial<LayoutAxis>;\n        const domainXInfo: DomainInterval = {\n          start: xAxisLayout?.domain ? xAxisLayout.domain[0] : 0,\n          end: xAxisLayout?.domain ? xAxisLayout.domain[1] : 1,\n        };\n        domainX.push(domainXInfo);\n      } else if (key.startsWith('yaxis')) {\n        const index = getIndexFromKey(key, 'yaxis');\n        const anchor = (layout[key as keyof typeof layout] as Partial<LayoutAxis>)?.anchor ?? 'x';\n        const anchorIndex = getIndexFromKey(anchor, 'x');\n        if (index !== anchorIndex) {\n          if ((index === 1 && anchorIndex === 0) || layout.yaxis2?.side === 'right') {\n            // Special case for secondary y axis where yaxis2 can anchor to x1\n            return { templateRows, templateColumns };\n          }\n          throw new Error(`Invalid layout: yaxis ${index + 1} anchor should be x${anchorIndex + 1}`);\n        }\n        const yAxisLayout = layout[key as keyof typeof layout] as Partial<LayoutAxis>;\n        const domainYInfo: DomainInterval = {\n          start: yAxisLayout?.domain ? yAxisLayout.domain[0] : 0,\n          end: yAxisLayout?.domain ? yAxisLayout.domain[1] : 1,\n        };\n        domainY.push(domainYInfo);\n      }\n    });\n  }\n\n  cartesianDomains = domainX.length; // Assuming that the number of x and y axes is the same\n  validTracesInfo.forEach((trace, index) => {\n    if (isNonPlotType(trace.type)) {\n      const series = schema?.data?.[index] as Partial<PieData> | Partial<SankeyData>;\n      const domainXInfo: DomainInterval = {\n        start: series.domain?.x ? series.domain.x[0] : 0,\n        end: series.domain?.x ? series.domain.x[1] : 1,\n      };\n      const domainYInfo: DomainInterval = {\n        start: series.domain?.y ? series.domain.y[0] : 0,\n        end: series.domain?.y ? series.domain.y[1] : 1,\n      };\n      domainX.push(domainXInfo);\n      domainY.push(domainYInfo);\n    }\n  });\n\n  if (layout !== undefined && layout !== null && Object.keys(layout).length > 0) {\n    layout.annotations?.forEach(annotation => {\n      const xMatches = domainX.flatMap((interval, idx) =>\n        (annotation?.x as number) >= interval.start && (annotation?.x as number) <= interval.end ? [idx] : [],\n      );\n      const yMatch = domainY.findIndex(\n        (interval, yIndex) =>\n          xMatches.includes(yIndex) &&\n          (annotation?.y as number) >= interval.start &&\n          (annotation?.y as number) <= interval.end,\n      );\n\n      if (yMatch !== -1) {\n        if (annotations[yMatch] === undefined) {\n          annotations[yMatch] = {} as AnnotationProps;\n        }\n        if ((annotation?.textangle as number) === 90) {\n          annotations[yMatch].yAnnotation = annotation.text;\n        } else {\n          annotations[yMatch].xAnnotation = annotation.text;\n        }\n      }\n    });\n  }\n\n  if (domainX.length > 0) {\n    const uniqueXIntervals = new Map<string, DomainInterval>();\n    domainX.forEach(interval => {\n      const key = `${interval.start}-${interval.end}`;\n      if (!uniqueXIntervals.has(key)) {\n        uniqueXIntervals.set(key, interval);\n      }\n    });\n    const sortedXStart = Array.from(uniqueXIntervals.values())\n      .map(interval => interval.start)\n      .sort();\n\n    templateColumns = `repeat(${sortedXStart.length}, 1fr)`;\n\n    domainX.forEach((interval, index) => {\n      const cellName =\n        index >= cartesianDomains\n          ? `${NON_PLOT_KEY_PREFIX}${index - cartesianDomains + 1}`\n          : (`x${index === 0 ? '' : index + 1}` as XAxisName);\n\n      const columnIndex = sortedXStart.findIndex(start => start === interval.start);\n      const columnNumber = columnIndex + 1; // Column numbers are 1-based\n\n      const annotationProps = annotations[index] as AnnotationProps;\n      const xAnnotation = annotationProps?.xAnnotation;\n\n      const row: AxisProperties = {\n        row: -1,\n        column: columnNumber,\n        xAnnotation,\n        xDomain: interval,\n        yDomain: { start: 0, end: 1 }, // Default yDomain for x-axis\n      };\n      gridLayout[cellName] = row;\n    });\n  }\n  if (domainY.length > 0) {\n    const uniqueYIntervals = new Map<string, DomainInterval>();\n    domainY.forEach(interval => {\n      const key = `${interval.start}-${interval.end}`;\n      if (!uniqueYIntervals.has(key)) {\n        uniqueYIntervals.set(key, interval);\n      }\n    });\n    const sortedYStart = Array.from(uniqueYIntervals.values())\n      .map(interval => interval.start)\n      .sort();\n\n    const numberOfRows = sortedYStart.length;\n\n    templateRows = `repeat(${numberOfRows}, 1fr)`;\n    domainY.forEach((interval, index) => {\n      const cellName =\n        index >= cartesianDomains\n          ? `${NON_PLOT_KEY_PREFIX}${index - cartesianDomains + 1}`\n          : (`x${index === 0 ? '' : index + 1}` as XAxisName);\n      const rowIndex = sortedYStart.findIndex(start => start === interval.start);\n      const rowNumber = numberOfRows - rowIndex; // Rows are 1-based and we need to reverse the order for CSS grid\n\n      const annotationProps = annotations[index] as AnnotationProps;\n      const yAnnotation = annotationProps?.yAnnotation;\n\n      const cell = gridLayout[cellName];\n\n      if (cell !== undefined) {\n        cell.row = rowNumber;\n        cell.yAnnotation = yAnnotation;\n        cell.yDomain = interval;\n      }\n    });\n  }\n\n  return {\n    templateRows,\n    templateColumns,\n    layout: gridLayout,\n  };\n};\n\ntype GetAxisCategoryOrderPropsResult = Pick<CartesianChartProps, 'xAxisCategoryOrder' | 'yAxisCategoryOrder'>;\n\n/**\n * @see {@link https://github.com/plotly/plotly.js/blob/master/src/plots/cartesian/category_order_defaults.js#L50}\n */\nconst getAxisCategoryOrderProps = (data: Data[], layout: Partial<Layout> | undefined) => {\n  const result: GetAxisCategoryOrderPropsResult = {};\n\n  const axesById: Record<string, Partial<LayoutAxis> | undefined> = {\n    x: layout?.xaxis,\n    y: layout?.yaxis,\n  };\n  Object.keys(axesById).forEach(axId => {\n    const ax = axesById[axId];\n    const axLetter = axId[0] as 'x' | 'y';\n    const propName = `${axLetter}AxisCategoryOrder` as keyof GetAxisCategoryOrderPropsResult;\n\n    const values: Datum[] = [];\n    data.forEach((series: Partial<PlotData>) => {\n      series[axLetter]?.forEach(val => {\n        if (!isInvalidValue(val)) {\n          values.push(val as Datum);\n        }\n      });\n    });\n\n    const isAxisTypeCategory =\n      ax?.type === 'category' || (isStringArray(values) && !isNumberArray(values) && !isDateArray(values));\n    if (!isAxisTypeCategory) {\n      result[propName] = 'data';\n      return;\n    }\n\n    const isValidArray = isArrayOrTypedArray(ax?.categoryarray) && ax!.categoryarray!.length > 0;\n    if (isValidArray && (!ax?.categoryorder || ax.categoryorder === 'array')) {\n      result[propName] = ax!.categoryarray;\n      return;\n    }\n\n    if (!ax?.categoryorder || ax.categoryorder === 'trace' || ax.categoryorder === 'array') {\n      const categoriesInTraceOrder = Array.from(new Set(values as string[]));\n      result[propName] = ax?.autorange === 'reversed' ? categoriesInTraceOrder.reverse() : categoriesInTraceOrder;\n      return;\n    }\n\n    result[propName] = ax.categoryorder;\n  });\n\n  return result;\n};\n\nconst getBarProps = (\n  data: Data[],\n  layout: Partial<Layout> | undefined,\n  isHorizontal?: boolean,\n):\n  | Pick<VerticalBarChartProps, 'barWidth' | 'maxBarWidth' | 'xAxisInnerPadding' | 'xAxisOuterPadding' | 'xAxisPadding'>\n  | Pick<GanttChartProps, 'barHeight' | 'maxBarHeight' | 'yAxisPadding'> => {\n  let padding: number | undefined;\n\n  if (typeof layout?.bargap === 'number') {\n    if (layout.bargap >= 0 && layout.bargap <= 1) {\n      padding = layout.bargap;\n    } else {\n      // Plotly uses a default bargap of 0.2, as noted here: https://github.com/plotly/plotly.js/blob/1d5a249e43dd31ae50acf02117a19e5ac97387e9/src/traces/bar/layout_defaults.js#L58.\n      // However, we don't use this value as our default padding because it causes the bars to\n      // appear disproportionately wide in large containers.\n      padding = 0.2;\n    }\n  }\n\n  const plotlyBarWidths = data\n    .map((series: Partial<PlotData>) => {\n      if (series.type === 'bar' && (isArrayOrTypedArray(series.width) || typeof series.width === 'number')) {\n        return series.width;\n      }\n      return [];\n    })\n    .flat();\n  const maxPlotlyBarWidth = d3Max(plotlyBarWidths as number[]);\n  if (typeof maxPlotlyBarWidth === 'number') {\n    padding = 1 - maxPlotlyBarWidth;\n    padding = Math.max(0, Math.min(padding, 1));\n  }\n\n  if (typeof padding === 'undefined') {\n    return {};\n  }\n\n  if (isHorizontal) {\n    return {\n      maxBarHeight: 1000,\n      yAxisPadding: padding,\n    };\n  }\n\n  return {\n    barWidth: 'auto',\n    maxBarWidth: 1000,\n    xAxisInnerPadding: padding,\n    xAxisOuterPadding: padding / 2,\n  };\n};\n\ntype GetAxisScaleTypePropsResult = Pick<CartesianChartProps, 'xScaleType' | 'yScaleType' | 'secondaryYScaleType'>;\n\nconst getAxisScaleTypeProps = (data: Data[], layout: Partial<Layout> | undefined): GetAxisScaleTypePropsResult => {\n  const result: GetAxisScaleTypePropsResult = {};\n\n  const axisObjects = getAxisObjects(data, layout);\n\n  if (axisObjects.x?.type === 'log') {\n    result.xScaleType = 'log';\n  }\n  if (axisObjects.y?.type === 'log') {\n    result.yScaleType = 'log';\n  }\n  if (axisObjects.y2?.type === 'log') {\n    result.secondaryYScaleType = 'log';\n  }\n\n  return result;\n};\n\ntype GetAxisTickPropsResult = Pick<\n  CartesianChartProps,\n  'tickValues' | 'xAxisTickCount' | 'xAxis' | 'yAxisTickValues' | 'yAxisTickCount' | 'yAxis'\n>;\n\n/**\n * @see {@link https://github.com/plotly/plotly.js/blob/master/src/plots/cartesian/tick_value_defaults.js#L8}\n */\nconst getAxisTickProps = (data: Data[], layout: Partial<Layout> | undefined): GetAxisTickPropsResult => {\n  const props: GetAxisTickPropsResult = {};\n  const axisObjects = getAxisObjects(data, layout);\n\n  Object.keys(axisObjects).forEach(axId => {\n    const ax = axisObjects[axId];\n    if (!ax) {\n      return;\n    }\n\n    const axType = getAxisType(data, ax);\n\n    if ((!ax.tickmode || ax.tickmode === 'array') && isArrayOrTypedArray(ax.tickvals)) {\n      const tickValues = axType === 'date' ? ax.tickvals!.map((v: string | number | Date) => new Date(v)) : ax.tickvals;\n\n      if (axId === 'x') {\n        props.tickValues = tickValues;\n      } else if (axId === 'y') {\n        props.yAxisTickValues = tickValues;\n      }\n      return;\n    }\n\n    if ((!ax.tickmode || ax.tickmode === 'linear') && ax.dtick) {\n      const dtick = plotlyDtick(ax.dtick, axType);\n      const tick0 = plotlyTick0(ax.tick0, axType, dtick);\n\n      if (axId === 'x') {\n        props.xAxis = {\n          tickStep: dtick,\n          tick0,\n        };\n      } else if (axId === 'y') {\n        props.yAxis = {\n          tickStep: dtick,\n          tick0,\n        };\n      }\n      return;\n    }\n\n    if ((!ax.tickmode || ax.tickmode === 'auto') && typeof ax.nticks === 'number' && ax.nticks >= 0) {\n      if (axId === 'x') {\n        props.xAxisTickCount = ax.nticks;\n      } else if (axId === 'y') {\n        props.yAxisTickCount = ax.nticks;\n      }\n    }\n  });\n\n  return props;\n};\n\n/**\n * @see {@link https://github.com/plotly/plotly.js/blob/master/src/plots/cartesian/clean_ticks.js#L16}\n */\nconst plotlyDtick = (dtick: DTickValue | undefined, axType: AxisType | undefined) => {\n  const isLogAx = axType === 'log';\n  const isDateAx = axType === 'date';\n  const isCatAx = axType === 'category';\n  const dtickDflt = isDateAx ? 86400000 : 1;\n\n  if (!dtick) {\n    return dtickDflt;\n  }\n\n  if (isNumber(dtick)) {\n    dtick = Number(dtick);\n    if (dtick <= 0) {\n      return dtickDflt;\n    }\n    if (isCatAx) {\n      // category dtick must be positive integers\n      return Math.max(1, Math.round(dtick));\n    }\n    if (isDateAx) {\n      // date dtick must be at least 0.1ms (our current precision)\n      return Math.max(0.1, dtick);\n    }\n    return dtick;\n  }\n\n  if (typeof dtick !== 'string' || !(isDateAx || isLogAx)) {\n    return dtickDflt;\n  }\n\n  const prefix = dtick.charAt(0);\n  const dtickNum = isNumber(dtick.slice(1)) ? Number(dtick.slice(1)) : 0;\n\n  if (\n    dtickNum <= 0 ||\n    !(\n      // \"M<n>\" gives ticks every (integer) n months\n      (\n        (isDateAx && prefix === 'M' && dtickNum === Math.round(dtickNum)) ||\n        // \"L<f>\" gives ticks linearly spaced in data (not in position) every (float) f\n        (isLogAx && prefix === 'L') ||\n        // \"D1\" gives powers of 10 with all small digits between, \"D2\" gives only 2 and 5\n        (isLogAx && prefix === 'D' && (dtickNum === 1 || dtickNum === 2))\n      )\n    )\n  ) {\n    return dtickDflt;\n  }\n\n  return dtick;\n};\n\n/**\n * @see {@link https://github.com/plotly/plotly.js/blob/master/src/plots/cartesian/clean_ticks.js#L70}\n */\nconst plotlyTick0 = (tick0: number | string | undefined, axType: AxisType | undefined, dtick: string | number) => {\n  if (axType === 'date') {\n    return isDate(tick0) ? new Date(tick0!) : new Date(DEFAULT_DATE_STRING);\n  }\n  if (dtick === 'D1' || dtick === 'D2') {\n    // D1 and D2 modes ignore tick0 entirely\n    return undefined;\n  }\n  // Aside from date axes, tick0 must be numeric\n  return isNumber(tick0) ? Number(tick0) : 0;\n};\n\ninterface AxisObject extends Partial<LayoutAxis> {\n  _id: string;\n}\n\nconst getAxisObjects = (data: Data[], layout: Partial<Layout> | undefined) => {\n  // Traces are grouped by their xaxis property, and for each group/subplot, the adapter functions\n  // are called with the corresponding filtered data. As a result, all traces passed to an adapter\n  // function share the same xaxis.\n  let xAxisId: number | undefined;\n  const yAxisIds = new Set<number>();\n  data.forEach((series: Partial<PlotData>) => {\n    const axisIds = getAxisIds(series);\n    xAxisId = axisIds.x;\n    yAxisIds.add(axisIds.y);\n  });\n\n  const makeAxisObject = (axLetter: 'x' | 'y', axId: number): AxisObject => ({\n    ...layout?.[getAxisKey(axLetter, axId)],\n    _id: `${axLetter}${axId > 1 ? axId : ''}`,\n  });\n\n  const axisObjects: Record<string, AxisObject> = {};\n\n  if (typeof xAxisId === 'number') {\n    axisObjects.x = makeAxisObject('x', xAxisId);\n  }\n\n  const sortedYAxisIds = Array.from(yAxisIds).sort();\n  if (sortedYAxisIds.length > 0) {\n    axisObjects.y = makeAxisObject('y', sortedYAxisIds[0]);\n  }\n  if (sortedYAxisIds.length > 1) {\n    axisObjects.y2 = makeAxisObject('y', sortedYAxisIds[1]);\n  }\n\n  return axisObjects;\n};\n\nfunction getAxisType(data: Data[], ax: AxisObject): AxisType;\nfunction getAxisType(data: Data[], layout: Partial<Layout> | undefined, axisId: string): AxisType;\nfunction getAxisType(data: Data[], arg2: AxisObject | Partial<Layout> | undefined, arg3?: string): AxisType {\n  let ax: AxisObject | undefined;\n\n  if (arg2 && typeof arg2 === 'object' && '_id' in arg2) {\n    ax = arg2;\n  } else if (typeof arg3 === 'string') {\n    const layout = arg2 as Partial<Layout> | undefined;\n    ax = getAxisObjects(data, layout)[arg3];\n  }\n\n  if (!ax) {\n    return 'category';\n  }\n\n  if (['linear', 'log', 'date', 'category'].includes(ax.type ?? '')) {\n    return ax.type!;\n  }\n\n  const axLetter = ax._id[0] as 'x' | 'y';\n  const values: Datum[] = [];\n  data.forEach((series: Partial<PlotData>) => {\n    const axId = series[`${axLetter}axis`];\n    if (axId === ax._id || (!axId && ax._id === axLetter)) {\n      series[axLetter]?.forEach(val => {\n        if (!isInvalidValue(val)) {\n          values.push(val as Datum);\n        }\n      });\n    }\n  });\n\n  if (isNumberArray(values) && !isYearArray(values)) {\n    return 'linear';\n  }\n  if (isDateArray(values)) {\n    return 'date';\n  }\n  return 'category';\n}\n\nconst getAxisValueResolver = (data: Data[], layout: Partial<Layout> | undefined, axisId: string) => {\n  const axType = getAxisType(data, layout, axisId);\n\n  return (value: Datum): Datum => {\n    if (isInvalidValue(value)) {\n      return null;\n    }\n\n    switch (axType) {\n      case 'linear':\n      case 'log':\n        return isNumber(value) ? +value! : null;\n\n      case 'date':\n        if (isNumber(value)) {\n          return new Date(+value!);\n        }\n        if (typeof value === 'string') {\n          return new Date(value);\n        }\n        return null;\n\n      case 'category':\n        return `${value}`;\n\n      default:\n        return null;\n    }\n  };\n};\n\n/**\n * This is experimental. Use it only with valid datetime strings to verify if they conform to the ISO 8601 format.\n */\nconst isoDateRegex = /^\\d{4}(-\\d{2}(-\\d{2})?)?(T\\d{2}:\\d{2}(:\\d{2}(\\.\\d{1,9})?)?(Z)?)?$/;\n\n/**\n * We want to display localized date and time in the charts, so the useUTC prop is set to false.\n * But this can sometimes cause the formatters to display the datetime incorrectly.\n * To work around this issue, we use this function to adjust datetime strings so that they are always interpreted\n * as local time, allowing the formatters to produce the correct output.\n *\n * FIXME: The formatters should always produce a clear and accurate localized output, regardless of the\n * format used to create the date object.\n */\nconst parseLocalDate = (value: string | number) => {\n  if (typeof value === 'string') {\n    const match = value.match(isoDateRegex);\n    if (match) {\n      if (!match[3]) {\n        value += 'T00:00';\n      } else if (match[6]) {\n        value = value.replace('Z', '');\n      }\n    }\n  }\n  return new Date(value);\n};\n"],"names":["React","bin","d3Bin","extent","d3Extent","sum","d3Sum","min","d3Min","max","d3Max","range","d3Range","scaleLinear","d3ScaleLinear","format","d3Format","DataVizPalette","getColorFromToken","DEFAULT_DATE_STRING","findNumericMinMaxOfY","formatScientificLimitWidth","MIN_DONUT_RADIUS","calculatePrecision","precisionRound","isArrayOrTypedArray","isDate","isDateArray","isNumberArray","isStringArray","isYearArray","isInvalidValue","formatToLocaleString","isNumber","isObjectArray","getAxisIds","getAxisKey","isScatterAreaChart","curveCardinal","d3CurveCardinal","getOpacity","extractColor","resolveColor","createColorScale","rgb","NON_PLOT_KEY_PREFIX","SINGLE_REPEAT","dashOptions","dot","strokeDasharray","strokeLinecap","strokeWidth","lineBorderWidth","dash","longdash","dashdot","longdashdot","solid","getTitles","layout","titles","chartTitle","title","text","xAxisTitle","xaxis","yAxisTitle","yaxis","getXAxisTickFormat","series","xAxis","getXAxisProperties","tickformat","tickFormat","getYAxisTickFormat","yAxis","getYAxisProperties","yAxisTickFormat","getYMinMaxValues","length","yMinValue","yMaxValue","getFormattedCalloutYData","yVal","yAxisFormat","correctYearMonth","xValues","presentYear","Date","getFullYear","Array","isArray","Error","dates","map","possiblyMonthValue","parsedDate","filteredDateIndexPairs","date","index","filter","i","currentDate","previousDate","currentMonth","getMonth","previousMonth","currentYear","previousYear","setFullYear","month","usesSecondaryYScale","yaxis2","anchor","side","getSecondaryYAxisValues","data","containsSecondaryYAxis","allLineSeries","forEach","yValues","y","Math","type","secondaryYAxistitle","undefined","secondaryYScaleOptions","_getGaugeAxisColor","colorway","colorwayType","color","colorMap","isDarkTheme","extractedColors","resolveXAxisPoint","x","isXYearCategory","isXString","isXDate","isXNumber","toString","parseFloat","shouldIgnoreKey","key","lowerKey","toLowerCase","includes","cssKeyRegex","RegExp","test","flattenObject","obj","prefix","flattened","Object","prototype","hasOwnProperty","call","newKey","value","assign","normalizeObjectArrayForGVBC","xLabels","traces","_","flattenedObjects","item","filtered","keys","allKeys","Set","add","hasValidData","isNumericData","push","trace","name","transformPlotlyJsonToDonutProps","input","isMultiPlot","firstData","colors","piecolorway","template","marker","mapLegendToDataPoint","current","clear","labels","values","markerColors","hasMarkerColors","labelValuePairs","label","getNumberAtIndexOrDefault","validPairs","pair","sort","a","b","sortedIdx","legend","width","height","hideLabels","textinfo","donutMarginHorizontal","donutMarginVertical","innerRadius","hole","legends","reorderedEntries","slice","reverse","chartData","v","hideLegend","showlegend","showLabelsInPercent","roundCorners","order","transformPlotlyJsonToVSBCProps","fallbackVSBC","vsbcData","mapXToDataPoints","secondaryYAxisValues","getLegendProps","colorScale","resolveXAxisValue","getAxisValueResolver","index1","extractedBarColors","extractedLineColors","line","validXYRanges","getValidXYRanges","rangeStart","rangeEnd","rangeIdx","rangeXValues","rangeYValues","index2","xAxisPoint","lineData","opacity","yAxisCalloutData","copy","formatHex8","lineColor","lineOptions","mode","getLineOptions","legendShape","getLegendShape","useSecondaryYScale","xCategories","shapes","shape","shapeIdx","resolveX","val","x0Key","x0","x1Key","x1","resolveY","yref","y0Val","y0","y1Val","y1","barWidth","wrapXAxisLables","hideTickOverlap","barGapMax","showYAxisLables","noOfCharsToTruncate","showYAxisLablesTooltip","getAxisCategoryOrderProps","getBarProps","getAxisTickProps","transformPlotlyJsonToGVBCProps","processedInput","hasObjectArrayData","some","processedData","flat","gvbcDataV2","xIndex","dataV2","transformPlotlyJsonToVBCProps","vbcData","seriesIdx","xVal","xBins","createBins","xbins","start","end","size","yBins","total","binIdx","findBinIndex","calculateHistFunc","histfunc","calculateHistNorm","histnorm","getBinSize","join","getBinCenter","xAxisCalloutData","maxBarWidth","transformPlotlyJsonToAreaChartProps","transformPlotlyJsonToScatterTraceProps","transformPlotlyJsonToLineChartProps","transformPlotlyJsonToScatterChartProps","mapColorFillBars","fillcolor","startX","endX","applyPattern","chartType","isScatterMarkers","isAreaChart","isScatterChart","shouldWrapLabels","getAxisType","seriesColor","seriesOpacity","fill","markerSizes","textValues","markerSize","markerColor","originXOffset","__polarOriginX","direction","polar","angularaxis","rotation","axisLabel","__axisLabel","xMinValue","xMaxValue","lineShape","xref","yMinMax","yMinMaxValues","startValue","endValue","numDataPoints","reduce","lineChartPoints","chartProps","lineChartData","scatterChartProps","scatterChartData","commonProps","supportNegativeData","useUTC","optimizeLargeData","getAxisScaleTypeProps","roundedTicks","bars","colorFillBars","transformPlotlyJsonToHorizontalBarWithAxisProps","yValue","point","chartHeight","margin","l","padding","pad","availableHeight","numberOfRows","d","scalingFactor","gapFactor","barHeight","transformPlotlyJsonToGanttChartProps","convertXValueToNumber","parseLocalDate","base","transformPlotlyJsonToHeatmapProps","heatmapDataPoints","zMin","Number","POSITIVE_INFINITY","zMax","NEGATIVE_INFINITY","zValues","zVal","z","isYString","ybins","zBins","xBinIdx","yBinIdx","row","xBin","xIdx","yBin","yIdx","rectText","heatmapData","defaultDomain","defaultRange","color1","color2","color3","colorscale","coloraxis","histogram2d","heatmap","isDivergent","isSequential","isSequentialMinus","diverging","sequential","sequentialminus","domainValuesForColorScale","arr","rangeValuesForColorScale","sortOrder","transformPlotlyJsonToSankeyProps","node","link","validLinks","source","target","extractedNodeColors","sankeyChartData","nodes","nodeId","links","validLink","SankeyChartData","transformPlotlyJsonToGaugeProps","stepsColors","gauge","steps","step","segments","axis","disabled","sublabel","sublabelColor","delta","reference","diff","extractedIncreasingDeltaColors","increasing","abs","extractedDecreasingDeltaColors","decreasing","styles","chartValue","minValue","maxValue","chartValueFormat","variant","cleanText","replace","trim","formatValue","colIndex","cells","formatStr","suffix","formatted","resolveCellStyle","raw","rowIndex","rowEntry","mergeCells","tableCells","templateCells","align","font","transformPlotlyJsonToChartTableProps","tableData","normalizeHeaders","header","cleanedValues","cell","Boolean","fontColor","fontSize","backgroundColor","textAlign","style","columns","table","rows","col","cellValue","cleanValue","formattedValue","root","templateHeader","tableHeader","headers","getCategoriesAndValues","orientation","stage","xIsString","yIsString","xIsNumber","yIsNumber","toArray","categories","transformPlotlyJsonToFunnelChartProps","funnelData","isStacked","every","seriesColors","category","stageIndex","findIndex","valueNum","isNaN","subValues","projectPolarToCartesian","projection","minRadius","maxRadius","sindex","rVals","r","ptindex","radiusShift","allThetaValues","theta","String","allX","allY","originX","from","thetas","dirMultiplier","startAngleInRad","PI","uniqueTheta","categorical","thetaRad","idx","indexOf","rawRadius","polarRadius","cos","sin","maxAbs","isPlainObject","getPrototypeOf","arrayAttributes","stack","isArrayStack","baseContainer","baseAttrName","findArrayAttributes","crawlIntoTrace","container","astrPartial","newAstrPartial","j","smoothing","curve","tension","bins","isString","binStart","binEnd","binSize","ceil","stop","floor","scale","domain","nice","minVal","maxVal","binGenerator","thresholds","precision","th","dx","dy","dashType","getAllupLegendsProps","traceInfo","allupLegends","toShowLegend","acc","pieSeries","labelIndex","group","isNonPlotType","plotSeries","legendgroup","resolvedColor","centerLegends","enabledWrapLines","canSelectMultipleLegends","hideLegendsData","hideLegendsInferred","isFinite","ranges","getIndexFromKey","pattern","normalizedKey","parseInt","getGridProperties","schema","validTracesInfo","domainX","domainY","cartesianDomains","annotations","templateRows","templateColumns","gridLayout","startsWith","anchorIndex","xAxisLayout","domainXInfo","yAxisLayout","domainYInfo","annotation","xMatches","flatMap","interval","yMatch","yIndex","textangle","yAnnotation","xAnnotation","uniqueXIntervals","Map","has","set","sortedXStart","cellName","columnIndex","columnNumber","annotationProps","column","xDomain","yDomain","uniqueYIntervals","sortedYStart","rowNumber","result","axesById","axId","ax","axLetter","propName","isAxisTypeCategory","isValidArray","categoryarray","categoryorder","categoriesInTraceOrder","autorange","isHorizontal","bargap","plotlyBarWidths","maxPlotlyBarWidth","maxBarHeight","yAxisPadding","xAxisInnerPadding","xAxisOuterPadding","axisObjects","getAxisObjects","xScaleType","yScaleType","y2","secondaryYScaleType","props","axType","tickmode","tickvals","tickValues","yAxisTickValues","dtick","plotlyDtick","tick0","plotlyTick0","tickStep","nticks","xAxisTickCount","yAxisTickCount","isLogAx","isDateAx","isCatAx","dtickDflt","round","charAt","dtickNum","xAxisId","yAxisIds","axisIds","makeAxisObject","_id","sortedYAxisIds","arg2","arg3","axisId","isoDateRegex","match"],"mappings":"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"}