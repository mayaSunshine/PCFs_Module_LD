'use client';
import * as React from 'react';
import { getWindow } from '../../utilities/getWindow';
import { useResponsiveChildStyles } from './useResponsiveChildStyles.styles';
import { mergeClasses } from '@griffel/react';
/**
 * Responsive Container component
 * {@docCategory ResponsiveContainer}
 */ export const ResponsiveContainer = (props)=>{
    const containerRef = React.useRef(null);
    const onResizeRef = React.useRef();
    const childClasses = useResponsiveChildStyles();
    const [size, setSize] = React.useState({});
    onResizeRef.current = props.onResize;
    React.useEffect(()=>{
        const _window = getWindow(containerRef.current);
        let animationFrameId;
        let resizeObserver;
        const resizeCallback = (entries)=>{
            var _onResizeRef_current;
            const { width: containerWidth, height: containerHeight } = entries[0].contentRect;
            // rAF is an alternative to the throttle function. For more info, see:
            // https://css-tricks.com/debouncing-throttling-explained-examples/#aa-requestanimationframe-raf
            animationFrameId = _window === null || _window === void 0 ? void 0 : _window.requestAnimationFrame(()=>{
                setSize((prevSize)=>{
                    const roundedWidth = Math.floor(containerWidth);
                    const roundedHeight = Math.floor(containerHeight);
                    if (prevSize.containerWidth === roundedWidth && prevSize.containerHeight === roundedHeight) {
                        return prevSize;
                    }
                    return {
                        containerWidth: roundedWidth,
                        containerHeight: roundedHeight
                    };
                });
            });
            (_onResizeRef_current = onResizeRef.current) === null || _onResizeRef_current === void 0 ? void 0 : _onResizeRef_current.call(onResizeRef, containerWidth, containerHeight);
        };
        if (_window && _window.ResizeObserver) {
            resizeObserver = new _window.ResizeObserver(resizeCallback);
            if (containerRef.current) {
                resizeObserver.observe(containerRef.current);
            }
        }
        return ()=>{
            if (animationFrameId) {
                _window === null || _window === void 0 ? void 0 : _window.cancelAnimationFrame(animationFrameId);
            }
            resizeObserver === null || resizeObserver === void 0 ? void 0 : resizeObserver.disconnect();
        };
    }, []);
    const chartContent = React.useMemo(()=>{
        let calculatedWidth = size.containerWidth;
        let calculatedHeight = size.containerHeight;
        if (typeof props.aspect === 'number' && props.aspect > 0) {
            if (calculatedWidth) {
                calculatedHeight = calculatedWidth / props.aspect;
            } else if (calculatedHeight) {
                calculatedWidth = calculatedHeight * props.aspect;
            }
            if (typeof props.maxHeight === 'number' && calculatedHeight && calculatedHeight > props.maxHeight) {
                calculatedHeight = props.maxHeight;
            }
        }
        return React.Children.map(props.children, (child)=>{
            var _child_props_styles, _child_props_styles1, _child_props_styles2;
            return /*#__PURE__*/ React.cloneElement(child, {
                width: calculatedWidth,
                height: calculatedHeight,
                // For SankeyChart
                shouldResize: (calculatedWidth !== null && calculatedWidth !== void 0 ? calculatedWidth : 0) + (calculatedHeight !== null && calculatedHeight !== void 0 ? calculatedHeight : 0),
                styles: {
                    root: mergeClasses((_child_props_styles = child.props.styles) === null || _child_props_styles === void 0 ? void 0 : _child_props_styles.root, childClasses.root),
                    chartWrapper: mergeClasses((_child_props_styles1 = child.props.styles) === null || _child_props_styles1 === void 0 ? void 0 : _child_props_styles1.chartWrapper, childClasses.chartWrapper),
                    chart: mergeClasses((_child_props_styles2 = child.props.styles) === null || _child_props_styles2 === void 0 ? void 0 : _child_props_styles2.chart, childClasses.chart)
                }
            });
        });
    }, [
        size,
        props.aspect,
        props.maxHeight,
        props.children
    ]);
    var _props_width, _props_height;
    return /*#__PURE__*/ React.createElement("div", {
        ref: containerRef,
        style: {
            width: (_props_width = props.width) !== null && _props_width !== void 0 ? _props_width : '100%',
            height: (_props_height = props.height) !== null && _props_height !== void 0 ? _props_height : '100%',
            minWidth: props.minWidth,
            minHeight: props.minHeight,
            maxHeight: props.maxHeight
        }
    }, chartContent);
};
ResponsiveContainer.displayName = 'ResponsiveContainer';
