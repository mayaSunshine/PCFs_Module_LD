{"version":3,"sources":["../src/components/FunnelChart/funnelGeometry.ts"],"sourcesContent":["import * as React from 'react';\nimport { FunnelChartDataPoint } from './FunnelChart.types';\n\nexport interface FunnelSegmentGeometry {\n  pathD: string;\n  textX: number;\n  textY: number;\n  availableWidth: number;\n}\n\nexport interface StackedFunnelSegmentGeometry {\n  pathD: string;\n  textX: number;\n  textY: number;\n  availableWidth: number;\n}\n\ninterface SubValue {\n  category: string;\n  value: number;\n  color: string;\n}\n\ninterface Stage {\n  subValues: SubValue[];\n}\n\nexport function getVerticalFunnelSegmentGeometry({\n  d,\n  i,\n  data,\n  funnelWidth,\n  funnelHeight,\n  isRTL,\n}: {\n  d: FunnelChartDataPoint;\n  i: number;\n  data: FunnelChartDataPoint[];\n  funnelWidth: number;\n  funnelHeight: number;\n  isRTL: boolean;\n}): FunnelSegmentGeometry {\n  const segmentHeight = funnelHeight / data.length;\n  const widthScale = (value: number) => (value / Math.max(...data.map(dataPoint => dataPoint.value!))) * funnelWidth;\n  const topWidth = widthScale(d.value!);\n  const bottomWidth = i < data.length - 1 ? widthScale(data[i + 1].value!) : 0;\n  const xOffset = (funnelWidth - topWidth) / 2;\n  const nextXOffset = (funnelWidth - bottomWidth) / 2;\n  const xStart = isRTL ? funnelWidth - xOffset : xOffset;\n  const xEnd = isRTL ? funnelWidth - nextXOffset : nextXOffset;\n\n  const isLastSegment = i === data.length - 1;\n  const textY = isLastSegment ? i * segmentHeight + segmentHeight * 0.33 : i * segmentHeight + segmentHeight / 2;\n\n  const textX = funnelWidth / 2;\n  let availableWidth = topWidth;\n  if (isLastSegment) {\n    const yFromTop = textY - i * segmentHeight;\n    const widthAtY = topWidth * (1 - yFromTop / segmentHeight);\n    availableWidth = Math.max(widthAtY * 0.8, 0);\n  } else {\n    availableWidth = Math.min(topWidth, bottomWidth) * 0.9;\n  }\n  const pathD = `M${xStart},${i * segmentHeight}\n    L${funnelWidth - xStart},${i * segmentHeight}\n    L${funnelWidth - xEnd},${(i + 1) * segmentHeight}\n    L${xEnd},${(i + 1) * segmentHeight}\n    Z`;\n  return { pathD, textX, textY, availableWidth };\n}\n\nexport function getHorizontalFunnelSegmentGeometry({\n  d,\n  i,\n  data,\n  funnelWidth,\n  funnelHeight,\n  isRTL,\n}: {\n  d: FunnelChartDataPoint;\n  i: number;\n  data: FunnelChartDataPoint[];\n  funnelWidth: number;\n  funnelHeight: number;\n  isRTL: boolean;\n}): FunnelSegmentGeometry {\n  const segmentWidth = funnelWidth / data.length;\n  const heightScale = (value: number) => (value / Math.max(...data.map(dataPoint => dataPoint.value!))) * funnelHeight;\n  const leftHeight = heightScale(d.value!);\n  const rightHeight = i < data.length - 1 ? heightScale(data[i + 1].value!) : 0;\n  const yOffset = (funnelHeight - leftHeight) / 2;\n  const nextYOffset = (funnelHeight - rightHeight) / 2;\n  const x0 = i * segmentWidth;\n  const x1 = (i + 1) * segmentWidth;\n\n  const isLastSegment = i === data.length - 1;\n  let textX: number;\n  let textY: number;\n  let availableWidth = segmentWidth * 0.8;\n\n  if (isLastSegment) {\n    // For the triangular last segment, position text at 1/4 from the left edge\n    textX = x0 + (x1 - x0) * 0.25;\n    textY = funnelHeight / 2;\n\n    // For triangular segments, we need to check both height and width constraints\n    // The segment needs to be large enough to contain text\n    const segmentArea = (leftHeight * segmentWidth) / 2; // Area of triangle\n    const minAreaForText = 800; // Minimum area needed to show text\n\n    if (leftHeight < 40 || segmentArea < minAreaForText) {\n      // Hide text if height is too small or area is insufficient\n      availableWidth = 0;\n    } else {\n      // Calculate available width at text position\n      const widthAtTextPosition = (x1 - x0) * 0.75;\n      availableWidth = widthAtTextPosition * 0.6;\n    }\n  } else {\n    textX = (x0 + x1) / 2;\n    textY = funnelHeight / 2;\n    const minHeight = Math.min(leftHeight, rightHeight);\n    availableWidth = minHeight > 20 ? segmentWidth * 0.8 : 0;\n  }\n\n  const pathD = `M${x0},${yOffset}\n    L${x1},${nextYOffset}\n    L${x1},${funnelHeight - nextYOffset}\n    L${x0},${funnelHeight - yOffset}\n    Z`;\n  return { pathD, textX, textY, availableWidth };\n}\n\nexport function getStackedVerticalFunnelSegmentGeometry({\n  i,\n  k,\n  stages,\n  totals,\n  maxTotal,\n  funnelWidth,\n  funnelHeight,\n}: {\n  i: number;\n  k: number;\n  stages: Stage[];\n  totals: number[];\n  maxTotal: number;\n  funnelWidth: number;\n  funnelHeight: number;\n}): StackedFunnelSegmentGeometry {\n  const segmentHeight = funnelHeight / stages.length;\n  const cur = stages[i];\n  const next = stages[i + 1] || { subValues: [] };\n  const curTotal = totals[i] || 1;\n  const nextTotal = totals[i + 1] || 0;\n\n  let cumTop = 0;\n  let cumBot = 0;\n  for (let idx = 0; idx < k; idx++) {\n    const v = cur.subValues[idx];\n    const vNext = next.subValues?.find((x: SubValue) => x.category === v.category);\n    const val = v.value;\n    const nextVal = vNext ? vNext.value : 0;\n    cumTop += (val / curTotal) * (curTotal / maxTotal) * funnelWidth;\n    cumBot += (nextVal / nextTotal || 0) * (nextTotal / maxTotal) * funnelWidth;\n  }\n  const v = cur.subValues[k];\n  const vNext = next.subValues?.find((x: SubValue) => x.category === v.category);\n  const val = v.value;\n  const nextVal = vNext ? vNext.value : 0;\n  const topW = (val / curTotal) * (curTotal / maxTotal) * funnelWidth;\n  const botW = (nextVal / nextTotal || 0) * (nextTotal / maxTotal) * funnelWidth;\n  const topStart = (funnelWidth - (curTotal / maxTotal) * funnelWidth) / 2 + cumTop;\n  const topEnd = topStart + topW;\n  const botStart = (funnelWidth - (nextTotal / maxTotal) * funnelWidth) / 2 + cumBot;\n  const botEnd = botStart + botW;\n  const textX = (topStart + topEnd + botStart + botEnd) / 4;\n\n  const isLastSegment = i === stages.length - 1;\n  const textY = isLastSegment ? i * segmentHeight + segmentHeight * 0.33 : (i + 0.5) * segmentHeight;\n\n  // Calculate available width based on this specific segment's width\n  let availableWidth: number;\n  if (isLastSegment) {\n    // For triangular last segment, use the width at text Y position\n    const yFromTop = textY - i * segmentHeight;\n    const widthRatio = 1 - yFromTop / segmentHeight;\n    availableWidth = topW * widthRatio;\n  } else {\n    // For trapezoidal segments, use the actual segment width\n    availableWidth = Math.min(topW, botW);\n  }\n\n  const pathD = `M${topStart},${i * segmentHeight}\n    L${topEnd},${i * segmentHeight}\n    L${botEnd},${(i + 1) * segmentHeight}\n    L${botStart},${(i + 1) * segmentHeight}\n    Z`;\n  return { pathD, textX, textY, availableWidth };\n}\n\nexport function getStackedHorizontalFunnelSegmentGeometry({\n  i,\n  k,\n  stages,\n  totals,\n  maxTotal,\n  funnelWidth,\n  funnelHeight,\n}: {\n  i: number;\n  k: number;\n  stages: Stage[];\n  totals: number[];\n  maxTotal: number;\n  funnelWidth: number;\n  funnelHeight: number;\n}): StackedFunnelSegmentGeometry {\n  const segmentWidth = funnelWidth / stages.length;\n  const cur = stages[i];\n  const next = stages[i + 1] || { subValues: [] };\n  const curTotal = totals[i] || 1;\n  const nextTotal = totals[i + 1] || 0;\n\n  let cumTop = 0;\n  let cumBot = 0;\n  for (let idx = 0; idx < k; idx++) {\n    const v = cur.subValues[idx];\n    const vNext = next.subValues?.find((x: SubValue) => x.category === v.category);\n    const val = v.value;\n    const nextVal = vNext ? vNext.value : 0;\n    cumTop += (val / curTotal) * (curTotal / maxTotal) * funnelHeight;\n    cumBot += (nextVal / nextTotal || 0) * (nextTotal / maxTotal) * funnelHeight;\n  }\n  const v = cur.subValues[k];\n  const vNext = next.subValues?.find((x: SubValue) => x.category === v.category);\n  const val = v.value;\n  const nextVal = vNext ? vNext.value : 0;\n  const topH = (val / curTotal) * (curTotal / maxTotal) * funnelHeight;\n  const botH = (nextVal / nextTotal || 0) * (nextTotal / maxTotal) * funnelHeight;\n  const leftStart = i * segmentWidth;\n  const leftEnd = (i + 1) * segmentWidth;\n  const topStart = (funnelHeight - (curTotal / maxTotal) * funnelHeight) / 2 + cumTop;\n  const topEnd = topStart + topH;\n  const botStart = (funnelHeight - (nextTotal / maxTotal) * funnelHeight) / 2 + cumBot;\n  const botEnd = botStart + botH;\n\n  const isLastSegment = i === stages.length - 1;\n  let textX: number;\n  let textY: number;\n  let availableWidth: number;\n\n  if (isLastSegment) {\n    textX = leftStart + (leftEnd - leftStart) * 0.25;\n    textY = (topStart + topEnd) / 2;\n    // For triangular segments, calculate available width at text position\n    const segmentWidthAtTextPos = (leftEnd - leftStart) * 0.5;\n    availableWidth = segmentWidthAtTextPos * 0.8;\n\n    // For triangular last segments, also check if there's enough height\n    // The segment area should be large enough to contain text\n    const segmentArea = (topH * segmentWidth) / 2;\n    if (topH < 24 || segmentArea < 600) {\n      availableWidth = 0;\n    }\n  } else {\n    textX = (leftStart + leftEnd) / 2;\n    textY = (topStart + topEnd + botStart + botEnd) / 4;\n    // For trapezoidal segments, use full segment width\n    availableWidth = Math.abs(leftEnd - leftStart) * 0.9;\n\n    // Check if the segment has sufficient height for text\n    // For non-last segments, we need to ensure there's enough vertical space\n    const avgHeight = (topH + botH) / 2;\n    if (avgHeight < 20) {\n      availableWidth = 0;\n    }\n  }\n\n  const pathD = `M${leftStart},${topStart}\n    L${leftEnd},${botStart}\n    L${leftEnd},${botEnd}\n    L${leftStart},${topEnd}\n    Z`;\n  return { pathD, textX, textY, availableWidth };\n}\n\nexport function getSegmentTextProps({\n  availableWidth,\n  minTextWidth = 24,\n  textX,\n  textY,\n  value,\n  culture,\n  onMouseOver,\n  onMouseMove,\n  onMouseOut,\n}: {\n  availableWidth: number;\n  minTextWidth?: number;\n  textX: number;\n  textY: number;\n  value: number;\n  culture: string | undefined;\n  onMouseOver: ((event: React.MouseEvent<SVGElement>) => void) | undefined;\n  onMouseMove: ((event: React.MouseEvent<SVGElement>) => void) | undefined;\n  onMouseOut: (() => void) | undefined;\n}): {\n  show: boolean;\n  x: number;\n  y: number;\n  value: number;\n  culture: string | undefined;\n  onMouseOver: ((event: React.MouseEvent<SVGElement>) => void) | undefined;\n  onMouseMove: ((event: React.MouseEvent<SVGElement>) => void) | undefined;\n  onMouseOut: (() => void) | undefined;\n} {\n  return {\n    show: availableWidth > minTextWidth && availableWidth > 0,\n    x: textX,\n    y: textY,\n    value,\n    culture,\n    onMouseOver,\n    onMouseMove,\n    onMouseOut,\n  };\n}\n"],"names":["React","getVerticalFunnelSegmentGeometry","d","i","data","funnelWidth","funnelHeight","isRTL","segmentHeight","length","widthScale","value","Math","max","map","dataPoint","topWidth","bottomWidth","xOffset","nextXOffset","xStart","xEnd","isLastSegment","textY","textX","availableWidth","yFromTop","widthAtY","min","pathD","getHorizontalFunnelSegmentGeometry","segmentWidth","heightScale","leftHeight","rightHeight","yOffset","nextYOffset","x0","x1","segmentArea","minAreaForText","widthAtTextPosition","minHeight","getStackedVerticalFunnelSegmentGeometry","k","stages","totals","maxTotal","next","cur","subValues","curTotal","nextTotal","cumTop","cumBot","idx","v","vNext","find","x","category","val","nextVal","topW","botW","topStart","topEnd","botStart","botEnd","widthRatio","getStackedHorizontalFunnelSegmentGeometry","topH","botH","leftStart","leftEnd","segmentWidthAtTextPos","abs","avgHeight","getSegmentTextProps","minTextWidth","culture","onMouseOver","onMouseMove","onMouseOut","show","y"],"mappings":"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"}