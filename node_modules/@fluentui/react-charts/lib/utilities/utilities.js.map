{"version":3,"sources":["../src/utilities/utilities.ts"],"sourcesContent":["'use client';\n\nimport { axisRight as d3AxisRight, axisBottom as d3AxisBottom, axisLeft as d3AxisLeft, Axis as D3Axis } from 'd3-axis';\nimport {\n  max as d3Max,\n  min as d3Min,\n  ticks as d3Ticks,\n  nice as d3nice,\n  sum as d3Sum,\n  mean as d3Mean,\n  median as d3Median,\n} from 'd3-array';\nimport {\n  scaleLinear as d3ScaleLinear,\n  scaleBand as d3ScaleBand,\n  scaleUtc as d3ScaleUtc,\n  scaleTime as d3ScaleTime,\n  scaleLog as d3ScaleLog,\n  NumberValue,\n  type ScaleContinuousNumeric,\n  type ScaleLinear,\n  type ScaleBand,\n  type ScaleTime,\n} from 'd3-scale';\nimport { select as d3Select, selectAll as d3SelectAll } from 'd3-selection';\nimport { format as d3Format } from 'd3-format';\nimport type { JSXElement } from '@fluentui/react-utilities';\nimport {\n  TimeLocaleObject as d3TimeLocaleObject,\n  timeFormat as d3TimeFormat,\n  timeFormatLocale as d3TimeFormatLocale,\n  TimeLocaleDefinition as d3TimeLocaleDefinition,\n  utcFormat as d3UtcFormat,\n} from 'd3-time-format';\nimport {\n  timeSecond as d3TimeSecond,\n  timeMinute as d3TimeMinute,\n  timeHour as d3TimeHour,\n  timeDay as d3TimeDay,\n  timeMonth as d3TimeMonth,\n  timeWeek as d3TimeWeek,\n  timeYear as d3TimeYear,\n  utcSecond as d3UtcSecond,\n  utcMinute as d3UtcMinute,\n  utcHour as d3UtcHour,\n  utcDay as d3UtcDay,\n  utcMonth as d3UtcMonth,\n  utcWeek as d3UtcWeek,\n  utcYear as d3UtcYear,\n} from 'd3-time';\nimport {\n  CurveFactory,\n  curveLinear as d3CurveLinear,\n  curveNatural as d3CurveNatural,\n  curveStep as d3CurveStep,\n  curveStepAfter as d3CurveStepAfter,\n  curveStepBefore as d3CurveStepBefore,\n} from 'd3-shape';\nimport { AxisProps, AxisScaleType, ScatterChartPoints } from '../types/DataPoint';\nimport {\n  AccessibilityProps,\n  EventsAnnotationProps,\n  LineChartPoints,\n  LineChartDataPoint,\n  ScatterChartDataPoint,\n  GanttChartDataPoint,\n  DataPoint,\n  VerticalStackedBarDataPoint,\n  VerticalBarChartDataPoint,\n  HorizontalBarChartWithAxisDataPoint,\n  LineChartLineOptions,\n  AxisCategoryOrder,\n  YValueHover,\n} from '../index';\nimport { formatPrefix as d3FormatPrefix } from 'd3-format';\nimport { useFluent_unstable as useFluent } from '@fluentui/react-shared-contexts';\nimport {\n  formatDateToLocaleString,\n  formatToLocaleString,\n  getMultiLevelDateTimeFormatOptions,\n  isInvalidValue,\n  isNumber,\n} from '@fluentui/chart-utilities';\n\nexport const MIN_DOMAIN_MARGIN = 8;\nexport const MIN_DONUT_RADIUS = 1;\nexport const DEFAULT_DATE_STRING = '2000-01-01';\n\nexport type NumericAxis = D3Axis<number | { valueOf(): number }>;\nexport type StringAxis = D3Axis<string>;\n\nexport enum ChartTypes {\n  AreaChart,\n  LineChart,\n  VerticalBarChart,\n  VerticalStackedBarChart,\n  GroupedVerticalBarChart,\n  HeatMapChart,\n  HorizontalBarChartWithAxis,\n  ScatterChart,\n  GanttChart,\n}\n\nexport enum XAxisTypes {\n  NumericAxis,\n  DateAxis,\n  StringAxis,\n}\n\nexport enum YAxisType {\n  NumericAxis,\n  DateAxis,\n  StringAxis,\n}\n\nexport interface IWrapLabelProps {\n  node: SVGSVGElement | null;\n  xAxis: NumericAxis | StringAxis;\n  noOfCharsToTruncate: number;\n  showXAxisLablesTooltip: boolean;\n  width?: number;\n}\n\nexport interface IRotateLabelProps {\n  node: SVGSVGElement | null;\n  xAxis: NumericAxis | StringAxis;\n}\n\nexport interface IAxisData {\n  yAxisDomainValues: number[];\n}\n\nexport interface IMargins {\n  /**\n   * left margin for the chart.\n   * @default 40\n   */\n  left?: number;\n  /**\n   * Right margin for the chart.\n   * @default 20\n   */\n  right?: number;\n  /**\n   * Top margin for the chart.\n   * @default 20\n   */\n  top?: number;\n  /**\n   * Bottom margin for the chart.\n   * @default 35\n   */\n  bottom?: number;\n}\n\nexport interface IDomainNRange {\n  dStartValue: number | Date;\n  dEndValue: number | Date;\n  rStartValue: number;\n  rEndValue: number;\n}\n\nexport interface IXAxisParams extends AxisProps {\n  domainNRangeValues: IDomainNRange;\n  xAxisElement?: SVGSVGElement | null;\n  xAxisCount?: number;\n  showRoundOffXTickValues?: boolean;\n  xAxistickSize?: number;\n  tickPadding?: number;\n  xAxisPadding?: number;\n  xAxisInnerPadding?: number;\n  xAxisOuterPadding?: number;\n  margins: IMargins;\n  containerHeight: number;\n  containerWidth: number;\n  hideTickOverlap?: boolean;\n  calcMaxLabelWidth: (x: (string | number)[]) => number;\n}\nexport interface ITickParams {\n  tickValues?: Date[] | number[] | string[];\n  tickFormat?: string;\n}\n\nexport interface IYAxisParams extends AxisProps {\n  yMinMaxValues?: {\n    startValue: number;\n    endValue: number;\n  };\n  maxOfYVal?: number;\n  margins: IMargins;\n  containerWidth: number;\n  containerHeight: number;\n  yAxisElement?: SVGSVGElement | null;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  yAxisTickFormat?: any;\n  yAxisTickCount: number;\n  yMaxValue?: number;\n  yMinValue?: number;\n  tickPadding?: number;\n  eventAnnotationProps?: EventsAnnotationProps;\n  eventLabelHeight?: number;\n  yAxisPadding?: number;\n  tickValues?: Date[] | number[] | string[];\n}\n\nfunction yAxisTickFormatterInternal(value: number, limitWidth: boolean = false): string {\n  // Use SI format prefix with 2 decimal places without insignificant trailing zeros\n  let formatter = d3FormatPrefix('.2~', value);\n\n  if (Math.abs(value) < 1) {\n    // Don't use SI notation for small numbers as it is less readable\n    formatter = d3Format('.2~g');\n  } else if (limitWidth && Math.abs(value) >= 1000) {\n    // If width is limited, use SI format prefix with 1 point precision\n    formatter = d3FormatPrefix('.1~', value);\n  }\n  const formattedValue = formatter(value);\n\n  // Replace 'G' with 'B' if the value is greater than 10^9 as it is a more common convention\n  if (Math.abs(value) >= 1e9) {\n    return formattedValue.replace('G', 'B');\n  }\n\n  return formattedValue;\n}\n\n/**\n * Formatter for y axis ticks.\n * @param value - The number to format.\n * @returns The formatted string .\n */\nexport function defaultYAxisTickFormatter(value: number): string {\n  return yAxisTickFormatterInternal(value);\n}\n\n/**\n * Create Numeric X axis\n * @export\n * @param {IXAxisParams} xAxisParams\n */\nexport function createNumericXAxis(\n  xAxisParams: IXAxisParams,\n  tickParams: ITickParams,\n  chartType: ChartTypes,\n  culture?: string,\n  scaleType?: AxisScaleType,\n  _useRtl?: boolean,\n): {\n  xScale: ScaleLinear<number, number>;\n  tickValues: string[];\n} {\n  const {\n    domainNRangeValues,\n    showRoundOffXTickValues = false,\n    xAxistickSize = 6,\n    tickPadding = 10,\n    xAxisCount,\n    xAxisElement,\n    hideTickOverlap,\n    calcMaxLabelWidth,\n    tickStep,\n    tick0,\n  } = xAxisParams;\n  const xAxisScale = createNumericScale(scaleType)\n    .domain([domainNRangeValues.dStartValue, domainNRangeValues.dEndValue])\n    .range([domainNRangeValues.rStartValue, domainNRangeValues.rEndValue]);\n  showRoundOffXTickValues && xAxisScale.nice();\n\n  let tickCount = xAxisCount ?? 6;\n  const tickFormat = (domainValue: NumberValue, _index: number, defaultFormat?: (val: NumberValue) => string) => {\n    if (tickParams.tickFormat) {\n      return d3Format(tickParams.tickFormat)(domainValue);\n    }\n    const xAxisValue = typeof domainValue === 'number' ? domainValue : domainValue.valueOf();\n    return defaultFormat?.(xAxisValue) === '' ? '' : (formatToLocaleString(xAxisValue, culture) as string);\n  };\n  if (hideTickOverlap && typeof xAxisCount === 'undefined') {\n    const longestLabelWidth =\n      calcMaxLabelWidth(xAxisScale.ticks().map((v: NumberValue, i: number) => tickFormat(v, i))) + 20;\n    const [start, end] = xAxisScale.range();\n    tickCount = Math.min(Math.max(1, Math.floor(Math.abs(end - start) / longestLabelWidth)), 10);\n  }\n\n  const xAxis = d3AxisBottom(xAxisScale)\n    .tickSize(xAxistickSize)\n    .tickPadding(tickPadding)\n    .ticks(tickCount)\n    .tickFormat((v, i) => tickFormat(v as NumberValue, i, xAxisScale.tickFormat(tickCount)));\n  if ([ChartTypes.HorizontalBarChartWithAxis, ChartTypes.GanttChart].includes(chartType)) {\n    xAxis.tickSizeInner(-(xAxisParams.containerHeight - xAxisParams.margins.top!));\n  }\n  let customTickValues: number[] | undefined;\n  if (tickParams.tickValues) {\n    customTickValues = tickParams.tickValues as number[];\n  } else if (tickStep) {\n    customTickValues = generateNumericTicks(scaleType, tickStep, tick0, xAxisScale.domain());\n  }\n  if (customTickValues) {\n    xAxis.tickValues(customTickValues);\n  }\n\n  if (xAxisElement) {\n    d3Select(xAxisElement)\n      .call(xAxis)\n      .selectAll('text')\n      .attr('aria-hidden', 'true')\n      .style('direction', 'ltr')\n      .style('unicode-bidi', 'isolate');\n  }\n  const tickValues = (customTickValues ?? xAxisScale.ticks(tickCount)).map(xAxis.tickFormat()!);\n  return { xScale: xAxisScale, tickValues };\n}\n\n/**\n * This function returns a multilevel formatter for a given date range.\n * It determines the appropriate date format to accommodate each tick value.\n * The goal is to represent the date label in the smallest possible format without loss of information.\n * The challenge here is to adhere to locale specific formats while ensuring the complete label is shown.\n * There is an exhaustive map of all possible date/time units and their respective formats.\n * Based on the range of formatting granularity levels, a format spanning the range is returned.\n * @param startLevel - The starting level of the date format.\n * @param endLevel - The ending level of the date format.\n * @param locale - The locale object for formatting.\n * @param useUTC\n * @returns\n */\nfunction getMultiLevelD3DateFormatter(\n  startLevel: number,\n  endLevel: number,\n  locale?: d3TimeLocaleObject,\n  useUTC?: boolean,\n) {\n  const timeFormat = locale ? (useUTC ? locale.utcFormat : locale.format) : useUTC ? d3UtcFormat : d3TimeFormat;\n\n  // Refer to https://d3js.org/d3-time-format#locale_format to see explanation about each format specifier\n  const DEFAULT = '%c';\n  const MS = '.%L';\n  const MS_S = ':%S.%L';\n  const MS_S_MIN = '%M:%S.%L';\n  const MS_S_MIN_H = '%-I:%M:%S.%L %p';\n  const MS_S_MIN_H_D = '%a %d, %X';\n  const MS_S_MIN_H_D_W = '%b %d, %X';\n  const MS_S_MIN_H_D_W_M = MS_S_MIN_H_D_W;\n  const MS_S_MIN_H_D_W_M_Y = DEFAULT;\n  const S = ':%S';\n  const S_MIN = '%-I:%M:%S';\n  const S_MIN_H = '%X';\n  const S_MIN_H_D = MS_S_MIN_H_D;\n  const S_MIN_H_D_W = MS_S_MIN_H_D_W;\n  const S_MIN_H_D_W_M = MS_S_MIN_H_D_W_M;\n  const S_MIN_H_D_W_M_Y = DEFAULT;\n  const MIN = '%-I:%M %p';\n  const MIN_H = MIN;\n  const MIN_H_D = '%a %d, %-I:%M %p';\n  const MIN_H_D_W = '%b %d, %-I:%M %p';\n  const MIN_H_D_W_M = MIN_H_D_W;\n  const MIN_H_D_W_M_Y = '%x, %-I:%M %p';\n  const H = '%-I %p';\n  const H_D = '%a %d, %-I %p';\n  const H_D_W = '%b %d, %-I %p';\n  const H_D_W_M = H_D_W;\n  const H_D_W_M_Y = '%x, %-I %p';\n  const D = '%a %d';\n  const D_W = '%b %d';\n  const D_W_M = D_W;\n  const D_W_M_Y = '%x';\n  const W = D_W;\n  const W_M = W;\n  const W_M_Y = D_W_M_Y;\n  const M = '%B';\n  const M_Y = '%b %Y';\n  const Y = '%Y';\n\n  const MULTI_LEVEL_DATE_TIME_FORMATS = [\n    // ms, s, min, h, d, w, m, y\n    [MS, MS_S, MS_S_MIN, MS_S_MIN_H, MS_S_MIN_H_D, MS_S_MIN_H_D_W, MS_S_MIN_H_D_W_M, MS_S_MIN_H_D_W_M_Y], // ms\n    [DEFAULT, S, S_MIN, S_MIN_H, S_MIN_H_D, S_MIN_H_D_W, S_MIN_H_D_W_M, S_MIN_H_D_W_M_Y], // s\n    [DEFAULT, DEFAULT, MIN, MIN_H, MIN_H_D, MIN_H_D_W, MIN_H_D_W_M, MIN_H_D_W_M_Y], // min\n    [DEFAULT, DEFAULT, DEFAULT, H, H_D, H_D_W, H_D_W_M, H_D_W_M_Y], // h\n    [DEFAULT, DEFAULT, DEFAULT, DEFAULT, D, D_W, D_W_M, D_W_M_Y], // d\n    [DEFAULT, DEFAULT, DEFAULT, DEFAULT, DEFAULT, W, W_M, W_M_Y], // w\n    [DEFAULT, DEFAULT, DEFAULT, DEFAULT, DEFAULT, DEFAULT, M, M_Y], // m\n    [DEFAULT, DEFAULT, DEFAULT, DEFAULT, DEFAULT, DEFAULT, DEFAULT, Y], // y\n  ];\n\n  const formatter = timeFormat(MULTI_LEVEL_DATE_TIME_FORMATS[startLevel][endLevel]);\n  return formatter;\n}\n\nexport function getDateFormatLevel(date: Date, useUTC?: boolean): number {\n  const timeSecond = useUTC ? d3UtcSecond : d3TimeSecond;\n  const timeMinute = useUTC ? d3UtcMinute : d3TimeMinute;\n  const timeHour = useUTC ? d3UtcHour : d3TimeHour;\n  const timeDay = useUTC ? d3UtcDay : d3TimeDay;\n  const timeMonth = useUTC ? d3UtcMonth : d3TimeMonth;\n  const timeWeek = useUTC ? d3UtcWeek : d3TimeWeek;\n  const timeYear = useUTC ? d3UtcYear : d3TimeYear;\n\n  const formats = [\n    { formatLevel: 0, condition: (d: Date) => timeSecond(d) < d }, // Milliseconds\n    { formatLevel: 1, condition: (d: Date) => timeMinute(d) < d }, // Seconds\n    { formatLevel: 2, condition: (d: Date) => timeHour(d) < d }, // Minutes\n    { formatLevel: 3, condition: (d: Date) => timeDay(d) < d }, // Hours\n    { formatLevel: 4, condition: (d: Date) => timeMonth(d) < d && timeWeek(d) < d }, // Days\n    { formatLevel: 5, condition: (d: Date) => timeMonth(d) < d }, // Weeks\n    { formatLevel: 6, condition: (d: Date) => timeYear(d) < d }, // Months\n    { formatLevel: 7, condition: () => true }, // Years (default)\n  ];\n\n  const matchedFormat = formats.find(({ condition }) => condition(date));\n\n  return matchedFormat?.formatLevel ?? 7;\n}\n\n/**\n * Creating Date x axis of the Chart\n * @export\n * @param {IXAxisParams} xAxisParams\n * @param {ITickParams} tickParams\n */\nexport function createDateXAxis(\n  xAxisParams: IXAxisParams,\n  tickParams: ITickParams,\n  culture?: string,\n  options?: Intl.DateTimeFormatOptions,\n  timeFormatLocale?: d3TimeLocaleDefinition,\n  customDateTimeFormatter?: (dateTime: Date) => string,\n  useUTC?: string | boolean,\n  chartType?: ChartTypes,\n): { xScale: ScaleTime<number, number>; tickValues: string[] } {\n  const {\n    domainNRangeValues,\n    xAxisElement,\n    tickPadding = 6,\n    xAxistickSize = 6,\n    xAxisCount,\n    calcMaxLabelWidth,\n    tickStep,\n    tick0,\n  } = xAxisParams;\n  const isUtcSet = useUTC === true || useUTC === 'utc';\n  const xAxisScale = isUtcSet ? d3ScaleUtc() : d3ScaleTime();\n  xAxisScale\n    .domain([domainNRangeValues.dStartValue, domainNRangeValues.dEndValue])\n    .range([domainNRangeValues.rStartValue, domainNRangeValues.rEndValue])\n    .nice();\n\n  let tickCount = xAxisCount ?? 6;\n\n  let lowestFormatLevel = 100;\n  let highestFormatLevel = -1;\n\n  const locale = timeFormatLocale ? d3TimeFormatLocale(timeFormatLocale) : undefined;\n\n  xAxisScale.ticks().forEach((domainValue: Date) => {\n    const formatLevel = getDateFormatLevel(domainValue, isUtcSet);\n\n    if (formatLevel > highestFormatLevel) {\n      highestFormatLevel = formatLevel;\n    }\n    if (formatLevel < lowestFormatLevel) {\n      lowestFormatLevel = formatLevel;\n    }\n  });\n\n  const formatOptions = options ?? getMultiLevelDateTimeFormatOptions(lowestFormatLevel, highestFormatLevel);\n\n  const formatFn: (date: Date) => string = getMultiLevelD3DateFormatter(\n    lowestFormatLevel,\n    highestFormatLevel,\n    locale,\n    isUtcSet,\n  );\n\n  const tickFormat = (domainValue: Date, _index: number) => {\n    if (customDateTimeFormatter) {\n      return customDateTimeFormatter(domainValue);\n    }\n    if (timeFormatLocale) {\n      return formatFn(domainValue);\n    }\n    if (culture === undefined && tickParams.tickFormat) {\n      if (useUTC) {\n        return d3UtcFormat(tickParams.tickFormat)(domainValue);\n      } else {\n        return d3TimeFormat(tickParams.tickFormat)(domainValue);\n      }\n    }\n\n    return formatDateToLocaleString(domainValue, culture, useUTC ? true : false, false, formatOptions);\n  };\n\n  const longestLabelWidth = calcMaxLabelWidth(xAxisScale.ticks().map(tickFormat)) + 40;\n  const [start, end] = xAxisScale.range();\n  const maxPossibleTickCount = Math.min(Math.max(1, Math.floor(Math.abs(end - start) / longestLabelWidth)), 10);\n  tickCount = Math.min(maxPossibleTickCount, xAxisCount ?? tickCount);\n\n  const xAxis = d3AxisBottom(xAxisScale)\n    .tickSize(xAxistickSize)\n    .tickPadding(tickPadding)\n    .ticks(tickCount)\n    .tickFormat(tickFormat);\n  if ([ChartTypes.GanttChart].includes(chartType!)) {\n    xAxis.tickSizeInner(-(xAxisParams.containerHeight - xAxisParams.margins.top!));\n  }\n\n  let customTickValues: Date[] | undefined;\n  if (tickParams.tickValues) {\n    customTickValues = tickParams.tickValues as Date[];\n  } else if (tickStep) {\n    customTickValues = generateDateTicks(tickStep, tick0, xAxisScale.domain(), useUTC as boolean);\n  }\n  if (customTickValues) {\n    xAxis.tickValues(customTickValues);\n  }\n  if (xAxisElement) {\n    d3Select(xAxisElement).call(xAxis).selectAll('text').attr('aria-hidden', 'true');\n  }\n  const tickValues = (customTickValues ?? xAxisScale.ticks(tickCount)).map(xAxis.tickFormat()!);\n  return { xScale: xAxisScale, tickValues };\n}\n\n/**\n * Create String X axis\n * Currently using for only Vetical stacked bar chart and grouped vertical bar chart\n * @export\n * @param {IXAxisParams} xAxisParams\n * @param {ITickParams} tickParams\n * @param {string[]} dataset\n * @returns\n */\nexport function createStringXAxis(\n  xAxisParams: IXAxisParams,\n  tickParams: ITickParams,\n  dataset: string[],\n  culture?: string,\n  _useRtl?: boolean,\n): {\n  xScale: ScaleBand<string>;\n  tickValues: string[];\n} {\n  const {\n    domainNRangeValues,\n    xAxistickSize = 6,\n    tickPadding = 10,\n    xAxisPadding = 0.1,\n    xAxisInnerPadding,\n    xAxisOuterPadding,\n    containerWidth,\n    hideTickOverlap,\n    calcMaxLabelWidth,\n  } = xAxisParams;\n  const xAxisScale = d3ScaleBand()\n    .domain(dataset!)\n    .range([domainNRangeValues.rStartValue, domainNRangeValues.rEndValue])\n    .paddingInner(typeof xAxisInnerPadding !== 'undefined' ? xAxisInnerPadding : xAxisPadding)\n    .paddingOuter(typeof xAxisOuterPadding !== 'undefined' ? xAxisOuterPadding : xAxisPadding);\n\n  let tickValues = (tickParams.tickValues as string[] | undefined) ?? dataset;\n  const tickFormat = (domainValue: string, _index: number) => {\n    return formatToLocaleString(domainValue, culture) as string;\n  };\n  if (hideTickOverlap) {\n    let nonOverlappingTickValues = [];\n    const tickSizes = tickValues.map(value => calcMaxLabelWidth([value]));\n    // for LTR\n    let start = 0;\n    let end = containerWidth;\n    let sign = 1;\n    const range = xAxisScale.range();\n    if (range[1] - range[0] < 0) {\n      // for RTL\n      start = containerWidth;\n      end = 0;\n      sign = -1;\n    }\n    for (let i = tickValues.length - 1; i >= 0; i--) {\n      const tickPosition = xAxisScale(tickValues[i])!;\n      if (\n        sign * (tickPosition - (sign * tickSizes[i]) / 2 - start) >= 0 &&\n        sign * (tickPosition + (sign * tickSizes[i]) / 2 - end) <= 0\n      ) {\n        nonOverlappingTickValues.push(tickValues[i]);\n        end = tickPosition - sign * (tickSizes[i] / 2 + 10);\n      }\n    }\n    nonOverlappingTickValues = nonOverlappingTickValues.reverse();\n    tickValues = nonOverlappingTickValues;\n  }\n\n  const xAxis = d3AxisBottom(xAxisScale)\n    .tickSize(xAxistickSize)\n    .tickPadding(tickPadding)\n    .tickValues(tickValues)\n    .tickFormat(tickFormat);\n\n  if (xAxisParams.xAxisElement) {\n    d3Select(xAxisParams.xAxisElement)\n      .call(xAxis)\n      .selectAll('text')\n      .attr('aria-hidden', 'true')\n      .style('direction', 'ltr')\n      .style('unicode-bidi', 'isolate');\n  }\n  return { xScale: xAxisScale, tickValues: tickValues.map(xAxis.tickFormat()!) };\n}\n\nexport function useRtl(): boolean {\n  const { dir } = useFluent(); // \"dir\" returns \"ltr\" or \"rtl\"\n  return dir === 'rtl';\n}\n\nfunction isPowerOf10(num: number): boolean {\n  const roundedfinalYMax = handleFloatingPointPrecisionError(num);\n  return Math.log10(roundedfinalYMax) % 1 === 0;\n}\n\n//for reference, go through this 'https://docs.python.org/release/2.5.1/tut/node16.html'\nfunction handleFloatingPointPrecisionError(num: number): number {\n  const rounded = Math.round(num);\n  return Math.abs(num - rounded) < 1e-6 ? rounded : num;\n}\n\n/**\n * This method is used to calculate the rounded tick values for the y-axis\n * @param {number} minVal\n * @param {number} maxVal\n * @param {number} splitInto\n * @returns {number[]}\n */\nfunction calculateRoundedTicks(minVal: number, maxVal: number, splitInto: number) {\n  const finalYmin = minVal >= 0 && minVal === maxVal ? 0 : minVal;\n  const finalYmax = minVal < 0 && minVal === maxVal ? 0 : maxVal;\n  const ticksInterval = d3nice(finalYmin, finalYmax, splitInto);\n  const ticks = d3Ticks(ticksInterval[0], ticksInterval[ticksInterval.length - 1], splitInto);\n  if (ticks[ticks.length - 1] > finalYmax && isPowerOf10(finalYmax)) {\n    ticks.pop();\n  }\n  return ticks;\n}\n\n/**\n * This method used for creating data points for the y axis.\n * @export\n * @param {number} maxVal\n * @param {number} minVal\n * @param {number} splitInto\n * @param {boolean} isIntegralDataset\n * @returns {number[]}\n */\nexport function prepareDatapoints(\n  maxVal: number,\n  minVal: number,\n  splitInto: number,\n  isIntegralDataset: boolean,\n  roundedTicks?: boolean,\n): number[] {\n  if (roundedTicks) {\n    return calculateRoundedTicks(minVal, maxVal, splitInto);\n  }\n  const val = isIntegralDataset\n    ? Math.ceil((maxVal - minVal) / splitInto)\n    : (maxVal - minVal) / splitInto >= 1\n    ? Math.ceil((maxVal - minVal) / splitInto)\n    : (maxVal - minVal) / splitInto;\n  /*\n    For cases where we have negative and positive values\n    The dataPointsArray is filled from 0 to minVal by val difference\n    Then the array is reversed and values from 0(excluding 0) to maxVal are appended\n    This ensures presence of 0 to act as an anchor reference.\n    For simple cases where the scale may not encounter such a need for 0,\n    We simply fill from minVal to maxVal\n  */\n  const dataPointsArray: number[] = [minVal < 0 && maxVal >= 0 ? 0 : minVal];\n  /*For the case of all positive or all negative, we need to add another value\n     in array for atleast one interval, but in case of mix of positive and negative,\n     there will always be one more entry that will be added by the logic we have*/\n  if (dataPointsArray[0] === minVal) {\n    dataPointsArray.push(minVal + val);\n  }\n  if (minVal < 0 && maxVal >= 0) {\n    while (dataPointsArray[dataPointsArray.length - 1] > minVal) {\n      dataPointsArray.push(dataPointsArray[dataPointsArray.length - 1] - val);\n    }\n    dataPointsArray.reverse();\n  }\n  while (dataPointsArray[dataPointsArray.length - 1] < maxVal) {\n    dataPointsArray.push(dataPointsArray[dataPointsArray.length - 1] + val);\n  }\n  return dataPointsArray;\n}\n\nexport function createYAxisForHorizontalBarChartWithAxis(\n  yAxisParams: IYAxisParams,\n  isRtl: boolean,\n): ScaleLinear<number, number> {\n  const {\n    yMinMaxValues = { startValue: 0, endValue: 0 },\n    yAxisElement = null,\n    yMaxValue = 0,\n    yMinValue = 0,\n    containerHeight,\n    margins,\n    tickPadding = 12,\n    maxOfYVal = 0,\n    yAxisTickFormat,\n    yAxisTickCount = 4,\n    tickValues,\n    tickStep,\n    tick0,\n  } = yAxisParams;\n\n  // maxOfYVal coming from horizontal bar chart with axis (Calculation done at base file)\n  const tempVal = maxOfYVal || yMinMaxValues.endValue;\n  const finalYmax = tempVal > yMaxValue ? tempVal : yMaxValue!;\n  const finalYmin = yMinMaxValues.startValue < yMinValue ? Math.min(0, yMinMaxValues.startValue) : yMinValue!;\n  const yAxisScale = d3ScaleLinear()\n    .domain([finalYmin, finalYmax])\n    .range([containerHeight - margins.bottom!, margins.top!]);\n  const axis = isRtl ? d3AxisRight(yAxisScale) : d3AxisLeft(yAxisScale);\n  const yAxis = axis.tickPadding(tickPadding).ticks(yAxisTickCount);\n  yAxisTickFormat ? yAxis.tickFormat(yAxisTickFormat) : yAxis.tickFormat(defaultYAxisTickFormatter);\n\n  let customTickValues: number[] | undefined;\n  if (tickValues) {\n    customTickValues = tickValues as number[];\n  } else if (tickStep) {\n    customTickValues = generateNumericTicks(undefined, tickStep, tick0, yAxisScale.domain());\n  }\n  if (customTickValues) {\n    yAxis.tickValues(customTickValues);\n  }\n\n  yAxisElement ? d3Select(yAxisElement).call(yAxis).selectAll('text').attr('aria-hidden', 'true') : '';\n  return yAxisScale;\n}\n\nexport function createNumericYAxis(\n  yAxisParams: IYAxisParams,\n  isRtl: boolean,\n  axisData: IAxisData,\n  isIntegralDataset: boolean,\n  chartType: ChartTypes,\n  useSecondaryYScale: boolean = false,\n  roundedTicks: boolean = false,\n  scaleType?: AxisScaleType,\n  _useRtl?: boolean,\n): ScaleLinear<number, number> {\n  const {\n    yMinMaxValues = { startValue: 0, endValue: 0 },\n    yAxisElement = null,\n    yMaxValue = 0,\n    yMinValue = 0,\n    containerHeight,\n    containerWidth,\n    margins,\n    tickPadding = 12,\n    maxOfYVal = 0,\n    yAxisTickFormat,\n    yAxisTickCount = 4,\n    eventAnnotationProps,\n    eventLabelHeight,\n    tickValues,\n    tickStep,\n    tick0,\n  } = yAxisParams;\n\n  // maxOfYVal coming from only area chart and Grouped vertical bar chart(Calculation done at base file)\n  const tempVal = maxOfYVal || yMinMaxValues.endValue || 0;\n  const finalYmax = tempVal > yMaxValue ? tempVal : yMaxValue!;\n  const finalYmin = Math.min(yMinMaxValues.startValue || 0, yMinValue || 0);\n  const domainValues = prepareDatapoints(finalYmax, finalYmin, yAxisTickCount, isIntegralDataset, roundedTicks);\n  let yMin = finalYmin;\n  let yMax = domainValues[domainValues.length - 1];\n  if (chartType === ChartTypes.ScatterChart) {\n    const yPadding = (yMax - yMin) * 0.1;\n    yMin = yMin - yPadding;\n    yMax = yMax + yPadding;\n  }\n  let scaleDomain = [domainValues[0], domainValues[domainValues.length - 1]];\n\n  if (scaleType === 'log') {\n    let domainStart = yMinMaxValues.startValue;\n    let domainEnd = yMinMaxValues.endValue;\n    if (yMinValue > 0) {\n      domainStart = Math.min(domainStart, yMinValue);\n    }\n    if (yMaxValue > 0) {\n      domainEnd = Math.max(domainEnd, yMaxValue);\n    }\n    scaleDomain = [domainStart, domainEnd];\n  }\n\n  const yAxisScale = createNumericScale(scaleType)\n    .domain(scaleDomain)\n    .range([containerHeight - margins.bottom!, margins.top! + (eventAnnotationProps! ? eventLabelHeight! : 0)]);\n  const axis =\n    (!isRtl && useSecondaryYScale) || (isRtl && !useSecondaryYScale) ? d3AxisRight(yAxisScale) : d3AxisLeft(yAxisScale);\n  const yAxis = axis.tickPadding(tickPadding).tickSizeInner(-(containerWidth - margins.left! - margins.right!));\n  let customTickValues: number[] | undefined;\n  if (tickValues) {\n    customTickValues = tickValues as number[];\n  } else if (tickStep) {\n    customTickValues = generateNumericTicks(scaleType, tickStep, tick0, yAxisScale.domain());\n  }\n  if (customTickValues) {\n    yAxis.tickValues(customTickValues);\n    axisData.yAxisDomainValues = customTickValues;\n  } else {\n    if (scaleType === 'log') {\n      axisData.yAxisDomainValues = yAxisScale.ticks();\n    } else {\n      yAxis.tickValues(domainValues);\n      axisData.yAxisDomainValues = domainValues;\n    }\n  }\n\n  const tickFormat = (domainValue: NumberValue, index: number, defaultFormat?: (val: NumberValue) => string) => {\n    const value = typeof domainValue === 'number' ? domainValue : domainValue.valueOf();\n    return defaultFormat?.(value) === '' ? '' : defaultYAxisTickFormatter(value);\n  };\n  yAxisTickFormat\n    ? yAxis.tickFormat(yAxisTickFormat)\n    : yAxis.tickFormat((v, i) => tickFormat(v as NumberValue, i, yAxisScale.tickFormat(yAxisTickCount)));\n  yAxisElement\n    ? d3Select(yAxisElement)\n        .call(yAxis)\n        .selectAll('text')\n        .attr('aria-hidden', 'true')\n        .style('direction', 'ltr')\n        .style('unicode-bidi', 'isolate')\n        .style('text-anchor', !useSecondaryYScale && (_useRtl ? 'start' : 'end'))\n    : '';\n  return yAxisScale;\n}\n\n/**\n * Creating String Y axis of the chart for Horizontal Bar Chart With Axis\n * @param yAxisParams\n * @param dataPoints\n * @param isRtl\n */\nexport const createStringYAxisForHorizontalBarChartWithAxis = (\n  yAxisParams: IYAxisParams,\n  dataPoints: string[],\n  isRtl: boolean,\n  barWidth: number,\n): ScaleBand<string> => {\n  const { containerHeight, tickPadding = 12, margins, yAxisTickFormat, yAxisElement, yAxisPadding } = yAxisParams;\n\n  let yAxisPaddingValue = yAxisPadding ?? 0.5;\n  yAxisPaddingValue = yAxisPaddingValue === 1 ? 0.99 : yAxisPaddingValue;\n  const yAxisScale = d3ScaleBand()\n    .domain(dataPoints)\n    .range([containerHeight - margins.bottom!, margins.top!])\n    .padding(yAxisPaddingValue);\n  const axis = isRtl ? d3AxisRight(yAxisScale) : d3AxisLeft(yAxisScale);\n  const yAxis = axis.tickPadding(tickPadding).ticks(dataPoints);\n  if (yAxisTickFormat) {\n    yAxis.tickFormat(yAxisTickFormat);\n  }\n  yAxisElement ? d3Select(yAxisElement).call(yAxis).selectAll('text') : '';\n  return yAxisScale;\n};\n\n/**\n * Creating String Y axis of the chart for other chart except Horizontal Bar Chart With Axis\n * @param yAxisParams\n * @param dataPoints\n * @param isRtl\n */\nexport const createStringYAxis = (\n  yAxisParams: IYAxisParams,\n  dataPoints: string[],\n  isRtl: boolean,\n  barWidth?: number,\n  chartType?: ChartTypes,\n): ScaleBand<string> => {\n  const {\n    containerHeight,\n    tickPadding = 12,\n    margins,\n    yAxisTickFormat,\n    yAxisElement,\n    yAxisPadding = 0,\n    containerWidth,\n  } = yAxisParams;\n  const yAxisScale = d3ScaleBand()\n    .domain(dataPoints)\n    .range([containerHeight - margins.bottom!, margins.top!])\n    .padding(yAxisPadding);\n  if (chartType === ChartTypes.VerticalStackedBarChart) {\n    yAxisScale.paddingInner(1).paddingOuter(0);\n  }\n  const axis = isRtl ? d3AxisRight(yAxisScale) : d3AxisLeft(yAxisScale);\n  const yAxis = axis.tickPadding(tickPadding).tickValues(dataPoints).tickSize(0);\n  if (chartType === ChartTypes.VerticalStackedBarChart) {\n    axis.tickSizeInner(-(containerWidth - margins.left! - margins.right!));\n  }\n  if (yAxisTickFormat) {\n    yAxis.tickFormat(yAxisTickFormat);\n  }\n  yAxisElement ? d3Select(yAxisElement).call(yAxis).selectAll('text') : '';\n  return yAxisScale;\n};\n\n/**\n * For area chart and line chart, while displaying stackCallout, Need to form a callout data object.\n * This methos creates an object for those 2 charts.\n * @param values\n */\n\n// changing the type to any as it is used by multiple charts with different data types\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function calloutData(\n  values: ((LineChartPoints | ScatterChartPoints) & { index?: number })[],\n): Record<string, YValueHover[]> {\n  let combinedResult: ((LineChartDataPoint | ScatterChartDataPoint) & {\n    legend: string;\n    color?: string;\n    index?: number;\n  })[] = [];\n\n  values.forEach((line: (LineChartPoints | ScatterChartPoints) & { index?: number }) => {\n    const elements = line.data\n      .filter((point: LineChartDataPoint | ScatterChartDataPoint) => !point.hideCallout)\n      .map((point: LineChartDataPoint | ScatterChartDataPoint) => {\n        return { ...point, legend: line.legend, color: line.color, index: line.index };\n      });\n    combinedResult = combinedResult.concat(elements);\n  });\n\n  const xValToDataPoints: {\n    [key: number]: {\n      legend: string;\n      y: number;\n      color: string;\n      xAxisCalloutData?: string;\n      yAxisCalloutData?: string | { [id: string]: number };\n      callOutAccessibilityData?: AccessibilityProps;\n      index?: number;\n    }[];\n    [key: string]: {\n      legend: string;\n      y: number;\n      color: string;\n      xAxisCalloutData?: string;\n      yAxisCalloutData?: string | { [id: string]: number };\n      callOutAccessibilityData?: AccessibilityProps;\n      index?: number;\n    }[];\n  } = {};\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  combinedResult.forEach((ele: any) => {\n    const xValue = ele.x instanceof Date ? ele.x.getTime() : ele.x;\n    if (xValue in xValToDataPoints) {\n      xValToDataPoints[xValue].push({\n        legend: ele.legend,\n        y: ele.y,\n        color: ele.color!,\n        xAxisCalloutData: ele.xAxisCalloutData,\n        yAxisCalloutData: ele.yAxisCalloutData,\n        callOutAccessibilityData: ele.callOutAccessibilityData,\n        index: ele.index,\n      });\n    } else {\n      xValToDataPoints[xValue] = [\n        {\n          legend: ele.legend,\n          y: ele.y,\n          color: ele.color!,\n          xAxisCalloutData: ele.xAxisCalloutData,\n          yAxisCalloutData: ele.yAxisCalloutData,\n          callOutAccessibilityData: ele.callOutAccessibilityData,\n          index: ele.index,\n        },\n      ];\n    }\n  });\n\n  return xValToDataPoints;\n}\n\nexport function getUnique(\n  arr: { x: number | Date | string; values: { legend: string; y: number }[] }[],\n  comp: string | number,\n): {\n  x: number | Date | string;\n  values: { legend: string; y: number }[];\n}[] {\n  const unique = arr\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    .map((e: { [x: string]: any }) => e[comp])\n    // store the keys of the unique objects\n    .map((e: string, i: number, final: string[]) => final.indexOf(e) === i && i)\n    // eliminate the dead keys & store unique objects\n    .filter((e: number) => arr[e])\n    .map((e: number) => arr[e]);\n  return unique;\n}\n\n/**\n * This function takes two paramerter\n * 1. an array of strings\n * 2. a string value\n * if the value is not present in the given array then it will return the new\n * array by appending the value to the present arrray.\n *\n * if the value is already present in  the given array then it will return the new\n * array by deleteing the value from the the array\n * @param array\n * @param value\n */\nexport function silceOrAppendToArray(array: string[], value: string): string[] {\n  const pos = array.indexOf(value);\n  if (pos === -1) {\n    return [...array, value];\n  } else {\n    return array.slice(0, pos).concat(array.slice(pos + 1));\n  }\n}\n\nexport const DEFAULT_WRAP_WIDTH = 10;\n\n/**\n * This method used for wrapping of x axis labels (tick values).\n * It breaks down given text value by space separated and calculates the total height needed to display all the words.\n * That value = removal value. This value needs to be remove from total svg height, svg will shrink and\n * total text will be displayed.\n * @export\n * @param {IWrapLabelProps} wrapLabelProps\n * @returns\n */\nexport function createWrapOfXLabels(wrapLabelProps: IWrapLabelProps): number | undefined {\n  const { node, xAxis, noOfCharsToTruncate, showXAxisLablesTooltip, width = DEFAULT_WRAP_WIDTH } = wrapLabelProps;\n  if (node === null) {\n    return;\n  }\n  const axisNode = d3Select(node).call(xAxis);\n  let removeVal = 0;\n  let maxLines = 1;\n  axisNode.selectAll('.tick text').each(function () {\n    const text = d3Select(this);\n    const totalWord = text.text();\n    const truncatedWord = `${text.text().slice(0, noOfCharsToTruncate)}...`;\n    const totalWordLength = text.text().length;\n    const words = text.text().split(/\\s+/).reverse();\n    let word: string = '';\n    let line: string[] = [];\n    let lineNumber: number = 0;\n    const lineHeight = 1.1; // ems\n    const y = text.attr('y');\n    const dy = parseFloat(text.attr('dy'));\n    let tspan = text\n      .text(null)\n      .append('tspan')\n      .attr('x', 0)\n      .attr('y', y)\n      .attr('id', 'BaseSpan')\n      .attr('dy', dy + 'em')\n      .attr('data-', totalWord);\n\n    if (showXAxisLablesTooltip && totalWordLength > noOfCharsToTruncate) {\n      tspan = text\n        .append('tspan')\n        .attr('id', 'showDots')\n        .attr('x', 0)\n        .attr('y', y)\n        .attr('dy', dy + 'em')\n        .text(truncatedWord);\n    } else if (showXAxisLablesTooltip && totalWordLength <= noOfCharsToTruncate) {\n      tspan = text\n        .append('tspan')\n        .attr('id', 'LessLength')\n        .attr('x', 0)\n        .attr('y', y)\n        .attr('dy', dy + 'em')\n        .text(totalWord);\n    } else {\n      while ((word = words.pop()!)) {\n        line.push(word);\n        tspan.text(line.join(' '));\n        if (tspan.node()!.getComputedTextLength() > width && line.length > 1) {\n          line.pop();\n          tspan.text(line.join(' '));\n          line = [word];\n          tspan = text\n            .append('tspan')\n            .attr('id', 'WordBreakId')\n            .attr('x', 0)\n            .attr('y', y)\n            .attr('dy', ++lineNumber * lineHeight + dy + 'em')\n            .text(word);\n        }\n      }\n    }\n    maxLines = Math.max(maxLines, lineNumber + 1);\n  });\n  if (!showXAxisLablesTooltip) {\n    let maxHeight: number = 12; // intial value to render corretly first time\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const outerHTMLElement = document.getElementById('WordBreakId') as any;\n    const BoxCordinates = outerHTMLElement && outerHTMLElement.getBoundingClientRect();\n    const boxHeight = BoxCordinates && BoxCordinates.height;\n    if (boxHeight > maxHeight) {\n      maxHeight = boxHeight;\n    }\n    removeVal = (maxLines - 1) * maxHeight;\n  }\n  return removeVal > 0 ? removeVal : 0;\n}\n\n/**\n * This method used for wrapping of y axis labels (tick values).\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function createYAxisLabels(\n  node: SVGElement | null,\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  yAxis: any,\n  noOfCharsToTruncate: number,\n  truncateLabel: boolean,\n  isRtl: boolean,\n): void {\n  if (node === null) {\n    return;\n  }\n  let tickIndex = 0;\n  const axisNode = d3Select(node).call(yAxis);\n  axisNode.selectAll('.tick text').each(function () {\n    const text = d3Select(this);\n    const totalWord = text.text();\n    const truncatedWord = isRtl\n      ? `...${text.text().slice(0, noOfCharsToTruncate)}`\n      : `${text.text().slice(0, noOfCharsToTruncate)}...`;\n    const totalWordLength = text.text().length;\n    const padding = 0; // ems\n    const y = text.attr('y');\n    const x = text.attr('x');\n    const dy = parseFloat(text.attr('dy'));\n    const dx = 0;\n    const uid = tickIndex++;\n    text\n      .text(null)\n      .append('tspan')\n      .attr('x', x)\n      .attr('y', y)\n      .attr('id', `BaseSpan-${uid}`)\n      .attr('dy', dy + 'em')\n      .attr('data-', totalWord);\n\n    if (truncateLabel && totalWordLength > noOfCharsToTruncate) {\n      text\n        .append('tspan')\n        .attr('id', `showDots-${uid}`)\n        .attr('x', x)\n        .attr('y', y)\n        .attr('dy', dy + 'em')\n        .attr('dx', padding + dx + 'em')\n        .text(truncatedWord);\n    } else {\n      text\n        .append('tspan')\n        .attr('id', `LessLength-${uid}`)\n        .attr('x', x)\n        .attr('y', y)\n        .attr('dx', padding + dx + 'em')\n        .text(totalWord);\n    }\n  });\n}\n\nexport const wrapContent = (content: string, id: string, maxWidth: number): boolean => {\n  const textElement = d3Select<SVGTextElement, {}>(`#${id}`);\n  textElement.text(content);\n  if (!textElement.node()) {\n    return false;\n  }\n\n  let isOverflowing = false;\n  let textLength = textElement.node()!.getComputedTextLength();\n  while (textLength > maxWidth && content.length > 0) {\n    content = content.slice(0, -1);\n    textElement.text(content + '...');\n    isOverflowing = true;\n    textLength = textElement.node()!.getComputedTextLength();\n  }\n  return isOverflowing;\n};\n\n/**\n * Calculates the width of the longest axis label in pixels\n */\nexport const calculateLongestLabelWidth = (labels: (string | number)[], query: string = 'none'): number => {\n  let maxLabelWidth = 0;\n  const canvas = document.createElement('canvas');\n  const ctx = canvas.getContext('2d');\n\n  if (ctx) {\n    const axisText = document.querySelector(query);\n    if (axisText) {\n      const styles = window.getComputedStyle(axisText, null);\n      const fontWeight = styles.getPropertyValue('font-weight');\n      const fontSize = styles.getPropertyValue('font-size');\n      const fontFamily = styles.getPropertyValue('font-family');\n      ctx.font = `${fontWeight} ${fontSize} ${fontFamily}`;\n    } else {\n      ctx.font = '600 10px \"Segoe UI\"';\n    }\n\n    labels.forEach(label => {\n      maxLabelWidth = Math.max(ctx.measureText(label.toString()).width, maxLabelWidth);\n    });\n  }\n\n  return maxLabelWidth;\n};\n\n/**\n * This method displays a tooltip to the x axis lables(tick values)\n * when prop 'showXAxisLablesTooltip' enables to the respected chart.\n * On hover of the truncated word(at x axis labels tick), a tooltip will be appeared.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function tooltipOfAxislabels(axistooltipProps: any): null | undefined {\n  const { tooltipCls, axis, id } = axistooltipProps;\n  if (axis === null) {\n    return null;\n  }\n  const div = d3Select('body').append('div').attr('id', id).attr('class', tooltipCls).style('opacity', 0);\n  const aa = axis!.selectAll('[id^=\"BaseSpan-\"]')._groups[0];\n  const baseSpanLength = aa && Object.keys(aa)!.length;\n  const originalDataArray: string[] = [];\n  for (let i = 0; i < baseSpanLength; i++) {\n    const originalData = aa[i].dataset && (Object.values(aa[i].dataset)[0] as string);\n    originalDataArray.push(originalData);\n  }\n  const tickObject = axis!.selectAll('.tick')._groups[0];\n  const tickObjectLength = tickObject && Object.keys(tickObject)!.length;\n  for (let i = 0; i < tickObjectLength; i++) {\n    const d1 = tickObject[i];\n    d3Select(d1)\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      .on('mouseover', (event: any, d) => {\n        div.style('opacity', 0.9);\n        div\n          .html(originalDataArray[i])\n          .style('left', event.pageX + 'px')\n          .style('top', event.pageY - 28 + 'px');\n      })\n      .on('mouseout', d => {\n        div.style('opacity', 0);\n      });\n  }\n}\n\n/**\n * Find the axis type of line chart and area chart from given data\n * @param points\n */\nexport function getXAxisType(points: LineChartPoints[]): boolean {\n  let isXAxisDateType: boolean = false;\n  if (points && points.length > 0) {\n    points.forEach((chartData: LineChartPoints) => {\n      if (chartData.data.length > 0) {\n        isXAxisDateType = chartData.data[0].x instanceof Date;\n        return;\n      }\n    });\n  }\n  return isXAxisDateType;\n}\n\n/**\n * Calculates Domain and range values for Numeric X axis.\n * This method calculates Area cart and line chart.\n * @export\n * @param {LineChartPoints[]} points\n * @param {IMargins} margins\n * @param {number} width\n * @param {boolean} isRTL\n * @returns {IDomainNRange}\n */\nexport function domainRangeOfNumericForAreaLineScatterCharts(\n  points: LineChartPoints[] | ScatterChartPoints[],\n  margins: IMargins,\n  width: number,\n  isRTL: boolean,\n  scaleType?: AxisScaleType,\n  hasMarkersMode?: boolean,\n): IDomainNRange {\n  const isScatterPolar = isScatterPolarSeries(points);\n  let [xMin, xMax] = getScatterXDomainExtent(points, scaleType) as [number, number];\n\n  if (hasMarkersMode) {\n    const xPadding = getDomainPaddingForMarkers(xMin, xMax, scaleType);\n    xMin = xMin - xPadding.start;\n    xMax = xMax + xPadding.end;\n  }\n\n  const rStartValue = margins.left!;\n  const rEndValue = width - margins.right!;\n\n  return isRTL\n    ? { dStartValue: isScatterPolar ? 1 : xMax, dEndValue: isScatterPolar ? -1 : xMin, rStartValue, rEndValue }\n    : { dStartValue: isScatterPolar ? -1 : xMin, dEndValue: isScatterPolar ? 1 : xMax, rStartValue, rEndValue };\n}\n\n/**\n * Groups HorizontalBarChart With Axis data based on YValue\n * Used for stacked case\n * @param {IHorizontalBarChartWithAxisDataPoint[]} chartData\n * @returns {IHorizontalBarChartWithAxisDataPoint[][]}\n */\nexport function groupChartDataByYValue(\n  chartData: HorizontalBarChartWithAxisDataPoint[],\n): HorizontalBarChartWithAxisDataPoint[][] {\n  const map: Record<string, HorizontalBarChartWithAxisDataPoint[]> = {};\n  chartData.forEach(dataPoint => {\n    const key = dataPoint.y;\n    if (!map[key]) {\n      map[key] = [];\n    }\n    map[key].push(dataPoint);\n  });\n\n  return Object.values(map);\n}\n\n/**\n * Calculates maximum domain values for Numeric x axis for both positive and negative values\n * works for Horizontal Bar Chart With axis\n * @param {HorizontalBarChartWithAxisDataPoint[][]} stackedChartData\n * @returns {number}\n */\nexport function computeLongestBars(\n  stackedChartData: HorizontalBarChartWithAxisDataPoint[][],\n  X_ORIGIN: number,\n): {\n  longestPositiveBar: number;\n  longestNegativeBar: number;\n} {\n  let longestPositiveBar = 0;\n  let longestNegativeBar = 0;\n\n  stackedChartData.forEach((group: HorizontalBarChartWithAxisDataPoint[]) => {\n    const positiveBarTotal = group.reduce(\n      (acc: number, point: HorizontalBarChartWithAxisDataPoint) => acc + (point.x > 0 ? point.x : 0),\n      X_ORIGIN,\n    );\n    const negativeBarTotal = group.reduce(\n      (acc: number, point: HorizontalBarChartWithAxisDataPoint) => acc + (point.x < 0 ? point.x : 0),\n      X_ORIGIN,\n    );\n\n    longestPositiveBar = Math.max(longestPositiveBar, positiveBarTotal);\n    longestNegativeBar = Math.min(longestNegativeBar, negativeBarTotal);\n  });\n  return { longestPositiveBar, longestNegativeBar };\n}\n\n/**\n * Calculates Domain and range values for Numeric X axis.\n * This method calculates Horizontal Chart with Axis\n * @export\n * @param {LineChartPoints[]} points\n * @param {IMargins} margins\n * @param {number} width\n * @param {boolean} isRTL\n * @returns {IDomainNRange}\n */\nexport function domainRangeOfNumericForHorizontalBarChartWithAxis(\n  points: HorizontalBarChartWithAxisDataPoint[],\n  margins: IMargins,\n  containerWidth: number,\n  isRTL: boolean,\n  shiftX: number,\n  X_ORIGIN?: number,\n): IDomainNRange {\n  const longestBars = computeLongestBars(groupChartDataByYValue(points), X_ORIGIN!);\n  const xMax = longestBars.longestPositiveBar;\n  const xMin = longestBars.longestNegativeBar;\n  const rMin = isRTL ? margins.left! : margins.left! + shiftX;\n  const rMax = isRTL ? containerWidth - margins.right! - shiftX : containerWidth - margins.right!;\n\n  return isRTL\n    ? { dStartValue: xMax, dEndValue: Math.min(xMin, X_ORIGIN!), rStartValue: rMin, rEndValue: rMax }\n    : { dStartValue: Math.min(xMin, X_ORIGIN!), dEndValue: xMax, rStartValue: rMin, rEndValue: rMax };\n}\n\n/**\n * Calculates Range values of x Axis string axis\n * For String axis, we need to give domain values (Not start and end array values)\n * So sending 0 as domain values. Domain will be handled at creation of string axis\n * For charts stacked bar chart, grouped vertical bar chart, HeatMapChart and Vertical bar chart\n * @export\n * @param {IMargins} margins\n * @param {number} width\n * @param {boolean} isRTL\n * @returns {IDomainNRange}\n */\nexport function domainRangeOfXStringAxis(margins: IMargins, width: number, isRTL: boolean): IDomainNRange {\n  const rMin = margins.left!;\n  const rMax = width - margins.right!;\n  return isRTL\n    ? { dStartValue: 0, dEndValue: 0, rStartValue: rMax, rEndValue: rMin }\n    : { dStartValue: 0, dEndValue: 0, rStartValue: rMin, rEndValue: rMax };\n}\n\n/**\n * Calculate domain and range values to the Vertical stacked bar chart - For Numeric axis\n * @export\n * @param {DataPoint[]} points\n * @param {IMargins} margins\n * @param {number} width\n * @param {boolean} isRTL\n * @param {number} barWidth\n * @returns {IDomainNRange}\n */\nexport function domainRangeOfVSBCNumeric(\n  points: DataPoint[],\n  margins: IMargins,\n  width: number,\n  isRTL: boolean,\n  barWidth: number,\n): IDomainNRange {\n  const xMin = d3Min(points, (point: DataPoint) => point.x as number)!;\n  const xMax = d3Max(points, (point: DataPoint) => point.x as number)!;\n  const rMax = margins.left!;\n  const rMin = width - margins.right!;\n  return isRTL\n    ? { dStartValue: xMax, dEndValue: xMin, rStartValue: rMax, rEndValue: rMin }\n    : { dStartValue: xMin, dEndValue: xMax, rStartValue: rMax, rEndValue: rMin };\n}\n\n/**\n * Calculates Domain and range values for Date X axis.\n * This method calculates Bar chart.\n * @export\n * @param {VerticalBarChartDataPoint[]} points\n * @param {IMargins} margins\n * @param {number} width\n * @param {boolean} isRTL\n * @param {Date[] | number[]} tickValues\n * @returns {IDomainNRange}\n */\nexport function domainRangeOfDateForAreaLineScatterVerticalBarCharts(\n  points: LineChartPoints[] | ScatterChartPoints[] | VerticalBarChartDataPoint[] | VerticalStackedBarDataPoint[],\n  margins: IMargins,\n  width: number,\n  isRTL: boolean,\n  tickValues: Date[] = [],\n  chartType: ChartTypes,\n  barWidth?: number,\n  hasMarkersMode?: boolean,\n): IDomainNRange {\n  let sDate: Date;\n  let lDate: Date;\n  if ([ChartTypes.AreaChart, ChartTypes.LineChart, ChartTypes.ScatterChart].includes(chartType)) {\n    [sDate, lDate] = getScatterXDomainExtent(points as LineChartPoints[]) as [Date, Date];\n    // Need to draw graph with given small and large date\n    // (Which Involves customization of date axis tick values)\n    // That may be Either from given graph data or from prop 'tickValues' date values.\n    // So, Finding smallest and largest dates\n    sDate = d3Min([...tickValues, sDate])!;\n    lDate = d3Max([...tickValues, lDate])!;\n\n    if (hasMarkersMode || chartType === ChartTypes.ScatterChart) {\n      const xPadding = getDomainPaddingForMarkers(sDate.getTime(), lDate.getTime());\n      sDate = new Date(sDate.getTime() - xPadding.start);\n      lDate = new Date(lDate.getTime() + xPadding.end);\n    }\n  } else {\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    sDate = d3Min(points as any[], point => point.x as Date)!;\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    lDate = d3Max(points as any[], point => point.x as Date)!;\n  }\n\n  const rStartValue = margins.left!;\n  const rEndValue = width - margins.right!;\n\n  return isRTL\n    ? { dStartValue: lDate, dEndValue: sDate, rStartValue, rEndValue }\n    : { dStartValue: sDate, dEndValue: lDate, rStartValue, rEndValue };\n}\n\n/**\n * Calculate domain and range values to the Vertical bar chart - For Numeric axis\n * @export\n * @param {DataPoint[]} points\n * @param {IMargins} margins\n * @param {number} containerWidth\n * @param {boolean} isRTL\n * @param {number} barWidth\n * @returns {IDomainNRange}\n */\nexport function domainRangeOfVerticalNumeric(\n  points: DataPoint[],\n  margins: IMargins,\n  containerWidth: number,\n  isRTL: boolean,\n  barWidth: number,\n): IDomainNRange {\n  const xMax = d3Max(points, (point: VerticalBarChartDataPoint) => point.x as number)!;\n  const xMin = d3Min(points, (point: VerticalBarChartDataPoint) => point.x as number)!;\n  const rMin = margins.left!;\n  const rMax = containerWidth - margins.right!;\n\n  return isRTL\n    ? { dStartValue: xMax, dEndValue: xMin, rStartValue: rMin, rEndValue: rMax }\n    : { dStartValue: xMin, dEndValue: xMax, rStartValue: rMin, rEndValue: rMax };\n}\n\n/**\n * Calculating start and ending values of the Area chart and LineChart\n * @export\n * @param {LineChartPoints[]} points\n * @returns {{ startValue: number; endValue: number }}\n */\nexport function findNumericMinMaxOfY(\n  points: LineChartPoints[] | ScatterChartPoints[],\n  yAxisType?: YAxisType | undefined,\n  useSecondaryYScale?: boolean,\n  scaleType?: AxisScaleType,\n): { startValue: number; endValue: number } {\n  const values: number[] = [];\n  points.forEach(point => {\n    if (!useSecondaryYScale === !point.useSecondaryYScale) {\n      point.data.forEach(data => {\n        if (isValidDomainValue(data.y, scaleType)) {\n          values.push(data.y);\n        }\n      });\n    }\n  });\n\n  return {\n    startValue: d3Min(values)!,\n    endValue: d3Max(values)!,\n  };\n}\n\n/**\n * Find the minimum and maximum values of the vertical stacked bar chart y axis data point. Used for create y axis.\n * @export\n * @param {DataPoint[]} dataset\n * @returns {{ startValue: number; endValue: number }}\n */\nexport function findVSBCNumericMinMaxOfY(dataset: DataPoint[]): { startValue: number; endValue: number } {\n  const yMax = d3Max(dataset, (point: DataPoint) => point.y)!;\n  const yMin = d3Min(dataset, (point: DataPoint) => point.y)!;\n\n  return { startValue: yMin, endValue: yMax };\n}\n\n/**\n * Finds the min and max values of the vertical bar chart y axis data point.\n * @export\n * @param {VerticalBarChartDataPoint[]} points\n * @returns {{ startValue: number; endValue: number }}\n */\nexport function findVerticalNumericMinMaxOfY(\n  points: VerticalBarChartDataPoint[],\n  yAxisType?: YAxisType,\n  useSecondaryYScale?: boolean,\n): {\n  startValue: number;\n  endValue: number;\n} {\n  const values: number[] = [];\n  points.forEach(point => {\n    if (!useSecondaryYScale) {\n      values.push(point.y);\n    }\n    if (typeof point.lineData !== 'undefined') {\n      if (!useSecondaryYScale === !point.lineData.useSecondaryYScale) {\n        values.push(point.lineData.y);\n      }\n    }\n  });\n\n  return { startValue: d3Min(values)!, endValue: d3Max(values)! };\n}\n/**\n * Finds the min and max values of the horizontal bar chart y axis data point.\n * @export\n * @param {HorizontalBarChartWithAxisDataPoint[]|GanttChartDataPoint[]} points\n * @returns {{ startValue: number; endValue: number }}\n */\nexport function findHBCWANumericMinMaxOfY(\n  points: HorizontalBarChartWithAxisDataPoint[] | GanttChartDataPoint[],\n  yAxisType: YAxisType | undefined,\n): { startValue: number; endValue: number } {\n  if (yAxisType !== undefined && yAxisType === YAxisType.NumericAxis) {\n    const yMax = d3Max(\n      points,\n      (point: HorizontalBarChartWithAxisDataPoint | GanttChartDataPoint) => point.y as number,\n    )!;\n    const yMin = d3Min(\n      points,\n      (point: HorizontalBarChartWithAxisDataPoint | GanttChartDataPoint) => point.y as number,\n    )!;\n\n    return { startValue: yMin, endValue: yMax };\n  }\n  return { startValue: 0, endValue: 0 };\n}\n\n/**\n * @param p string or number or Date\n *\n * This function takes the single data point of the x-aixs\n * and decides what is the x-axis\n */\nexport const getTypeOfAxis = (p: string | number | Date, isXAxis: boolean): XAxisTypes | YAxisType => {\n  if (isXAxis) {\n    switch (typeof p) {\n      case 'string':\n        return XAxisTypes.StringAxis;\n      case 'number':\n        return XAxisTypes.NumericAxis;\n      default:\n        return XAxisTypes.DateAxis;\n    }\n  } else {\n    switch (typeof p) {\n      case 'string':\n        return YAxisType.StringAxis;\n      case 'number':\n        return YAxisType.NumericAxis;\n      default:\n        return YAxisType.DateAxis;\n    }\n  }\n};\n\n/**\n * we need to make sure that if we add any property to this, then\n * we need to also add that in  pointTypes below and vise-versa\n */\n\nexport enum Points {\n  circle,\n  square,\n  triangle,\n  diamond,\n  pyramid,\n  hexagon,\n  pentagon,\n  octagon,\n}\n\nexport enum CustomPoints {\n  dottedLine,\n}\n\nexport type PointTypes = {\n  [key in number]: {\n    /**\n     * For certian shapes like pentagon, hexagon and octagon.\n     * the width of the bouding box increase by the time of the\n     * length of the side, so when we want to render a pentagon\n     * having each side of length 7 units we need to decrease it's\n     * units by width ratio so that the bounding box width of the pentagon\n     * stays as 7\n     */\n    widthRatio: number;\n  };\n};\n\n/**\n * we need to make sure that if we add any property to this, then\n * we need to also add that in enum Point and vise-versa\n */\n\nexport const pointTypes: PointTypes = {\n  [Points.circle]: {\n    widthRatio: 1,\n  },\n  [Points.square]: {\n    widthRatio: 1,\n  },\n  [Points.triangle]: {\n    widthRatio: 1,\n  },\n  [Points.diamond]: {\n    widthRatio: 1,\n  },\n  [Points.pyramid]: {\n    widthRatio: 1,\n  },\n  [Points.hexagon]: {\n    widthRatio: 2,\n  },\n  [Points.pentagon]: {\n    widthRatio: 1.168,\n  },\n  [Points.octagon]: {\n    widthRatio: 2.414,\n  },\n};\n\n/**\n * @param accessibleData accessible data\n * @param role string to define role of tag\n * @param isDataFocusable boolean\n * function returns the accessibility data object\n */\nexport const getAccessibleDataObject = (\n  accessibleData?: AccessibilityProps,\n  role: string = 'text',\n  isDataFocusable: boolean = true,\n): {\n  role: string;\n  'data-is-focusable': boolean;\n  'aria-label': string | undefined;\n  'aria-labelledby': string | undefined;\n  'aria-describedby': string | undefined;\n} => {\n  accessibleData = accessibleData ?? {};\n  return {\n    role,\n    'data-is-focusable': isDataFocusable,\n    'aria-label': accessibleData!.ariaLabel,\n    'aria-labelledby': accessibleData!.ariaLabelledBy,\n    'aria-describedby': accessibleData!.ariaDescribedBy,\n  };\n};\n\nexport function rotateXAxisLabels(rotateLabelProps: IRotateLabelProps): number | void {\n  const { node, xAxis } = rotateLabelProps;\n  if (node === null || xAxis === null) {\n    return;\n  }\n\n  let maxHeight: number = 0;\n  const xAxisTranslations: string[] = [];\n  d3Select(node)\n    .call(xAxis)\n    .selectAll('.tick')\n    .each(function () {\n      const translateValue = (this as SVGElement).getAttribute('transform');\n      if (translateValue?.indexOf('rotate') === -1) {\n        const translatePair = translateValue\n          .substring(translateValue.indexOf('(') + 1, translateValue.indexOf(')'))\n          .split(',');\n        if (translatePair.length === 2) {\n          xAxisTranslations.push(translatePair[0]);\n          (this as SVGElement).setAttribute('transform', `translate(${translatePair[0]},0)rotate(-45)`);\n        }\n      }\n\n      const BoxCordinates = (this as HTMLElement).getBoundingClientRect();\n      const boxHeight = BoxCordinates && BoxCordinates.height;\n      if (boxHeight > maxHeight) {\n        maxHeight = boxHeight;\n      }\n    });\n\n  let idx = 0;\n  d3Select(node)\n    .call(xAxis)\n    .selectAll('.tick')\n    .each(function () {\n      if (xAxisTranslations.length > idx) {\n        (this as SVGSVGElement).setAttribute(\n          'transform',\n          `translate(${xAxisTranslations[idx]},${maxHeight / 2})rotate(-45)`,\n        ); // Translate y by max height/2\n        idx += 1;\n      }\n    });\n\n  return Math.floor(maxHeight / 1.414); // Compute maxHeight/tanInverse(45) to get the vertical height of labels.\n}\n\nexport function wrapTextInsideDonut(selectorClass: string, maxWidth: number): void {\n  let idx: number = 0;\n  d3SelectAll(`.${selectorClass}`).each(function () {\n    const text = d3Select(this);\n    const words = text.text().split(/\\s+/).reverse();\n    let word: string = '';\n    let line: string[] = [];\n    let lineNumber: number = 0;\n    const lineHeight = 1.1; // ems\n    const y = text.attr('y');\n\n    let tspan = text\n      .text(null)\n      .append('tspan')\n      .attr('id', `WordBreakId-${idx}-${lineNumber}`)\n      .attr('x', 0)\n      .attr('y', y)\n      .attr('dy', lineNumber++ * lineHeight + 'em');\n\n    while ((word = words.pop()!)) {\n      line.push(word);\n      tspan.text(line.join(' ') + ' ');\n      if (tspan.node()!.getComputedTextLength() > maxWidth && line.length > 1) {\n        line.pop();\n        tspan.text(line.join(' ') + ' ');\n        line = [word];\n        tspan = text\n          .append('tspan')\n          .attr('id', `WordBreakId-${idx}-${lineNumber}`)\n          .attr('x', 0)\n          .attr('y', y)\n          .attr('dy', lineNumber++ * lineHeight + 'em')\n          .text(word);\n      }\n    }\n    idx += 1;\n  });\n}\n\nexport function formatScientificLimitWidth(value: number): string {\n  return yAxisTickFormatterInternal(value, true);\n}\n\nconst DEFAULT_BAR_WIDTH = 16;\nconst MIN_BAR_WIDTH = 1;\n\nexport const getBarWidth = (\n  barWidthProp: number | 'default' | 'auto' | undefined,\n  maxBarWidthProp: number | undefined,\n  adjustedValue = DEFAULT_BAR_WIDTH,\n  modeProp?: string,\n): number => {\n  let barWidth: number;\n  if (barWidthProp === 'auto' || modeProp === 'histogram') {\n    barWidth = adjustedValue;\n  } else if (typeof barWidthProp === 'number') {\n    barWidth = barWidthProp;\n  } else {\n    barWidth = Math.min(adjustedValue, DEFAULT_BAR_WIDTH);\n  }\n  if (typeof maxBarWidthProp === 'number') {\n    barWidth = Math.min(barWidth, maxBarWidthProp);\n  }\n  barWidth = Math.max(barWidth, MIN_BAR_WIDTH);\n  return barWidth;\n};\n\nexport const getScalePadding = (prop: number | undefined, shorthandProp?: number, defaultValue = 0): number => {\n  let padding = typeof prop === 'number' ? prop : typeof shorthandProp === 'number' ? shorthandProp : defaultValue;\n  padding = Math.max(0, Math.min(padding, 1));\n  return padding;\n};\n\nexport const isScalePaddingDefined = (prop: number | undefined, shorthandProp?: number): boolean => {\n  return typeof prop === 'number' || typeof shorthandProp === 'number';\n};\n\n/**\n * Helper to find the index of an item within an array, using a callback to\n * determine the match.\n *\n * @public\n * @param array - Array to search.\n * @param cb - Callback which returns true on matches.\n * @param fromIndex - Optional index to start from (defaults to 0)\n */\nexport function findIndex<T>(array: T[], cb: (item: T, index: number) => boolean, fromIndex: number = 0): number {\n  let index = -1;\n\n  for (let i = fromIndex; array && i < array.length; i++) {\n    if (cb(array[i], i)) {\n      index = i;\n      break;\n    }\n  }\n\n  return index;\n}\n\n/**\n * Helper to find the first item within an array that satisfies the callback.\n * @param array - Array to search\n * @param cb - Callback which returns true on matches\n */\nexport function find<T>(array: T[], cb: (item: T, index: number) => boolean): T | undefined {\n  let index = findIndex(array, cb);\n\n  if (index < 0) {\n    return undefined;\n  }\n\n  return array[index];\n}\n\nexport const HighContrastSelector = '@media screen and (-ms-high-contrast: active), screen and (forced-colors: active)';\nexport const HighContrastSelectorWhite =\n  // eslint-disable-next-line @fluentui/max-len\n  '@media screen and (-ms-high-contrast: black-on-white), screen and (forced-colors: active) and (prefers-color-scheme: light)';\nexport const HighContrastSelectorBlack =\n  // eslint-disable-next-line @fluentui/max-len\n  '@media screen and (-ms-high-contrast: white-on-black), screen and (forced-colors: active) and (prefers-color-scheme: dark)';\n\n/**\n * Render function interface for providing overrideable render callbacks.\n *\n * @public\n */\nexport interface RenderFunction<P> {\n  (props?: P, defaultRender?: (props?: P) => JSXElement | null): JSXElement | null;\n}\n\nexport const formatDate = (date: Date, useUTC?: string | boolean): string => {\n  const timeFormat = useUTC ? d3UtcFormat : d3TimeFormat;\n  return timeFormat('%-e %b %Y, %H:%M')(date) + (useUTC ? ' GMT' : '');\n};\n\nexport function areArraysEqual(arr1?: string[], arr2?: string[]): boolean {\n  if (arr1 === arr2 || (!arr1 && !arr2)) {\n    return true;\n  }\n  if (!arr1 || !arr2 || arr1.length !== arr2.length) {\n    return false;\n  }\n  for (let i = 0; i < arr1.length; i++) {\n    if (arr1[i] !== arr2[i]) {\n      return false;\n    }\n  }\n  return true;\n}\n\nconst cssVarRegExp = /var\\((--[a-zA-Z0-9\\-]+)\\)/g;\n\nexport function resolveCSSVariables(chartContainer: HTMLElement, styleRules: string): string {\n  const containerStyles = getComputedStyle(chartContainer);\n  return styleRules.replace(cssVarRegExp, (match, group1) => {\n    return containerStyles.getPropertyValue(group1);\n  });\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport function getSecureProps(props: Record<string, any> = {}): Record<string, any> {\n  const { dangerouslySetInnerHTML, ...result } = props;\n  return result;\n}\n\nexport function getCurveFactory(\n  curve: LineChartLineOptions['curve'],\n  defaultFactory: CurveFactory = d3CurveLinear,\n): CurveFactory {\n  if (typeof curve === 'function') {\n    return curve;\n  }\n\n  switch (curve) {\n    case 'linear':\n      return d3CurveLinear;\n    case 'natural':\n      return d3CurveNatural;\n    case 'step':\n      return d3CurveStep;\n    case 'stepAfter':\n      return d3CurveStepAfter;\n    case 'stepBefore':\n      return d3CurveStepBefore;\n    default:\n      return defaultFactory;\n  }\n}\n\nexport const truncateString = (str: string, maxLength: number, ellipsis = '...'): string => {\n  if (str.length <= maxLength) {\n    return str;\n  }\n\n  return str.slice(0, maxLength) + ellipsis;\n};\n\nconst categoryOrderRegex = /(category|total|sum|min|max|mean|median) (ascending|descending)/;\n\n/**\n * @see {@link https://github.com/plotly/plotly.js/blob/master/src/plots/plots.js#L3041}\n */\nexport const sortAxisCategories = (\n  categoryToValues: Record<string, number[]>,\n  categoryOrder: AxisCategoryOrder | undefined,\n): string[] => {\n  if (Array.isArray(categoryOrder)) {\n    const result: string[] = [];\n    const seen = new Set<string>();\n\n    // Add elements from categoryOrder array that are in categoryToValues, in the array's order\n    categoryOrder.forEach(category => {\n      if (categoryToValues[category] && !seen.has(category)) {\n        result.push(category);\n        seen.add(category);\n      }\n    });\n\n    // Append any keys from categoryToValues not already in result\n    Object.keys(categoryToValues).forEach(category => {\n      if (!seen.has(category)) {\n        result.push(category);\n      }\n    });\n\n    return result;\n  }\n\n  const match = categoryOrder?.match(categoryOrderRegex);\n  if (match) {\n    const aggregator = match[1];\n    const order = match[2];\n\n    if (aggregator === 'category') {\n      const result = Object.keys(categoryToValues).sort();\n      return order === 'descending' ? result.reverse() : result;\n    }\n\n    const aggFn: Record<string, (values: number[]) => number | undefined> = {\n      min: d3Min,\n      max: d3Max,\n      sum: d3Sum,\n      total: d3Sum,\n      mean: d3Mean,\n      median: d3Median,\n    };\n    const sortAscending = (a: [string, number], b: [string, number]) => {\n      return a[1] - b[1];\n    };\n    const sortDescending = (a: [string, number], b: [string, number]) => {\n      return b[1] - a[1];\n    };\n\n    const categoriesAggregatedValue: [string, number][] = [];\n    Object.keys(categoryToValues).forEach(category => {\n      categoriesAggregatedValue.push([category, aggFn[aggregator](categoryToValues[category]) || 0]);\n    });\n\n    categoriesAggregatedValue.sort(order === 'descending' ? sortDescending : sortAscending);\n\n    return categoriesAggregatedValue.map(([category]) => category);\n  }\n\n  return Object.keys(categoryToValues);\n};\n\nexport function copyStyle(properties: string[] | Record<string, string>, fromEl: Element, toEl: Element): void {\n  const styles = getComputedStyle(fromEl);\n  if (Array.isArray(properties)) {\n    properties.forEach(prop => {\n      d3Select(toEl).style(prop, styles.getPropertyValue(prop));\n    });\n  } else {\n    Object.entries(properties).forEach(([fromProp, toProp]) => {\n      d3Select(toEl).style(toProp, styles.getPropertyValue(fromProp));\n    });\n  }\n}\n\nlet measurementSpanCounter = 0;\nfunction getUniqueMeasurementSpanId() {\n  measurementSpanCounter++;\n  return `measurement_span_${measurementSpanCounter}`;\n}\n\nconst MEASUREMENT_SPAN_STYLE = {\n  position: 'absolute',\n  visibility: 'hidden',\n  top: '-20000px',\n  left: 0,\n  padding: 0,\n  margin: 0,\n  border: 'none',\n  whiteSpace: 'pre',\n};\n\nexport const createMeasurementSpan = (\n  text: string | number,\n  className: string,\n  parentElement?: HTMLElement | null,\n): HTMLSpanElement => {\n  const MEASUREMENT_SPAN_ID = getUniqueMeasurementSpanId();\n  let measurementSpan = document.getElementById(MEASUREMENT_SPAN_ID);\n  if (!measurementSpan) {\n    measurementSpan = document.createElement('span');\n    measurementSpan.setAttribute('id', MEASUREMENT_SPAN_ID);\n    measurementSpan.setAttribute('aria-hidden', 'true');\n\n    if (parentElement) {\n      parentElement.appendChild(measurementSpan);\n    } else {\n      document.body.appendChild(measurementSpan);\n    }\n  }\n\n  measurementSpan.setAttribute('class', className);\n  Object.assign(measurementSpan.style, MEASUREMENT_SPAN_STYLE);\n  measurementSpan.textContent = `${text}`;\n\n  return measurementSpan;\n};\n\n/**\n * Utility function to check if an array of points is scatterpolar\n * @param points - Array of chart points\n * @returns true if any point has lineOptions.mode as 'scatterpolar'\n */\nexport function isScatterPolarSeries(points: (LineChartPoints | ScatterChartPoints)[]): boolean {\n  return points.some(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    item => typeof (item as any).lineOptions?.mode === 'string' && (item as any).lineOptions.mode === 'scatterpolar',\n  );\n}\n\n/**\n * Utility function to check if an array of points contains mode as 'text' only\n * @param points - Array of chart points\n * @returns true if any point has lineOptions.mode as 'text'\n */\nexport function isTextMode(points: (LineChartPoints | ScatterChartPoints)[]): boolean {\n  return points.some(\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    item => typeof (item as any).lineOptions?.mode === 'string' && (item as any).lineOptions.mode === 'text',\n  );\n}\n\n// TODO: Refactor to encapsulate the complete numeric scale creation logic here, including setting domain and range.\nconst createNumericScale = (scaleType?: AxisScaleType) => {\n  if (scaleType === 'log') {\n    return d3ScaleLog();\n  } else {\n    return d3ScaleLinear();\n  }\n};\n\nexport const getDomainPaddingForMarkers = (\n  minVal: number,\n  maxVal: number,\n  scaleType?: AxisScaleType,\n): { start: number; end: number } => {\n  if (scaleType === 'log') {\n    return {\n      start: minVal * 0.5,\n      end: maxVal,\n    };\n  }\n\n  const defaultPadding = (maxVal - minVal) * 0.1;\n  return {\n    start: defaultPadding,\n    end: defaultPadding,\n  };\n};\n\n/**\n * Determines whether a value is valid for inclusion in the scale domain.\n * For log scales, ensures the value is strictly positive to prevent undefined scale behavior.\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const isValidDomainValue = (value: any, scaleType?: AxisScaleType): boolean => {\n  return typeof value !== 'number' || scaleType !== 'log' || value > 0;\n};\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nexport const isPlottable = (x: any, y: any): boolean => {\n  return !isInvalidValue(x) && !isInvalidValue(y);\n};\n\nexport const getScatterXDomainExtent = (\n  points: LineChartPoints[] | ScatterChartPoints[],\n  scaleType?: AxisScaleType,\n): [number | Date, number | Date] => {\n  const isValidDataPointForScale = (item: LineChartDataPoint | ScatterChartDataPoint) =>\n    isValidDomainValue(item.x, scaleType);\n\n  const xMin = d3Min(points, point => {\n    return d3Min(point.data.filter(isValidDataPointForScale), item => item.x as number | Date)!;\n  })!;\n\n  const xMax = d3Max(points, point => {\n    return d3Max(point.data.filter(isValidDataPointForScale), item => {\n      return item.x as number | Date;\n    });\n  })!;\n\n  return [xMin, xMax];\n};\n\nexport const getRangeForScatterMarkerSize = ({\n  data,\n  xScale,\n  yScalePrimary,\n  yScaleSecondary,\n  useSecondaryYScale,\n  xScaleType,\n  yScaleType: primaryYScaleType,\n  secondaryYScaleType,\n}: {\n  data: LineChartPoints[] | ScatterChartPoints[];\n  xScale: ScaleContinuousNumeric<number, number> | ScaleTime<number, number>;\n  yScalePrimary: ScaleContinuousNumeric<number, number>;\n  yScaleSecondary?: ScaleContinuousNumeric<number, number>;\n  useSecondaryYScale?: boolean;\n  xScaleType?: AxisScaleType;\n  yScaleType?: AxisScaleType;\n  secondaryYScaleType?: AxisScaleType;\n}): number => {\n  // Note: This function is executed after the scale is created, so the actual padding can be\n  // obtained by calculating the difference between the respective minimums or maximums of the\n  // scale domain and the data. However, doing so often causes the marker size to scale up\n  // unnecessarily when the scale uses a wider domain than required (due to the use of D3's nice\n  // function or our own tick value calculations).\n  // A better approach could be to treat the marker size as a fixed pixel value and adjust the\n  // scale domain with sufficient padding to accommodate the maximum marker sizeinstead of doing\n  // it the other way around (i.e., adjusting the scale domain first with padding and then scaling\n  // the markers to fit inside the plot area).\n  const [xMin, xMax] = getScatterXDomainExtent(data, xScaleType);\n  const xPadding = getDomainPaddingForMarkers(+xMin, +xMax, xScaleType);\n  const scaleXMin = xMin instanceof Date ? new Date(+xMin - xPadding.start) : xMin - xPadding.start;\n  const scaleXMax = xMax instanceof Date ? new Date(+xMax + xPadding.end) : xMax + xPadding.end;\n  const extraXPixels = Math.min(Math.abs(xScale(xMin) - xScale(scaleXMin)), Math.abs(xScale(scaleXMax) - xScale(xMax)));\n\n  const yScaleType = useSecondaryYScale ? secondaryYScaleType : primaryYScaleType;\n  const { startValue: yMin, endValue: yMax } = findNumericMinMaxOfY(data, undefined, useSecondaryYScale, yScaleType);\n  const yPadding = getDomainPaddingForMarkers(yMin, yMax, yScaleType);\n  const scaleYMin = yMin - yPadding.start;\n  const scaleYMax = yMax + yPadding.end;\n  const yScale = (useSecondaryYScale ? yScaleSecondary : yScalePrimary)!;\n  const extraYPixels = Math.min(Math.abs(yScale(scaleYMin) - yScale(yMin)), Math.abs(yScale(yMax) - yScale(scaleYMax)));\n  return Math.min(extraXPixels, extraYPixels);\n};\n\nexport const generateLinearTicks = (tick0: number, tickStep: number, scaleDomain: number[]): number[] => {\n  const domainMin = d3Min(scaleDomain)!;\n  const domainMax = d3Max(scaleDomain)!;\n\n  const precision = Math.max(calculatePrecision(tick0), calculatePrecision(tickStep));\n\n  const start = Math.ceil(precisionRound((domainMin - tick0) / tickStep, precision));\n  const end = Math.floor(precisionRound((domainMax - tick0) / tickStep, precision));\n\n  const ticks: number[] = [];\n  for (let i = start; i <= end; i++) {\n    ticks.push(precisionRound(tick0 + i * tickStep, precision));\n  }\n\n  return ticks;\n};\n\nexport const generateMonthlyTicks = (\n  tick0: Date,\n  tickStepInMonths: number,\n  scaleDomain: Date[],\n  useUTC?: boolean,\n): Date[] => {\n  const domainMin = +d3Min(scaleDomain)!;\n  const domainMax = +d3Max(scaleDomain)!;\n\n  const getMonth = (d: Date) => (useUTC ? d.getUTCMonth() : d.getMonth());\n  const setMonth = (d: Date, month: number) => (useUTC ? new Date(d.setUTCMonth(month)) : new Date(d.setMonth(month)));\n\n  // Find the earliest tick <= domainMin\n  let start = 0;\n  for (let firstTick = new Date(+tick0); +firstTick > domainMin; ) {\n    firstTick = setMonth(firstTick, getMonth(firstTick) - tickStepInMonths);\n    start -= tickStepInMonths;\n  }\n\n  const baseMonth = getMonth(tick0);\n  const ticks: Date[] = [];\n\n  // Generate ticks forward until domainMax\n  for (let i = start; ; i += tickStepInMonths) {\n    let tickDate = setMonth(new Date(+tick0), baseMonth + i);\n\n    // Handle month rollover (e.g., Jan 31 + 1 month  Mar 3 instead of Feb)\n    if (getMonth(tickDate) !== (((baseMonth + i) % 12) + 12) % 12) {\n      tickDate = useUTC ? new Date(tickDate.setUTCDate(0)) : new Date(tickDate.setDate(0));\n    }\n\n    if (+tickDate > domainMax) {\n      break;\n    }\n    if (+tickDate >= domainMin) {\n      ticks.push(tickDate);\n    }\n  }\n\n  return ticks;\n};\n\nconst generateNumericTicks = (\n  scaleType: AxisScaleType | undefined,\n  tickStep: string | number | undefined,\n  tick0: number | Date | undefined,\n  scaleDomain: number[],\n) => {\n  const refTick = typeof tick0 === 'number' ? tick0 : 0;\n\n  if (scaleType === 'log') {\n    if (typeof tickStep === 'number' && tickStep > 0) {\n      return generateLinearTicks(\n        refTick,\n        tickStep,\n        scaleDomain.map(d => Math.log10(d)),\n      ).map(t => Math.pow(10, t));\n    }\n\n    if (typeof tickStep === 'string') {\n      const prefix = tickStep[0];\n      const num = isNumber(tickStep.slice(1)) ? Number(tickStep.slice(1)) : 0;\n      if (prefix === 'L' && num > 0) {\n        return generateLinearTicks(refTick, num, scaleDomain);\n      }\n    }\n\n    return;\n  }\n\n  if (typeof tickStep === 'number' && tickStep > 0) {\n    return generateLinearTicks(refTick, tickStep, scaleDomain);\n  }\n};\n\nconst generateDateTicks = (\n  tickStep: string | number | undefined,\n  tick0: number | Date | undefined,\n  scaleDomain: Date[],\n  useUTC?: boolean,\n) => {\n  const refTick = tick0 instanceof Date ? tick0 : new Date(DEFAULT_DATE_STRING);\n\n  if (typeof tickStep === 'number' && tickStep > 0) {\n    return generateLinearTicks(\n      +refTick,\n      tickStep,\n      scaleDomain.map(d => +d),\n    ).map(t => new Date(t));\n  }\n\n  if (typeof tickStep === 'string') {\n    const prefix = tickStep[0];\n    const num = isNumber(tickStep.slice(1)) ? Number(tickStep.slice(1)) : 0;\n    if (prefix === 'M' && num > 0 && num === Math.round(num)) {\n      return generateMonthlyTicks(refTick, num, scaleDomain, useUTC);\n    }\n  }\n};\n\n/**\n * Calculates a number's precision based on the number of trailing\n * zeros if the number does not have a decimal indicated by a negative\n * precision. Otherwise, it calculates the number of digits after\n * the decimal point indicated by a positive precision.\n * @param value - the value to determine the precision of\n */\nexport function calculatePrecision(value: number | string): number {\n  /**\n   * Group 1:\n   * [1-9]([0]+$) matches trailing zeros\n   * Group 2:\n   * \\.([0-9]*) matches all digits after a decimal point.\n   */\n  const groups = /[1-9]([0]+$)|\\.([0-9]*)/.exec(String(value));\n  if (!groups) {\n    return 0;\n  }\n  if (groups[1]) {\n    return -groups[1].length;\n  }\n  if (groups[2]) {\n    return groups[2].length;\n  }\n  return 0;\n}\n\n/**\n * Rounds a number to a certain level of precision. Accepts negative precision.\n * @param value - The value that is being rounded.\n * @param precision - The number of decimal places to round the number to\n */\nexport function precisionRound(value: number, precision: number, base: number = 10): number {\n  const exp = Math.pow(base, precision);\n  return Math.round(value * exp) / exp;\n}\n\nexport const findCalloutPoints = (\n  calloutPointsByX: Record<string, YValueHover[]>,\n  x: string | number | Date | null,\n): { x: string | number | Date; values: YValueHover[] } | undefined => {\n  if (x === null) {\n    return undefined;\n  }\n\n  const key = x instanceof Date ? x.getTime() : x;\n  if (!calloutPointsByX[key]) {\n    return undefined;\n  }\n  return {\n    x,\n    values: calloutPointsByX[key],\n  };\n};\n"],"names":["axisRight","d3AxisRight","axisBottom","d3AxisBottom","axisLeft","d3AxisLeft","max","d3Max","min","d3Min","ticks","d3Ticks","nice","d3nice","sum","d3Sum","mean","d3Mean","median","d3Median","scaleLinear","d3ScaleLinear","scaleBand","d3ScaleBand","scaleUtc","d3ScaleUtc","scaleTime","d3ScaleTime","scaleLog","d3ScaleLog","select","d3Select","selectAll","d3SelectAll","format","d3Format","timeFormat","d3TimeFormat","timeFormatLocale","d3TimeFormatLocale","utcFormat","d3UtcFormat","timeSecond","d3TimeSecond","timeMinute","d3TimeMinute","timeHour","d3TimeHour","timeDay","d3TimeDay","timeMonth","d3TimeMonth","timeWeek","d3TimeWeek","timeYear","d3TimeYear","utcSecond","d3UtcSecond","utcMinute","d3UtcMinute","utcHour","d3UtcHour","utcDay","d3UtcDay","utcMonth","d3UtcMonth","utcWeek","d3UtcWeek","utcYear","d3UtcYear","curveLinear","d3CurveLinear","curveNatural","d3CurveNatural","curveStep","d3CurveStep","curveStepAfter","d3CurveStepAfter","curveStepBefore","d3CurveStepBefore","formatPrefix","d3FormatPrefix","useFluent_unstable","useFluent","formatDateToLocaleString","formatToLocaleString","getMultiLevelDateTimeFormatOptions","isInvalidValue","isNumber","MIN_DOMAIN_MARGIN","MIN_DONUT_RADIUS","DEFAULT_DATE_STRING","ChartTypes","XAxisTypes","YAxisType","yAxisTickFormatterInternal","value","limitWidth","formatter","Math","abs","formattedValue","replace","defaultYAxisTickFormatter","createNumericXAxis","xAxisParams","tickParams","chartType","culture","scaleType","_useRtl","domainNRangeValues","showRoundOffXTickValues","xAxistickSize","tickPadding","xAxisCount","xAxisElement","hideTickOverlap","calcMaxLabelWidth","tickStep","tick0","xAxisScale","createNumericScale","domain","dStartValue","dEndValue","range","rStartValue","rEndValue","tickCount","tickFormat","domainValue","_index","defaultFormat","xAxisValue","valueOf","longestLabelWidth","map","v","i","start","end","floor","xAxis","tickSize","includes","tickSizeInner","containerHeight","margins","top","customTickValues","tickValues","generateNumericTicks","call","attr","style","xScale","getMultiLevelD3DateFormatter","startLevel","endLevel","locale","useUTC","DEFAULT","MS","MS_S","MS_S_MIN","MS_S_MIN_H","MS_S_MIN_H_D","MS_S_MIN_H_D_W","MS_S_MIN_H_D_W_M","MS_S_MIN_H_D_W_M_Y","S","S_MIN","S_MIN_H","S_MIN_H_D","S_MIN_H_D_W","S_MIN_H_D_W_M","S_MIN_H_D_W_M_Y","MIN","MIN_H","MIN_H_D","MIN_H_D_W","MIN_H_D_W_M","MIN_H_D_W_M_Y","H","H_D","H_D_W","H_D_W_M","H_D_W_M_Y","D","D_W","D_W_M","D_W_M_Y","W","W_M","W_M_Y","M","M_Y","Y","MULTI_LEVEL_DATE_TIME_FORMATS","getDateFormatLevel","date","formats","formatLevel","condition","d","matchedFormat","find","createDateXAxis","options","customDateTimeFormatter","isUtcSet","lowestFormatLevel","highestFormatLevel","undefined","forEach","formatOptions","formatFn","maxPossibleTickCount","generateDateTicks","createStringXAxis","dataset","xAxisPadding","xAxisInnerPadding","xAxisOuterPadding","containerWidth","paddingInner","paddingOuter","nonOverlappingTickValues","tickSizes","sign","length","tickPosition","push","reverse","useRtl","dir","isPowerOf10","num","roundedfinalYMax","handleFloatingPointPrecisionError","log10","rounded","round","calculateRoundedTicks","minVal","maxVal","splitInto","finalYmin","finalYmax","ticksInterval","pop","prepareDatapoints","isIntegralDataset","roundedTicks","val","ceil","dataPointsArray","createYAxisForHorizontalBarChartWithAxis","yAxisParams","isRtl","yMinMaxValues","startValue","endValue","yAxisElement","yMaxValue","yMinValue","maxOfYVal","yAxisTickFormat","yAxisTickCount","tempVal","yAxisScale","bottom","axis","yAxis","createNumericYAxis","axisData","useSecondaryYScale","eventAnnotationProps","eventLabelHeight","domainValues","yMin","yMax","yPadding","scaleDomain","domainStart","domainEnd","left","right","yAxisDomainValues","index","createStringYAxisForHorizontalBarChartWithAxis","dataPoints","barWidth","yAxisPadding","yAxisPaddingValue","padding","createStringYAxis","calloutData","values","combinedResult","line","elements","data","filter","point","hideCallout","legend","color","concat","xValToDataPoints","ele","xValue","x","Date","getTime","y","xAxisCalloutData","yAxisCalloutData","callOutAccessibilityData","getUnique","arr","comp","unique","e","final","indexOf","silceOrAppendToArray","array","pos","slice","DEFAULT_WRAP_WIDTH","createWrapOfXLabels","wrapLabelProps","node","noOfCharsToTruncate","showXAxisLablesTooltip","width","axisNode","removeVal","maxLines","each","text","totalWord","truncatedWord","totalWordLength","words","split","word","lineNumber","lineHeight","dy","parseFloat","tspan","append","join","getComputedTextLength","maxHeight","outerHTMLElement","document","getElementById","BoxCordinates","getBoundingClientRect","boxHeight","height","createYAxisLabels","truncateLabel","tickIndex","dx","uid","wrapContent","content","id","maxWidth","textElement","isOverflowing","textLength","calculateLongestLabelWidth","labels","query","maxLabelWidth","canvas","createElement","ctx","getContext","axisText","querySelector","styles","window","getComputedStyle","fontWeight","getPropertyValue","fontSize","fontFamily","font","label","measureText","toString","tooltipOfAxislabels","axistooltipProps","tooltipCls","div","aa","_groups","baseSpanLength","Object","keys","originalDataArray","originalData","tickObject","tickObjectLength","d1","on","event","html","pageX","pageY","getXAxisType","points","isXAxisDateType","chartData","domainRangeOfNumericForAreaLineScatterCharts","isRTL","hasMarkersMode","isScatterPolar","isScatterPolarSeries","xMin","xMax","getScatterXDomainExtent","xPadding","getDomainPaddingForMarkers","groupChartDataByYValue","dataPoint","key","computeLongestBars","stackedChartData","X_ORIGIN","longestPositiveBar","longestNegativeBar","group","positiveBarTotal","reduce","acc","negativeBarTotal","domainRangeOfNumericForHorizontalBarChartWithAxis","shiftX","longestBars","rMin","rMax","domainRangeOfXStringAxis","domainRangeOfVSBCNumeric","domainRangeOfDateForAreaLineScatterVerticalBarCharts","sDate","lDate","domainRangeOfVerticalNumeric","findNumericMinMaxOfY","yAxisType","isValidDomainValue","findVSBCNumericMinMaxOfY","findVerticalNumericMinMaxOfY","lineData","findHBCWANumericMinMaxOfY","getTypeOfAxis","p","isXAxis","Points","CustomPoints","pointTypes","widthRatio","getAccessibleDataObject","accessibleData","role","isDataFocusable","ariaLabel","ariaLabelledBy","ariaDescribedBy","rotateXAxisLabels","rotateLabelProps","xAxisTranslations","translateValue","getAttribute","translatePair","substring","setAttribute","idx","wrapTextInsideDonut","selectorClass","formatScientificLimitWidth","DEFAULT_BAR_WIDTH","MIN_BAR_WIDTH","getBarWidth","barWidthProp","maxBarWidthProp","adjustedValue","modeProp","getScalePadding","prop","shorthandProp","defaultValue","isScalePaddingDefined","findIndex","cb","fromIndex","HighContrastSelector","HighContrastSelectorWhite","HighContrastSelectorBlack","formatDate","areArraysEqual","arr1","arr2","cssVarRegExp","resolveCSSVariables","chartContainer","styleRules","containerStyles","match","group1","getSecureProps","props","dangerouslySetInnerHTML","result","getCurveFactory","curve","defaultFactory","truncateString","str","maxLength","ellipsis","categoryOrderRegex","sortAxisCategories","categoryToValues","categoryOrder","Array","isArray","seen","Set","category","has","add","aggregator","order","sort","aggFn","total","sortAscending","a","b","sortDescending","categoriesAggregatedValue","copyStyle","properties","fromEl","toEl","entries","fromProp","toProp","measurementSpanCounter","getUniqueMeasurementSpanId","MEASUREMENT_SPAN_STYLE","position","visibility","margin","border","whiteSpace","createMeasurementSpan","className","parentElement","MEASUREMENT_SPAN_ID","measurementSpan","appendChild","body","assign","textContent","some","item","lineOptions","mode","isTextMode","defaultPadding","isPlottable","isValidDataPointForScale","getRangeForScatterMarkerSize","yScalePrimary","yScaleSecondary","xScaleType","yScaleType","primaryYScaleType","secondaryYScaleType","scaleXMin","scaleXMax","extraXPixels","scaleYMin","scaleYMax","yScale","extraYPixels","generateLinearTicks","domainMin","domainMax","precision","calculatePrecision","precisionRound","generateMonthlyTicks","tickStepInMonths","getMonth","getUTCMonth","setMonth","month","setUTCMonth","firstTick","baseMonth","tickDate","setUTCDate","setDate","refTick","t","pow","prefix","Number","groups","exec","String","base","exp","findCalloutPoints","calloutPointsByX"],"mappings":"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"}