'use client';
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "SVGTooltipText", {
    enumerable: true,
    get: function() {
        return SVGTooltipText;
    }
});
const _interop_require_wildcard = require("@swc/helpers/_/_interop_require_wildcard");
const _react = /*#__PURE__*/ _interop_require_wildcard._(require("react"));
const _reactsharedcontexts = require("@fluentui/react-shared-contexts");
const _reacttooltip = require("@fluentui/react-tooltip");
const _asyncutils = require("./async-utils");
const _KeyCodes = require("./KeyCodes");
const _reactutilities = require("@fluentui/react-utilities");
const SVGTooltipText = /*#__PURE__*/ _react.forwardRef((props, forwardedRef)=>{
    var _props_textProps, _props_textProps1, _props_textProps2;
    const [isTooltipVisible, setIsTooltipVisible] = (0, _react.useState)(false);
    const [isOverflowing, setIsOverflowing] = (0, _react.useState)(false);
    const [textWidth, setTextWidth] = (0, _react.useState)(0);
    const [textHeight, setTextHeight] = (0, _react.useState)(0);
    const tooltipHostRef = (0, _react.useRef)(null);
    const async = (0, _react.useRef)(new _asyncutils.Async()).current;
    const dismissTimerId = (0, _react.useRef)();
    const openTimerId = (0, _react.useRef)();
    const tooltipHostId = (0, _react.useRef)((0, _reactutilities.useId)('tooltip-host')).current;
    const ignoreNextFocusEvent = (0, _react.useRef)(false);
    const portalMountNode = (0, _reactsharedcontexts.usePortalMountNode)();
    const PADDING = 3;
    const wrapContentCallback = (0, _react.useCallback)(()=>{
        var _props_maxWidth;
        if (props.content && props.wrapContent && props.wrapContent(props.content, tooltipHostId, (_props_maxWidth = props.maxWidth) !== null && _props_maxWidth !== void 0 ? _props_maxWidth : 100, props.maxHeight)) {
            setIsOverflowing(true);
        } else {
            setIsOverflowing(false);
        }
    }, [
        props,
        tooltipHostId
    ]);
    const measureText = (0, _react.useCallback)(()=>{
        if (tooltipHostRef.current && typeof tooltipHostRef.current.getBBox === 'function') {
            const bbox = tooltipHostRef.current.getBBox();
            setTextWidth(bbox.width);
            setTextHeight(bbox.height);
        }
    }, []);
    (0, _react.useEffect)(()=>{
        wrapContentCallback();
        return ()=>{
            async.dispose();
        };
    }, [
        wrapContentCallback,
        async
    ]);
    (0, _react.useEffect)(()=>{
        wrapContentCallback();
    }, [
        props.maxWidth,
        props.maxHeight,
        wrapContentCallback
    ]);
    (0, _react.useEffect)(()=>{
        if (isTooltipVisible) {
            measureText();
        }
    }, [
        isTooltipVisible,
        measureText
    ]);
    (0, _react.useEffect)(()=>{
        // Recalculate text dimensions when content or dimensions change
        measureText();
    }, [
        props.content,
        props.textProps,
        props.maxWidth,
        props.maxHeight,
        measureText
    ]);
    const hideTooltip = (0, _react.useCallback)(()=>{
        async.clearTimeout(openTimerId.current);
        async.clearTimeout(dismissTimerId.current);
        setIsTooltipVisible(false);
    }, [
        async
    ]);
    const onTooltipMouseEnter = (0, _react.useCallback)((ev)=>{
        if (!isOverflowing) {
            return;
        }
        if (ev.target && (portalMountNode === null || portalMountNode === void 0 ? void 0 : portalMountNode.contains(ev.target))) {
            return;
        }
        async.clearTimeout(dismissTimerId.current);
        async.clearTimeout(openTimerId.current);
        if (props.delay !== 0) {
            openTimerId.current = async.setTimeout(()=>{
                setIsTooltipVisible(true);
            }, props.delay);
        } else {
            setIsTooltipVisible(true);
        }
    }, [
        isOverflowing,
        portalMountNode,
        async,
        props.delay
    ]);
    const onTooltipMouseLeave = (0, _react.useCallback)((ev)=>{
        async.clearTimeout(dismissTimerId.current);
        async.clearTimeout(openTimerId.current);
        if (props.closeDelay) {
            dismissTimerId.current = async.setTimeout(()=>{
                setIsTooltipVisible(false);
            }, props.closeDelay);
        } else {
            setIsTooltipVisible(false);
        }
    }, [
        async,
        props.closeDelay
    ]);
    const onTooltipFocus = (0, _react.useCallback)((ev)=>{
        if (ignoreNextFocusEvent.current) {
            ignoreNextFocusEvent.current = false;
            return;
        }
        onTooltipMouseEnter(ev);
    }, [
        onTooltipMouseEnter
    ]);
    const onTooltipBlur = (0, _react.useCallback)((ev)=>{
        var _document;
        ignoreNextFocusEvent.current = ((_document = document) === null || _document === void 0 ? void 0 : _document.activeElement) === ev.target;
        dismissTimerId.current = async.setTimeout(()=>{
            setIsTooltipVisible(false);
        }, 0);
    }, [
        async
    ]);
    const onTooltipKeyDown = (0, _react.useCallback)((ev)=>{
        // eslint-disable-next-line @typescript-eslint/no-deprecated
        if ((ev.which === _KeyCodes.KeyCodes.escape || ev.ctrlKey) && isTooltipVisible) {
            hideTooltip();
            ev.stopPropagation();
        }
    }, [
        isTooltipVisible,
        hideTooltip
    ]);
    const showTooltip = props.isTooltipVisibleProp && isOverflowing && !!props.content || isTooltipVisible && !!props.content;
    const rectX = (typeof ((_props_textProps = props.textProps) === null || _props_textProps === void 0 ? void 0 : _props_textProps.x) === 'number' ? props.textProps.x : 0) - (textWidth !== null && textWidth !== void 0 ? textWidth : 0) / 2 - PADDING;
    const rectY = (typeof ((_props_textProps1 = props.textProps) === null || _props_textProps1 === void 0 ? void 0 : _props_textProps1.y) === 'number' ? props.textProps.y : 0) - (textHeight !== null && textHeight !== void 0 ? textHeight : 0) / 2 - 2 * PADDING;
    return /*#__PURE__*/ _react.createElement(_react.Fragment, null, props.showBackground && /*#__PURE__*/ _react.createElement("rect", {
        x: rectX,
        y: rectY,
        width: (textWidth !== null && textWidth !== void 0 ? textWidth : 0) + 2 * PADDING,
        height: (textHeight !== null && textHeight !== void 0 ? textHeight : 0) + PADDING,
        transform: (_props_textProps2 = props.textProps) === null || _props_textProps2 === void 0 ? void 0 : _props_textProps2.transform,
        className: props.className
    }), /*#__PURE__*/ _react.createElement(_reacttooltip.Tooltip, {
        relationship: "description",
        ...props.tooltipProps,
        withArrow: true,
        content: props.content,
        // targetElement={getTargetElement()} ToDo - This assignment is causing build failure. Needs to be fixed.
        visible: showTooltip
    }, /*#__PURE__*/ _react.createElement("text", {
        ...props.textProps,
        id: tooltipHostId,
        ref: tooltipHostRef,
        onFocusCapture: onTooltipFocus,
        onBlurCapture: onTooltipBlur,
        onMouseEnter: onTooltipMouseEnter,
        onMouseLeave: onTooltipMouseLeave,
        onKeyDown: onTooltipKeyDown,
        "data-is-focusable": props.shouldReceiveFocus && isOverflowing
    }, props.content)));
});
// eslint-disable-next-line @typescript-eslint/no-deprecated
SVGTooltipText.defaultProps = {
    delay: 0,
    showBackground: false
};
