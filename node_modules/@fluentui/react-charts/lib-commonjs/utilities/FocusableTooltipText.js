'use client';
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "FocusableTooltipText", {
    enumerable: true,
    get: function() {
        return FocusableTooltipText;
    }
});
const _interop_require_wildcard = require("@swc/helpers/_/_interop_require_wildcard");
const _react = /*#__PURE__*/ _interop_require_wildcard._(require("react"));
const _reacttooltip = require("@fluentui/react-tooltip");
const _overflowutils = require("./overflow-utils");
const _index = require("./index");
const _asyncutils = require("./async-utils");
const FocusableTooltipText = /*#__PURE__*/ _react.forwardRef((props, forwardedRef)=>{
    const [textOverflow, setTextOverflow] = (0, _react.useState)(false);
    const tooltipChild = (0, _react.useRef)(null);
    const async = (0, _react.useRef)(new _asyncutils.Async()).current;
    const resizeObserver = (0, _react.useRef)();
    const getTargetElement = (0, _react.useCallback)(()=>{
        if (!tooltipChild.current || !tooltipChild.current.parentElement) {
            return undefined;
        }
        return tooltipChild.current.parentElement;
    }, [
        tooltipChild
    ]);
    const checkTextOverflow = (0, _react.useCallback)(()=>{
        const overflowElement = getTargetElement();
        const isTextOverflow = !!overflowElement && (0, _overflowutils.hasOverflow)(overflowElement);
        if (isTextOverflow !== textOverflow) {
            setTextOverflow(isTextOverflow);
        }
    }, [
        getTargetElement,
        textOverflow,
        setTextOverflow
    ]);
    (0, _react.useEffect)(()=>{
        checkTextOverflow();
    }, [
        checkTextOverflow
    ]);
    (0, _react.useEffect)(()=>{
        // setup part executed only when the component mounts/updates
        const overflowElement = getTargetElement();
        if (window.ResizeObserver && overflowElement) {
            resizeObserver.current = new window.ResizeObserver(async.debounce(checkTextOverflow, 500));
            resizeObserver.current.observe(overflowElement);
        }
        // cleanup part executed only when the component unmounts
        return ()=>{
            var _resizeObserver_current;
            (_resizeObserver_current = resizeObserver.current) === null || _resizeObserver_current === void 0 ? void 0 : _resizeObserver_current.disconnect();
            async.dispose();
        };
    }, [
        async,
        checkTextOverflow,
        getTargetElement
    ]);
    return /*#__PURE__*/ _react.createElement("div", {
        className: props.className
    }, /*#__PURE__*/ _react.createElement(_reacttooltip.Tooltip, {
        content: props.content,
        relationship: "description"
    }, /*#__PURE__*/ _react.createElement("span", {
        ...(0, _index.getAccessibleDataObject)(props.accessibilityData),
        ref: tooltipChild,
        "data-is-focusable": textOverflow
    }, props.content)));
});
