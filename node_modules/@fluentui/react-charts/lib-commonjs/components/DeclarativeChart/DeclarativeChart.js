'use client';
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "DeclarativeChart", {
    enumerable: true,
    get: function() {
        return DeclarativeChart;
    }
});
const _interop_require_wildcard = require("@swc/helpers/_/_interop_require_wildcard");
const _react = /*#__PURE__*/ _interop_require_wildcard._(require("react"));
const _chartutilities = require("@fluentui/chart-utilities");
const _reacttheme = require("@fluentui/react-theme");
const _reactsharedcontexts = require("@fluentui/react-shared-contexts");
const _tokens = require("@fluentui/tokens");
const _d3color = /*#__PURE__*/ _interop_require_wildcard._(require("d3-color"));
const _PlotlySchemaAdapter = require("./PlotlySchemaAdapter");
const _index = require("../DonutChart/index");
const _index1 = require("../VerticalStackedBarChart/index");
const _index2 = require("../LineChart/index");
const _index3 = require("../HorizontalBarChartWithAxis/index");
const _index4 = require("../AreaChart/index");
const _index5 = require("../HeatMapChart/index");
const _SankeyChart = require("../SankeyChart/SankeyChart");
const _index6 = require("../GaugeChart/index");
const _index7 = require("../GroupedVerticalBarChart/index");
const _index8 = require("../VerticalBarChart/index");
const _index9 = require("../ScatterChart/index");
const _FunnelChart = require("../FunnelChart/FunnelChart");
const _index10 = require("../GanttChart/index");
const _withResponsiveContainer = require("../ResponsiveContainer/withResponsiveContainer");
const _index11 = require("../ChartTable/index");
const _index12 = require("../Legends/index");
const ResponsiveDonutChart = (0, _withResponsiveContainer.withResponsiveContainer)(_index.DonutChart);
const ResponsiveVerticalStackedBarChart = (0, _withResponsiveContainer.withResponsiveContainer)(_index1.VerticalStackedBarChart);
const ResponsiveLineChart = (0, _withResponsiveContainer.withResponsiveContainer)(_index2.LineChart);
const ResponsiveHorizontalBarChartWithAxis = (0, _withResponsiveContainer.withResponsiveContainer)(_index3.HorizontalBarChartWithAxis);
const ResponsiveAreaChart = (0, _withResponsiveContainer.withResponsiveContainer)(_index4.AreaChart);
const ResponsiveHeatMapChart = (0, _withResponsiveContainer.withResponsiveContainer)(_index5.HeatMapChart);
const ResponsiveSankeyChart = (0, _withResponsiveContainer.withResponsiveContainer)(_SankeyChart.SankeyChart);
const ResponsiveGaugeChart = (0, _withResponsiveContainer.withResponsiveContainer)(_index6.GaugeChart);
const ResponsiveGroupedVerticalBarChart = (0, _withResponsiveContainer.withResponsiveContainer)(_index7.GroupedVerticalBarChart);
const ResponsiveVerticalBarChart = (0, _withResponsiveContainer.withResponsiveContainer)(_index8.VerticalBarChart);
const ResponsiveScatterChart = (0, _withResponsiveContainer.withResponsiveContainer)(_index9.ScatterChart);
const ResponsiveChartTable = (0, _withResponsiveContainer.withResponsiveContainer)(_index11.ChartTable);
const ResponsiveGanttChart = (0, _withResponsiveContainer.withResponsiveContainer)(_index10.GanttChart);
// Removing responsive wrapper for FunnelChart as responsive container is not working with FunnelChart
//const ResponsiveFunnelChart = withResponsiveContainer(FunnelChart);
// Default x-axis key for grouping traces. Also applicable for PieData and SankeyData where x-axis is not defined.
const DEFAULT_XAXIS = 'x';
const useColorMapping = ()=>{
    const colorMap = _react.useRef(new Map());
    return colorMap;
};
function renderChart(Renderer, transformer, transformerArgs, commonProps, cellRow, cellColumn) {
    const chartProps = transformer(...transformerArgs);
    return /*#__PURE__*/ _react.createElement("div", {
        key: `${cellRow}_${cellColumn}`,
        style: {
            gridRowStart: cellRow,
            gridRowEnd: cellRow + 1,
            gridColumnStart: cellColumn,
            gridColumnEnd: cellColumn + 1
        }
    }, /*#__PURE__*/ _react.createElement(Renderer, {
        ...chartProps,
        ...commonProps
    }));
}
const LineAreaPreTransformOp = (plotlyInput)=>{
    const xValues = plotlyInput.data[0].x;
    const isXMonth = (0, _chartutilities.isMonthArray)(xValues);
    let renderData = plotlyInput.data;
    if (isXMonth) {
        renderData = plotlyInput.data.map((dataPoint)=>({
                ...dataPoint,
                x: (0, _PlotlySchemaAdapter.correctYearMonth)(dataPoint.x)
            }));
    }
    return {
        data: renderData,
        layout: plotlyInput.layout
    };
};
const chartMap = {
    // PieData category charts
    donut: {
        transformer: _PlotlySchemaAdapter.transformPlotlyJsonToDonutProps,
        renderer: ResponsiveDonutChart
    },
    // SankeyData category charts
    sankey: {
        transformer: _PlotlySchemaAdapter.transformPlotlyJsonToSankeyProps,
        renderer: ResponsiveSankeyChart
    },
    // TableData category charts
    table: {
        transformer: _PlotlySchemaAdapter.transformPlotlyJsonToChartTableProps,
        renderer: ResponsiveChartTable
    },
    // PlotData category charts
    horizontalbar: {
        transformer: _PlotlySchemaAdapter.transformPlotlyJsonToHorizontalBarWithAxisProps,
        renderer: ResponsiveHorizontalBarChartWithAxis
    },
    groupedverticalbar: {
        transformer: _PlotlySchemaAdapter.transformPlotlyJsonToGVBCProps,
        renderer: ResponsiveGroupedVerticalBarChart
    },
    verticalstackedbar: {
        transformer: _PlotlySchemaAdapter.transformPlotlyJsonToVSBCProps,
        renderer: ResponsiveVerticalStackedBarChart
    },
    heatmap: {
        transformer: _PlotlySchemaAdapter.transformPlotlyJsonToHeatmapProps,
        renderer: ResponsiveHeatMapChart
    },
    gauge: {
        transformer: _PlotlySchemaAdapter.transformPlotlyJsonToGaugeProps,
        renderer: ResponsiveGaugeChart
    },
    verticalbar: {
        transformer: _PlotlySchemaAdapter.transformPlotlyJsonToVBCProps,
        renderer: ResponsiveVerticalBarChart
    },
    area: {
        transformer: _PlotlySchemaAdapter.transformPlotlyJsonToAreaChartProps,
        renderer: ResponsiveAreaChart,
        preTransformOperation: LineAreaPreTransformOp
    },
    line: {
        transformer: _PlotlySchemaAdapter.transformPlotlyJsonToLineChartProps,
        renderer: ResponsiveLineChart,
        preTransformOperation: LineAreaPreTransformOp
    },
    scatter: {
        transformer: _PlotlySchemaAdapter.transformPlotlyJsonToScatterChartProps,
        renderer: ResponsiveScatterChart,
        preTransformOperation: LineAreaPreTransformOp
    },
    gantt: {
        transformer: _PlotlySchemaAdapter.transformPlotlyJsonToGanttChartProps,
        renderer: ResponsiveGanttChart
    },
    funnel: {
        transformer: _PlotlySchemaAdapter.transformPlotlyJsonToFunnelChartProps,
        renderer: _FunnelChart.FunnelChart
    },
    fallback: {
        transformer: _PlotlySchemaAdapter.transformPlotlyJsonToVSBCProps,
        renderer: ResponsiveVerticalStackedBarChart
    }
};
const useIsDarkTheme = ()=>{
    const parentV9Theme = _react.useContext(_reactsharedcontexts.ThemeContext_unstable);
    const v9Theme = parentV9Theme ? parentV9Theme : _tokens.webLightTheme;
    // Get background and foreground colors
    const backgroundColor = _d3color.hsl(v9Theme.colorNeutralBackground1);
    const foregroundColor = _d3color.hsl(v9Theme.colorNeutralForeground1);
    const isDarkTheme = backgroundColor.l < foregroundColor.l;
    return isDarkTheme;
};
const DeclarativeChart = /*#__PURE__*/ _react.forwardRef((props, forwardedRef)=>{
    const { plotlySchema } = (0, _chartutilities.sanitizeJson)(props.chartSchema);
    const chart = (0, _chartutilities.mapFluentChart)(plotlySchema);
    if (!chart.isValid) {
        throw new Error(`Invalid chart schema: ${chart.errorMessage}`);
    }
    let plotlyInput = plotlySchema;
    try {
        plotlyInput = (0, _chartutilities.decodeBase64Fields)(plotlyInput);
    } catch (error) {
        throw new Error(`Failed to decode plotly schema: ${error}`);
    }
    const plotlyInputWithValidData = {
        ...plotlyInput,
        data: chart.validTracesInfo.map((trace)=>plotlyInput.data[trace.index])
    };
    const validTracesFilteredIndex = chart.validTracesInfo.map((trace, index)=>({
            index,
            type: trace.type
        }));
    let { selectedLegends } = plotlySchema;
    const colorMap = useColorMapping();
    const isDarkTheme = useIsDarkTheme();
    const chartRef = _react.useRef(null);
    const isMultiPlot = _react.useRef(false);
    if (!(0, _chartutilities.isArrayOrTypedArray)(selectedLegends)) {
        selectedLegends = [];
    }
    const [activeLegends, setActiveLegends] = _react.useState(selectedLegends);
    const onActiveLegendsChange = (keys)=>{
        setActiveLegends(keys);
        if (props.onSchemaChange) {
            props.onSchemaChange({
                plotlySchema: {
                    plotlyInput,
                    selectedLegends: keys
                }
            });
        }
    };
    _react.useEffect(()=>{
        // eslint-disable-next-line @typescript-eslint/no-shadow
        const { plotlySchema } = (0, _chartutilities.sanitizeJson)(props.chartSchema);
        // eslint-disable-next-line @typescript-eslint/no-shadow
        const { selectedLegends } = plotlySchema;
        setActiveLegends(selectedLegends !== null && selectedLegends !== void 0 ? selectedLegends : []);
    }, [
        props.chartSchema
    ]);
    const multiSelectLegendProps = {
        canSelectMultipleLegends: true,
        onChange: onActiveLegendsChange,
        selectedLegends: activeLegends
    };
    const commonProps = {
        legendProps: multiSelectLegendProps,
        componentRef: chartRef
    };
    function createLegends(legendProps) {
        // eslint-disable-next-line react/jsx-no-bind
        return /*#__PURE__*/ _react.createElement(_index12.Legends, {
            ...legendProps,
            selectedLegends: activeLegends,
            onChange: onActiveLegendsChange
        });
    }
    // TODO
    const exportAsImage = _react.useCallback((opts)=>{
        return new Promise((resolve, reject)=>{
            if (isMultiPlot.current) {
                return reject(Error('Exporting multi plot charts as image is not supported'));
            }
            if (!chartRef.current || typeof chartRef.current.toImage !== 'function') {
                return reject(Error('Chart cannot be exported as image'));
            }
            chartRef.current.toImage({
                background: _reacttheme.tokens.colorNeutralBackground1,
                scale: 5,
                ...opts
            }).then(resolve).catch(reject);
        });
    }, []);
    _react.useImperativeHandle(props.componentRef, ()=>({
            exportAsImage
        }), [
        exportAsImage
    ]);
    if (chart.type === 'scatterpolar') {
        const cartesianProjection = (0, _PlotlySchemaAdapter.projectPolarToCartesian)(plotlyInputWithValidData);
        plotlyInputWithValidData.data = cartesianProjection.data;
        plotlyInputWithValidData.layout = cartesianProjection.layout;
        validTracesFilteredIndex.forEach((trace, index)=>{
            if (trace.type === 'scatterpolar') {
                var _plotlyInputWithValidData_data_index;
                var _plotlyInputWithValidData_data_index_mode;
                const mode = (_plotlyInputWithValidData_data_index_mode = (_plotlyInputWithValidData_data_index = plotlyInputWithValidData.data[index]) === null || _plotlyInputWithValidData_data_index === void 0 ? void 0 : _plotlyInputWithValidData_data_index.mode) !== null && _plotlyInputWithValidData_data_index_mode !== void 0 ? _plotlyInputWithValidData_data_index_mode : '';
                if (mode.includes('line')) {
                    validTracesFilteredIndex[index].type = 'line';
                } else if (mode.includes('markers') || mode === 'text') {
                    validTracesFilteredIndex[index].type = 'scatter';
                } else {
                    validTracesFilteredIndex[index].type = 'line';
                }
            }
        });
    }
    const groupedTraces = {};
    let nonCartesianTraceCount = 0;
    plotlyInputWithValidData.data.forEach((trace, index)=>{
        let traceKey = '';
        if ((0, _PlotlySchemaAdapter.isNonPlotType)(chart.validTracesInfo[index].type)) {
            traceKey = `${_PlotlySchemaAdapter.NON_PLOT_KEY_PREFIX}${nonCartesianTraceCount + 1}`;
            nonCartesianTraceCount++;
        } else {
            var _trace_xaxis;
            traceKey = (_trace_xaxis = trace.xaxis) !== null && _trace_xaxis !== void 0 ? _trace_xaxis : DEFAULT_XAXIS;
        }
        if (!groupedTraces[traceKey]) {
            groupedTraces[traceKey] = [];
        }
        groupedTraces[traceKey].push(index);
    });
    isMultiPlot.current = Object.keys(groupedTraces).length > 1;
    const gridProperties = (0, _PlotlySchemaAdapter.getGridProperties)(plotlyInputWithValidData, isMultiPlot.current, chart.validTracesInfo);
    // Render only one plot if the grid properties cannot determine positioning of multiple plots.
    if (isMultiPlot.current && gridProperties.templateRows === _PlotlySchemaAdapter.SINGLE_REPEAT && gridProperties.templateColumns === _PlotlySchemaAdapter.SINGLE_REPEAT) {
        if (chart.type === 'donut') {
            // If there are multiple data traces for donut/pie, picking the last one similar to plotly
            const keys = Object.keys(groupedTraces);
            keys.forEach((key, index)=>{
                if (index < keys.length - 1) {
                    delete groupedTraces[key];
                }
            });
        } else {
            Object.keys(groupedTraces).forEach((key, index)=>{
                if (index > 0) {
                    delete groupedTraces[key];
                }
            });
        }
        isMultiPlot.current = false;
    }
    const allupLegendsProps = (0, _PlotlySchemaAdapter.getAllupLegendsProps)(plotlyInputWithValidData, colorMap, props.colorwayType, chart.validTracesInfo, isDarkTheme);
    // map through the grouped traces and render the appropriate chart
    return /*#__PURE__*/ _react.createElement(_react.Fragment, null, /*#__PURE__*/ _react.createElement("div", {
        style: {
            display: 'grid',
            gridTemplateRows: gridProperties.templateRows,
            gridTemplateColumns: gridProperties.templateColumns
        }
    }, Object.entries(groupedTraces).map(([xAxisKey, index])=>{
        const plotlyInputForGroup = {
            ...plotlyInputWithValidData,
            data: index.map((idx)=>plotlyInputWithValidData.data[idx])
        };
        const filteredTracesInfo = validTracesFilteredIndex.filter((trace)=>index.includes(trace.index));
        let chartType = chart.type === 'fallback' || chart.type === 'groupedverticalbar' ? chart.type : filteredTracesInfo[0].type;
        if (validTracesFilteredIndex.some((trace)=>trace.type === 'line') && validTracesFilteredIndex.some((trace)=>trace.type === 'scatter')) {
            chartType = 'line';
        }
        const chartEntry = chartMap[chartType];
        if (chartEntry) {
            const { transformer, renderer, preTransformCondition, preTransformOperation } = chartEntry;
            if (preTransformCondition === undefined || preTransformCondition(plotlyInputForGroup)) {
                const transformedInput = preTransformOperation ? preTransformOperation(plotlyInputForGroup) : plotlyInputForGroup;
                const cellProperties = gridProperties.layout[xAxisKey];
                var _cellProperties_row, _cellProperties_column;
                return renderChart(renderer, transformer, [
                    transformedInput,
                    isMultiPlot.current,
                    colorMap,
                    props.colorwayType,
                    isDarkTheme
                ], {
                    ...commonProps,
                    xAxisAnnotation: cellProperties === null || cellProperties === void 0 ? void 0 : cellProperties.xAnnotation,
                    yAxisAnnotation: cellProperties === null || cellProperties === void 0 ? void 0 : cellProperties.yAnnotation
                }, (_cellProperties_row = cellProperties === null || cellProperties === void 0 ? void 0 : cellProperties.row) !== null && _cellProperties_row !== void 0 ? _cellProperties_row : 1, (_cellProperties_column = cellProperties === null || cellProperties === void 0 ? void 0 : cellProperties.column) !== null && _cellProperties_column !== void 0 ? _cellProperties_column : 1);
            }
            return /*#__PURE__*/ _react.createElement(_react.Fragment, null);
        } else {
            var _plotlyInputForGroup_data_;
            throw new Error(`Unsupported chart type :${(_plotlyInputForGroup_data_ = plotlyInputForGroup.data[0]) === null || _plotlyInputForGroup_data_ === void 0 ? void 0 : _plotlyInputForGroup_data_.type}`);
        }
    })), isMultiPlot.current && createLegends(allupLegendsProps));
});
DeclarativeChart.displayName = 'DeclarativeChart';
DeclarativeChart.defaultProps = {
    colorwayType: 'default'
};
