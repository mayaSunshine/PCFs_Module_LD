{"version":3,"sources":["../src/components/LineChart/eventAnnotation/EventAnnotation.tsx"],"sourcesContent":["import * as React from 'react';\nimport { ScaleTime } from 'd3-scale';\nimport { tokens } from '@fluentui/react-theme';\nimport { findIndex } from '../../../utilities/index';\nimport { LineDef, LabelLink, LabelDef } from './LabelLink';\nimport { EventsAnnotationProps } from '../LineChart.types';\nimport { getColorFromToken } from '../../../utilities/colors';\n\ninterface IEventsAnnotationExtendProps extends EventsAnnotationProps {\n  scale: ScaleTime<number, number>;\n  chartYBottom: number;\n  chartYTop: number;\n}\n\nexport const EventsAnnotation: React.FunctionComponent<IEventsAnnotationExtendProps> = props => {\n  const textWidth = props.labelWidth ? props.labelWidth : 105;\n  const textY = props.chartYTop - 20;\n  const lineTopY = textY + 7;\n  const textPadding = 5;\n  const lineHeight = 18;\n  const fontSize = '10pt';\n  const axisRange = props.scale.range();\n\n  const lineDefs: LineDef[] = props.events.map(e => ({ ...e, x: props.scale(e.date) }));\n\n  lineDefs.sort((e1, e2) => +e1.date - +e2.date);\n\n  const fill: string | undefined = props.strokeColor\n    ? getColorFromToken(props.strokeColor, false /*ToDo fix */)\n    : tokens.colorNeutralForeground1;\n\n  const lines = uniqBy(lineDefs, x => x.date.toString()).map((x, i) => (\n    <line key={i} x1={x.x} x2={x.x} y1={lineTopY} y2={props.chartYBottom} stroke={fill} strokeDasharray=\"8\" />\n  ));\n\n  const labelLinks = calculateLabels(lineDefs, textWidth + textPadding, axisRange[1], axisRange[0]).map((x, i) => (\n    <LabelLink\n      key={i}\n      {...{\n        lineDefs,\n        labelDef: x,\n        textY,\n        textWidth,\n        textLineHeight: lineHeight,\n        textFontSize: fontSize,\n        textColor: props.labelColor,\n        mergedLabel: props.mergedLabel,\n      }}\n    />\n  ));\n\n  return (\n    <>\n      {lines}\n      {labelLinks}\n    </>\n  );\n};\n\nfunction calculateLabels(lineDefs: LineDef[], textWidth: number, maxX: number, minX: number): LabelDef[] {\n  const calculateLabel = (lastX: number, currentIdx: number): LabelDef[] => {\n    // base case 1\n    if (currentIdx === lineDefs.length) {\n      return [];\n    }\n\n    const { x } = lineDefs[currentIdx];\n    const leftXBoundary = x - textWidth;\n\n    // cannot render on top of other text\n    if (x < lastX) {\n      return [];\n    }\n\n    // base case 2\n    if (currentIdx === lineDefs.length - 1) {\n      if (lastX < leftXBoundary) {\n        return [{ x: x, anchor: 'end', aggregatedIdx: [currentIdx] }];\n      } else if (x + textWidth < maxX) {\n        return [{ x: x, anchor: 'start', aggregatedIdx: [currentIdx] }];\n      }\n\n      return [];\n    }\n\n    if (lastX < leftXBoundary) {\n      // label on left side\n      return backtrack(currentIdx, 'end');\n    } else {\n      // label on right side\n      return backtrack(currentIdx, 'start');\n    }\n  };\n\n  const backtrack = (currentIdx: number, anchor: 'start' | 'end'): LabelDef[] => {\n    const bd = anchor === 'end' ? lineDefs[currentIdx].x : lineDefs[currentIdx].x + textWidth;\n\n    let idx = findIndex(\n      lineDefs,\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      ds => ds.x > bd && (ds.x - textWidth >= bd || ds.x + textWidth < maxX),\n      currentIdx + 1,\n    );\n    if (idx === -1) {\n      idx = lineDefs.length;\n    }\n\n    const aggregatedIdx: number[] = [];\n    for (let i = currentIdx; i < idx; i++) {\n      aggregatedIdx.push(i);\n    }\n    const next = calculateLabel(bd, idx);\n\n    next.unshift({ x: lineDefs[currentIdx].x, anchor, aggregatedIdx });\n    return next;\n  };\n\n  return calculateLabel(minX, 0);\n}\n\n/** Get unique items of `arr`, comparing based on the result of calling `iteratee` on each item. */\nfunction uniqBy<T>(arr: T[], iteratee: (x: T) => string): T[] {\n  const seen: string[] = [];\n  const result: T[] = [];\n  for (const x of arr) {\n    const comp = iteratee(x);\n    if (seen.indexOf(comp) === -1) {\n      result.push(x);\n      seen.push(comp);\n    }\n  }\n  return result;\n}\n"],"names":["React","tokens","findIndex","LabelLink","getColorFromToken","EventsAnnotation","props","textWidth","labelWidth","textY","chartYTop","lineTopY","textPadding","lineHeight","fontSize","axisRange","scale","range","lineDefs","events","map","e","x","date","sort","e1","e2","fill","strokeColor","colorNeutralForeground1","lines","uniqBy","toString","i","line","key","x1","x2","y1","y2","chartYBottom","stroke","strokeDasharray","labelLinks","calculateLabels","labelDef","textLineHeight","textFontSize","textColor","labelColor","mergedLabel","maxX","minX","calculateLabel","lastX","currentIdx","length","leftXBoundary","anchor","aggregatedIdx","backtrack","bd","idx","ds","push","next","unshift","arr","iteratee","seen","result","comp","indexOf"],"mappings":"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"}